     1                                  ; -*- fundamental -*- (asm-mode sucks)
     2                                  ; $Id: ldlinux.asm,v 1.147 2004/06/13 20:50:44 hpa Exp $
     3                                  ; ****************************************************************************
     4                                  ;
     5                                  ;  ldlinux.asm
     6                                  ;
     7                                  ;  A program to boot Linux kernels off an MS-DOS formatted floppy disk.	 This
     8                                  ;  functionality is good to have for installation floppies, where it may
     9                                  ;  be hard to find a functional Linux system to run LILO off.
    10                                  ;
    11                                  ;  This program allows manipulation of the disk to take place entirely
    12                                  ;  from MS-LOSS, and can be especially useful in conjunction with the
    13                                  ;  umsdos filesystem.
    14                                  ;
    15                                  ;  This file is loaded in stages; first the boot sector at offset 7C00h,
    16                                  ;  then the first sector (cluster, really, but we can only assume 1 sector)
    17                                  ;  of LDLINUX.SYS at 7E00h and finally the remainder of LDLINUX.SYS at 8000h.
    18                                  ;
    19                                  ;   Copyright (C) 1994-2004  H. Peter Anvin
    20                                  ;
    21                                  ;  This program is free software; you can redistribute it and/or modify
    22                                  ;  it under the terms of the GNU General Public License as published by
    23                                  ;  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
    24                                  ;  USA; either version 2 of the License, or (at your option) any later
    25                                  ;  version; incorporated herein by reference.
    26                                  ; 
    27                                  ; ****************************************************************************
    28                                  
    29                                  %ifndef IS_MDSLINUX
    30                                  %define IS_SYSLINUX 1
    31                                  %endif
    32                                  %include "macros.inc"
    33                              <1> ;; $Id: macros.inc,v 1.6 2003/04/16 02:49:31 hpa Exp $
    34                              <1> ;; -----------------------------------------------------------------------
    35                              <1> ;;   
    36                              <1> ;;   Copyright 1994-2003 H. Peter Anvin - All Rights Reserved
    37                              <1> ;;
    38                              <1> ;;   This program is free software; you can redistribute it and/or modify
    39                              <1> ;;   it under the terms of the GNU General Public License as published by
    40                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
    41                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
    42                              <1> ;;   (at your option) any later version; incorporated herein by reference.
    43                              <1> ;;
    44                              <1> ;; -----------------------------------------------------------------------
    45                              <1> 
    46                              <1> ;;
    47                              <1> ;; macros.inc
    48                              <1> ;; 
    49                              <1> ;; Convenient macros
    50                              <1> ;;
    51                              <1> 
    52                              <1> %ifndef _MACROS_INC
    53                              <1> %define _MACROS_INC
    54                              <1> 
    55                              <1> ;
    56                              <1> ; Identify the module we're compiling; the "correct" should be defined
    57                              <1> ; in the module itself to 1
    58                              <1> ;
    59                              <1> %ifndef IS_SYSLINUX
    60                              <1> %define IS_SYSLINUX 0
    61                              <1> %endif
    62                              <1> %ifndef IS_MDSLINUX
    63                              <1> %define IS_MDSLINUX 0
    64                              <1> %endif
    65                              <1> %ifndef IS_PXELINUX
    66                              <1> %define IS_PXELINUX 0
    67                              <1> %endif
    68                              <1> %ifndef IS_ISOLINUX
    69                              <1> %define IS_ISOLINUX 0
    70                              <1> %endif
    71                              <1> 
    72                              <1> ;
    73                              <1> ; Macros similar to res[bwd], but which works in the code segment (after
    74                              <1> ; section .text) or the data segment (section .data)
    75                              <1> ;
    76                              <1> %macro	zb	1.nolist
    77                              <1> 	times %1 db 0
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro	zw	1.nolist
    81                              <1> 	times %1 dw 0
    82                              <1> %endmacro
    83                              <1> 
    84                              <1> %macro	zd	1.nolist
    85                              <1> 	times %1 dd 0
    86                              <1> %endmacro
    87                              <1> 
    88                              <1> ;
    89                              <1> ; Macro to emit an unsigned decimal number as a string
    90                              <1> ;
    91                              <1> %macro asciidec	1.nolist
    92                              <1> %ifndef DEPEND	; Not safe for "depend"
    93                              <1> %if %1 >= 1000000000
    94                              <1> 	db ((%1/1000000000) % 10) + '0'
    95                              <1> %endif
    96                              <1> %if %1 >= 100000000
    97                              <1> 	db ((%1/100000000) % 10) + '0'
    98                              <1> %endif
    99                              <1> %if %1 >= 10000000
   100                              <1> 	db ((%1/10000000) % 10) + '0'
   101                              <1> %endif
   102                              <1> %if %1 >= 1000000
   103                              <1> 	db ((%1/1000000) % 10) + '0'
   104                              <1> %endif
   105                              <1> %if %1 >= 100000
   106                              <1> 	db ((%1/100000) % 10) + '0'
   107                              <1> %endif
   108                              <1> %if %1 >= 10000
   109                              <1> 	db ((%1/10000) % 10) + '0'
   110                              <1> %endif
   111                              <1> %if %1 >= 1000
   112                              <1> 	db ((%1/1000) % 10) + '0'
   113                              <1> %endif
   114                              <1> %if %1 >= 100
   115                              <1> 	db ((%1/100) % 10) + '0'
   116                              <1> %endif
   117                              <1> %if %1 >= 10
   118                              <1> 	db ((%1/10) % 10) + '0'
   119                              <1> %endif
   120                              <1> 	db (%1 % 10) + '0'
   121                              <1> %endif
   122                              <1> %endmacro
   123                              <1> 
   124                              <1> ;
   125                              <1> ; Macros for network byte order of constants
   126                              <1> ;
   127                              <1> %define htons(x)  ( ( ((x) & 0FFh) << 8 ) + ( ((x) & 0FF00h) >> 8 ) )
   128                              <1> %define ntohs(x) htons(x)
   129                              <1> %define htonl(x)  ( ( ((x) & 0FFh) << 24) + ( ((x) & 0FF00h) << 8 ) + ( ((x) & 0FF0000h) >> 8 ) + ( ((x) & 0FF000000h) >> 24) )
   130                              <1> %define ntohl(x) htonl(x)
   131                              <1> 
   132                              <1> %endif ; _MACROS_INC
   133                                  %include "config.inc"
   134                              <1> ;; $Id: config.inc,v 1.5 2004/01/29 06:31:49 hpa Exp $
   135                              <1> ;; -----------------------------------------------------------------------
   136                              <1> ;;   
   137                              <1> ;;   Copyright 2002-2004 H. Peter Anvin - All Rights Reserved
   138                              <1> ;;
   139                              <1> ;;   This program is free software; you can redistribute it and/or modify
   140                              <1> ;;   it under the terms of the GNU General Public License as published by
   141                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
   142                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
   143                              <1> ;;   (at your option) any later version; incorporated herein by reference.
   144                              <1> ;;
   145                              <1> ;; -----------------------------------------------------------------------
   146                              <1> 
   147                              <1> ;;
   148                              <1> ;; config.inc
   149                              <1> ;;
   150                              <1> ;; Common configuration options.  Some of these are imposed by the kernel.
   151                              <1> ;;
   152                              <1> 
   153                              <1> %ifndef _CONFIG_INC
   154                              <1> %define _CONFIG_INC
   155                              <1> 
   156                              <1> max_cmd_len	equ 255			; Must be odd; 255 is the kernel limit
   157                              <1> HIGHMEM_MAX	equ 037FFFFFFh		; DEFAULT highest address for an initrd
   158                              <1> DEFAULT_BAUD	equ 9600		; Default baud rate for serial port
   159                              <1> BAUD_DIVISOR	equ 115200		; Serial port parameter
   160                              <1> 
   161                              <1> %assign	DO_WBINVD 0			; Should we use WBINVD or not?
   162                              <1> 
   163                              <1> ;
   164                              <1> ; Version number definitinons
   165                              <1> ;
   166                              <1> %ifndef DEPEND				; Generated file
   167                              <1> %include "version.gen"
   168                              <2> %define VERSION "2.10"
   169                              <2> %define VER_MAJOR 2
   170                              <2> %define VER_MINOR 10
   171                              <1> %endif
   172                              <1> 
   173                              <1> ;
   174                              <1> ; Should be updated with every release to avoid bootsector/SYS file mismatch
   175                              <1> ;
   176                              <1> %define	version_str	VERSION		; Must be 4 characters long!
   177                              <1> %define date		DATE_STR	; Defined from the Makefile
   178                              <1> %define	year		'2004'
   179                              <1> 
   180                              <1> %endif ; _CONFIG_INC
   181                                  %include "kernel.inc"
   182                              <1> ;; $Id: kernel.inc,v 1.1 2002/04/26 05:56:24 hpa Exp $
   183                              <1> ;; -----------------------------------------------------------------------
   184                              <1> ;;   
   185                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
   186                              <1> ;;
   187                              <1> ;;   This program is free software; you can redistribute it and/or modify
   188                              <1> ;;   it under the terms of the GNU General Public License as published by
   189                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
   190                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
   191                              <1> ;;   (at your option) any later version; incorporated herein by reference.
   192                              <1> ;;
   193                              <1> ;; -----------------------------------------------------------------------
   194                              <1> 
   195                              <1> ;;
   196                              <1> ;; kernel.inc
   197                              <1> ;; 
   198                              <1> ;; Header file for the kernel interface definitions
   199                              <1> ;;
   200                              <1> 
   201                              <1> %ifndef _KERNEL_INC
   202                              <1> %define _KERNEL_INC
   203                              <1> 
   204                              <1> ;;
   205                              <1> ;; Structure of the real_mode_seg
   206                              <1> ;;
   207                              <1> 
   208                              <1> 		struc real_mode_seg_t
   209 00000000 <res 00000020>      <1> 		resb 20h-($-$$)		; org 20h
   210 00000020 <res 00000002>      <1> kern_cmd_magic	resw 1			; 0020 Magic # for command line
   211 00000022 <res 00000002>      <1> kern_cmd_offset resw 1			; 0022 Offset for kernel command line
   212 00000024 <res 000001CD>      <1> 		resb 497-($-$$)		; org 497d
   213 000001F1 <res 00000001>      <1> bs_setupsecs	resb 1			; 01F1 Sectors for setup code (0 -> 4)
   214 000001F2 <res 00000002>      <1> bs_rootflags	resw 1			; 01F2 Root readonly flag
   215 000001F4 <res 00000002>      <1> bs_syssize	resw 1			; 01F4
   216 000001F6 <res 00000002>      <1> bs_swapdev	resw 1			; 01F6 Swap device (obsolete)
   217 000001F8 <res 00000002>      <1> bs_ramsize	resw 1			; 01F8 Ramdisk flags, formerly ramdisk size
   218 000001FA <res 00000002>      <1> bs_vidmode	resw 1			; 01FA Video mode
   219 000001FC <res 00000002>      <1> bs_rootdev	resw 1			; 01FC Root device
   220 000001FE <res 00000002>      <1> bs_bootsign	resw 1			; 01FE Boot sector signature (0AA55h)
   221 00000200 <res 00000001>      <1> su_jump		resb 1			; 0200 0EBh
   222 00000201 <res 00000001>      <1> su_jump2	resb 1			; 0201 Size of following header
   223 00000202 <res 00000004>      <1> su_header	resd 1			; 0202 New setup code: header
   224 00000206 <res 00000002>      <1> su_version	resw 1			; 0206 See linux/arch/i386/boot/setup.S
   225 00000208 <res 00000002>      <1> su_switch	resw 1			; 0208
   226 0000020A <res 00000002>      <1> su_setupseg	resw 1			; 020A
   227 0000020C <res 00000002>      <1> su_startsys	resw 1			; 020C
   228 0000020E <res 00000002>      <1> su_kver		resw 1			; 020E Kernel version pointer
   229 00000210 <res 00000001>      <1> su_loader	resb 1			; 0210 Loader ID
   230 00000211 <res 00000001>      <1> su_loadflags	resb 1			; 0211 Load high flag
   231 00000212 <res 00000002>      <1> su_movesize	resw 1			; 0212
   232 00000214 <res 00000004>      <1> su_code32start	resd 1			; 0214 Start of code loaded high
   233 00000218 <res 00000004>      <1> su_ramdiskat	resd 1			; 0218 Start of initial ramdisk
   234                              <1> su_ramdisklen	equ $			; Length of initial ramdisk
   235 0000021C <res 00000002>      <1> su_ramdisklen1	resw 1			; 021C
   236 0000021E <res 00000002>      <1> su_ramdisklen2	resw 1			; 021E
   237 00000220 <res 00000002>      <1> su_bsklugeoffs	resw 1			; 0220
   238 00000222 <res 00000002>      <1> su_bsklugeseg	resw 1			; 0222
   239 00000224 <res 00000002>      <1> su_heapend	resw 1			; 0224
   240 00000226 <res 00000002>      <1> su_pad1		resw 1			; 0226
   241 00000228 <res 00000004>      <1> su_cmd_line_ptr	resd 1			; 0228
   242 0000022C <res 00000004>      <1> su_ramdisk_max	resd 1			; 022C
   243 00000230 <res 00008DC4>      <1> 		resb (9000h-12)-($-$$)	; Were bootsect.S puts it...
   244                              <1> linux_stack	equ $			; 8FF4
   245                              <1> linux_fdctab	equ $
   246 00008FF4 <res 0000000C>      <1> 		resb 9000h-($-$$)
   247                              <1> cmd_line_here	equ $			; 9000 Should be out of the way
   248                              <1> 		endstruc
   249                              <1> 
   250                              <1> ;
   251                              <1> ; Kernel command line signature
   252                              <1> ;
   253                              <1> CMD_MAGIC	equ 0A33Fh		; Command line magic
   254                              <1> 
   255                              <1> ;
   256                              <1> ; Magic number of su_header field
   257                              <1> ;
   258                              <1> HEADER_ID       equ 'HdrS'		; HdrS (in littleendian hex)
   259                              <1> 
   260                              <1> ;
   261                              <1> ; Flags for the su_loadflags field
   262                              <1> ;
   263                              <1> LOAD_HIGH	equ 01h			; Large kernel, load high
   264                              <1> CAN_USE_HEAP    equ 80h                 ; Boot loader reports heap size
   265                              <1> 
   266                              <1> ;
   267                              <1> ; ID codes for various modules
   268                              <1> ;
   269                              <1> syslinux_id	equ 031h		; 3 = SYSLINUX family; 1 = SYSLINUX
   270                              <1> pxelinux_id	equ 032h		; 3 = SYSLINUX family; 2 = PXELINUX
   271                              <1> isolinux_id	equ 033h		; 3 = SYSLINUX family; 3 = PXELINUX
   272                              <1> 
   273                              <1> %endif ; _KERNEL_INC
   274                                  %include "bios.inc"
   275                              <1> ;; $Id: bios.inc,v 1.2 2004/01/29 06:54:51 hpa Exp $
   276                              <1> ;; -----------------------------------------------------------------------
   277                              <1> ;;   
   278                              <1> ;;   Copyright 1994-2004 H. Peter Anvin - All Rights Reserved
   279                              <1> ;;
   280                              <1> ;;   This program is free software; you can redistribute it and/or modify
   281                              <1> ;;   it under the terms of the GNU General Public License as published by
   282                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
   283                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
   284                              <1> ;;   (at your option) any later version; incorporated herein by reference.
   285                              <1> ;;
   286                              <1> ;; -----------------------------------------------------------------------
   287                              <1> 
   288                              <1> ;;
   289                              <1> ;; bios.inc
   290                              <1> ;; 
   291                              <1> ;; Header file for the BIOS data structures etc.
   292                              <1> ;;
   293                              <1> 
   294                              <1> %ifndef _BIOS_INC
   295                              <1> %define _BIOS_INC
   296                              <1> 
   297                              <1> 		absolute 4*1Eh		; In the interrupt table
   298                              <1> fdctab		equ $
   299 00000078 <res 00000002>      <1> fdctab1		resw 1
   300 0000007A <res 00000002>      <1> fdctab2		resw 1
   301                              <1> 		absolute 0400h
   302 00000400 <res 00000008>      <1> serial_base	resw 4			; Base addresses for 4 serial ports
   303                              <1> 		absolute 0413h
   304 00000413 <res 00000002>      <1> BIOS_fbm	resw 1			; Free Base Memory (kilobytes)
   305                              <1> 		absolute 0462h
   306 00000462 <res 00000001>      <1> BIOS_page	resb 1			; Current video page
   307                              <1> 		absolute 046Ch
   308 0000046C <res 00000002>      <1> BIOS_timer	resw 1			; Timer ticks
   309                              <1> 		absolute 0472h
   310 00000472 <res 00000002>      <1> BIOS_magic	resw 1			; BIOS reset magic
   311                              <1>                 absolute 0484h
   312 00000484 <res 00000001>      <1> BIOS_vidrows    resb 1			; Number of screen rows
   313                              <1> 
   314                              <1> %endif ; _BIOS_INC
   315                                  %include "tracers.inc"
   316                              <1> ;; $Id: tracers.inc,v 1.1 2002/04/26 05:56:25 hpa Exp $
   317                              <1> ;; -----------------------------------------------------------------------
   318                              <1> ;;   
   319                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
   320                              <1> ;;
   321                              <1> ;;   This program is free software; you can redistribute it and/or modify
   322                              <1> ;;   it under the terms of the GNU General Public License as published by
   323                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
   324                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
   325                              <1> ;;   (at your option) any later version; incorporated herein by reference.
   326                              <1> ;;
   327                              <1> ;; -----------------------------------------------------------------------
   328                              <1> 
   329                              <1> ;;
   330                              <1> ;; tracers.inc
   331                              <1> ;; 
   332                              <1> ;; Debugging tracers
   333                              <1> ;;
   334                              <1> 
   335                              <1> %ifndef _TRACERS_INC
   336                              <1> %define _TRACERS_INC
   337                              <1> 
   338                              <1> ; Note: The Makefile builds one version with DEBUG_MESSAGES automatically.
   339                              <1> ; %define DEBUG_TRACERS			; Uncomment to get debugging tracers
   340                              <1> ; %define DEBUG_MESSAGES		; Uncomment to get debugging messages
   341                              <1> 
   342                              <1> %ifdef DEBUG_TRACERS
   343                              <1> 
   344                              <1> %macro TRACER	1
   345                              <1> 	call debug_tracer
   346                              <1> 	db %1
   347                              <1> %endmacro
   348                              <1> 
   349                              <1> %else	; DEBUG_TRACERS
   350                              <1> 
   351                              <1> %macro	TRACER	1
   352                              <1> %endmacro
   353                              <1> 
   354                              <1> %endif	; DEBUG_TRACERS
   355                              <1> 
   356                              <1> %endif ; _TRACERS_INC
   357                                  
   358                                  ;
   359                                  ; Some semi-configurable constants... change on your own risk.
   360                                  ;
   361                                  my_id		equ syslinux_id
   362                                  FILENAME_MAX_LG2 equ 4			; log2(Max filename size Including final null)
   363                                  FILENAME_MAX	equ 11			; Max mangled filename size
   364                                  NULLFILE	equ ' '			; First char space == null filename
   365                                  retry_count	equ 6			; How patient are we with the disk?
   366                                  %assign HIGHMEM_SLOP 0			; Avoid this much memory near the top
   367                                  
   368                                  ;
   369                                  ; This is what we need to do when idle
   370                                  ;
   371                                  %macro	RESET_IDLE 0
   372                                  	; Nothing
   373                                  %endmacro
   374                                  %macro	DO_IDLE 0
   375                                  	; Nothing
   376                                  %endmacro
   377                                  
   378                                  ;
   379                                  ; The following structure is used for "virtual kernels"; i.e. LILO-style
   380                                  ; option labels.  The options we permit here are `kernel' and `append
   381                                  ; Since there is no room in the bottom 64K for all of these, we
   382                                  ; stick them at vk_seg:0000 and copy them down before we need them.
   383                                  ;
   384                                  ; Note: this structure can be added to, but it must 
   385                                  ;
   386                                  %define vk_power	7		; log2(max number of vkernels)
   387                                  %define	max_vk		(1 << vk_power)	; Maximum number of vkernels
   388                                  %define vk_shift	(16-vk_power)	; Number of bits to shift
   389                                  %define vk_size		(1 << vk_shift)	; Size of a vkernel buffer
   390                                  
   391                                  		struc vkernel
   392 00000000 <res 0000000B>          vk_vname:	resb FILENAME_MAX	; Virtual name **MUST BE FIRST!**
   393 0000000B <res 0000000B>          vk_rname:	resb FILENAME_MAX	; Real name
   394 00000016 <res 00000002>          vk_appendlen:	resw 1
   395                                  		alignb 4
   396 00000018 <res 00000100>          vk_append:	resb max_cmd_len+1	; Command line
   397                                  		alignb 4
   398                                  vk_end:		equ $			; Should be <= vk_size
   399                                  		endstruc
   400                                  
   401                                  %ifndef DEPEND
   402                                  %if (vk_end > vk_size) || (vk_size*max_vk > 65536)
   403                                  %error "Too many vkernels defined, reduce vk_power"
   404                                  %endif
   405                                  %endif
   406                                  
   407                                  ;
   408                                  ; Segment assignments in the bottom 640K
   409                                  ; Stick to the low 512K in case we're using something like M-systems flash
   410                                  ; which load a driver into low RAM (evil!!)
   411                                  ;
   412                                  ; 0000h - main code/data segment (and BIOS segment)
   413                                  ;
   414                                  real_mode_seg	equ 5000h
   415                                  fat_seg		equ 3000h		; 128K area for FAT (2x64K)
   416                                  vk_seg          equ 2000h		; Virtual kernels
   417                                  xfer_buf_seg	equ 1000h		; Bounce buffer for I/O to high mem
   418                                  comboot_seg	equ real_mode_seg	; COMBOOT image loading zone
   419                                  
   420                                  ; ---------------------------------------------------------------------------
   421                                  ;   BEGIN CODE
   422                                  ; ---------------------------------------------------------------------------
   423                                  
   424                                  ;
   425                                  ; Memory below this point is reserved for the BIOS and the MBR
   426                                  ;
   427                                   		absolute 1000h
   428                                  trackbuf	equ $			; Track buffer goes here
   429                                  trackbufsize	equ 16384		; Safe size of track buffer
   430                                  ;		trackbuf ends at 5000h
   431                                  
   432                                  
   433                                  ;
   434                                  ; Constants for the xfer_buf_seg
   435                                  ;
   436                                  ; The xfer_buf_seg is also used to store message file buffers.  We
   437                                  ; need two trackbuffers (text and graphics), plus a work buffer
   438                                  ; for the graphics decompressor.
   439                                  ;
   440                                  xbs_textbuf	equ 0			; Also hard-coded, do not change
   441                                  xbs_vgabuf	equ trackbufsize
   442                                  xbs_vgatmpbuf	equ 2*trackbufsize
   443                                  
   444                                  
   445                                                  absolute 5000h          ; Here we keep our BSS stuff
   446 00005000 <res 00000200>          VKernelBuf:	resb vk_size		; "Current" vkernel
   447                                  		alignb 4
   448 00005200 <res 00000100>          AppendBuf       resb max_cmd_len+1	; append=
   449 00005300 <res 00000100>          Ontimeout	resb max_cmd_len+1	; ontimeout
   450 00005400 <res 00000100>          Onerror		resb max_cmd_len+1	; onerror
   451 00005500 <res 00000100>          KbdMap		resb 256		; Keyboard map
   452 00005600 <res 000000A0>          FKeyName	resb 10*16		; File names for F-key help
   453 000056A0 <res 0000000F>          NumBuf		resb 15			; Buffer to load number
   454 000056AF <res 00000001>          NumBufEnd	resb 1			; Last byte in NumBuf
   455                                  		alignb 8
   456                                  
   457                                  		; Expanded superblock
   458                                  SuperInfo	equ $
   459 000056B0 <res 00000080>          		resq 16			; The first 16 bytes expanded 8 times
   460                                  		;
   461                                  		; These need to follow SuperInfo
   462                                  		;
   463 00005730 <res 00000004>          RootDir		resd 1			; Location of root directory
   464 00005734 <res 00000004>          DataArea	resd 1			; Location of data area
   465 00005738 <res 00000002>          RootDirSize	resw 1			; Root dir size in sectors
   466 0000573A <res 00000002>          DirScanCtr	resw 1			; Used while searching directory
   467 0000573C <res 00000002>          EndofDirSec	resw 1			; = trackbuf+bsBytesPerSec-31
   468                                  
   469 0000573E <res 00000001>-         		alignb 4
   470 0000573E <rept>             
   471 00005740 <res 00000014>          E820Buf		resd 5			; INT 15:E820 data buffer
   472 00005754 <res 00000004>          E820Mem		resd 1			; Memory detected by E820
   473 00005758 <res 00000004>          E820Max		resd 1			; Is E820 memory capped?
   474 0000575C <res 00000004>          HiLoadAddr      resd 1			; Address pointer for high load loop
   475 00005760 <res 00000004>          HighMemSize	resd 1			; End of memory pointer (bytes)
   476 00005764 <res 00000004>          RamdiskMax	resd 1			; Highest address for a ramdisk
   477 00005768 <res 00000004>          KernelSize	resd 1			; Size of kernel (bytes)
   478 0000576C <res 00000004>          SavedSSSP	resd 1			; Our SS:SP while running a COMBOOT image
   479 00005770 <res 00000004>          PMESP		resd 1			; Protected-mode ESP
   480 00005774 <res 00000004>          ClustPerMoby	resd 1			; Clusters per 64K
   481 00005778 <res 00000004>          ClustSize	resd 1			; Bytes/cluster
   482 0000577C <res 0000000C>          KernelName      resb 12		        ; Mangled name for kernel
   483                                  					; (note the spare byte after!)
   484 00005788 <res 00000004>          OrigKernelExt	resd 1			; Original kernel extension
   485                                  FBytes		equ $			; Used by open/getc
   486 0000578C <res 00000002>          FBytes1		resw 1
   487 0000578E <res 00000002>          FBytes2		resw 1
   488 00005790 <res 00000002>          DirBlocksLeft	resw 1			; Ditto
   489 00005792 <res 00000002>          RunLinClust	resw 1			; Cluster # for LDLINUX.SYS
   490 00005794 <res 00000002>          BufSafe		resw 1			; Clusters we can load into trackbuf
   491 00005796 <res 00000002>          BufSafeSec	resw 1			; = how many sectors?
   492 00005798 <res 00000002>          BufSafeBytes	resw 1			; = how many bytes?
   493 0000579A <res 00000002>          EndOfGetCBuf	resw 1			; = getcbuf+BufSafeBytes
   494 0000579C <res 00000002>          KernelClust	resw 1			; Kernel size in clusters
   495 0000579E <res 00000002>          FClust		resw 1			; Number of clusters in open/getc file
   496 000057A0 <res 00000002>          FNextClust	resw 1			; Pointer to next cluster in d:o
   497 000057A2 <res 00000002>          FPtr		resw 1			; Pointer to next char in buffer
   498 000057A4 <res 00000002>          CmdOptPtr       resw 1			; Pointer to first option on cmd line
   499 000057A6 <res 00000002>          KernelCNameLen  resw 1			; Length of unmangled kernel name
   500 000057A8 <res 00000002>          InitRDCNameLen  resw 1			; Length of unmangled initrd name
   501 000057AA <res 00000002>          NextCharJump    resw 1			; Routine to interpret next print char
   502 000057AC <res 00000002>          SetupSecs	resw 1			; Number of setup sectors
   503 000057AE <res 00000002>          A20Test		resw 1			; Counter for testing status of A20
   504 000057B0 <res 00000002>          A20Type		resw 1			; A20 type
   505 000057B2 <res 00000002>          CmdLineLen	resw 1			; Length of command line including null
   506 000057B4 <res 00000002>          GraphXSize	resw 1			; Width of splash screen file
   507 000057B6 <res 00000002>          VGAPos		resw 1			; Pointer into VGA memory
   508 000057B8 <res 00000002>          VGACluster	resw 1			; Cluster pointer for VGA image file
   509 000057BA <res 00000002>          VGAFilePtr	resw 1			; Pointer into VGAFileBuf
   510 000057BC <res 00000002>          Com32SysSP	resw 1			; SP saved during COM32 syscall
   511                                  CursorDX        equ $
   512 000057BE <res 00000001>          CursorCol       resb 1			; Cursor column for message file
   513 000057BF <res 00000001>          CursorRow       resb 1			; Cursor row for message file
   514                                  ScreenSize      equ $
   515 000057C0 <res 00000001>          VidCols         resb 1			; Columns on screen-1
   516 000057C1 <res 00000001>          VidRows         resb 1			; Rows on screen-1
   517 000057C2 <res 00000002>          BaudDivisor	resw 1			; Baud rate divisor
   518                                  FlowControl	equ $
   519 000057C4 <res 00000001>          FlowOutput	resb 1			; Outputs to assert for serial flow
   520 000057C5 <res 00000001>          FlowInput	resb 1			; Input bits for serial flow
   521 000057C6 <res 00000001>          FlowIgnore	resb 1			; Ignore input unless these bits set
   522 000057C7 <res 00000001>          TextAttribute   resb 1			; Text attribute for message file
   523 000057C8 <res 00000001>          RetryCount      resb 1			; Used for disk access retries
   524 000057C9 <res 00000001>          KbdFlags	resb 1			; Check for keyboard escapes
   525 000057CA <res 00000001>          LoadFlags	resb 1			; Loadflags from kernel
   526 000057CB <res 00000001>          A20Tries	resb 1			; Times until giving up on A20
   527 000057CC <res 00000001>          FuncFlag	resb 1			; Escape sequences received from keyboard
   528 000057CD <res 00000001>          DisplayMask	resb 1			; Display modes mask
   529 000057CE <res 00000001>          CopySuper	resb 1			; Distinguish .bs versus .bss
   530 000057CF <res 0000000B>          MNameBuf        resb 11            	; Generic mangled file name buffer
   531 000057DA <res 0000000B>          InitRD          resb 11                 ; initrd= mangled name
   532 000057E5 <res 0000000D>          KernelCName     resb 13                 ; Unmangled kernel name
   533 000057F2 <res 0000000D>          InitRDCName     resb 13            	; Unmangled initrd name
   534 000057FF <res 00000011>          TextColorReg	resb 17			; VGA color registers for text mode
   535 00005810 <res 0000000D>          VGAFileBuf	resb 13			; Unmangled VGA image name
   536                                  VGAFileBufEnd	equ $
   537 0000581D <res 0000000B>          VGAFileMBuf	resb 11			; Mangled VGA image name
   538                                                  alignb 4		; For the good of REP MOVSD
   539 00005828 <res 00000101>          command_line	resb max_cmd_len+2	; Command line buffer
   540 00005929 <res 00000100>          default_cmd	resb max_cmd_len+1	; "default" command line
   541                                  kern_cmd_len	equ $-command_line
   542                                  
   543                                  		section .text
   544                                                  org 7C00h
   545                                  ;
   546                                  ; Some of the things that have to be saved very early are saved
   547                                  ; "close" to the initial stack pointer offset, in order to
   548                                  ; reduce the code size...
   549                                  ;
   550                                  StackBuf	equ $-44-32		; Start the stack here (grow down - 4K)
   551                                  PartInfo	equ StackBuf		; Saved partition table entry
   552                                  FloppyTable	equ PartInfo+16		; Floppy info table (must follow PartInfo)
   553                                  OrigFDCTabPtr	equ StackBuf-4		; The high dword on the stack
   554                                  
   555                                  ;
   556                                  ; Primary entry point.  Tempting as though it may be, we can't put the
   557                                  ; initial "cli" here; the jmp opcode in the first byte is part of the
   558                                  ; "magic number" (using the term very loosely) for the DOS superblock.
   559                                  ;
   560                                  bootsec		equ $
   561 00000000 EB3C                    		jmp short start		; 2 bytes
   562 00000002 90                      		nop			; 1 byte
   563                                  ;
   564                                  ; "Superblock" follows -- it's in the boot sector, so it's already
   565                                  ; loaded and ready for us
   566                                  ;
   567 00000003 5359534C494E5558        bsOemName	db 'SYSLINUX'		; The SYS command sets this, so...
   568                                  ;
   569                                  ; These are the fields we actually care about.  We end up expanding them
   570                                  ; all to dword size early in the code, so generate labels for both
   571                                  ; the expanded and unexpanded versions.
   572                                  ;;
   573                                  %macro		superb 1
   574                                  bx %+ %1	equ SuperInfo+($-superblock)*8+4
   575                                  bs %+ %1	equ $
   576                                  		zb 1
   577                                  %endmacro
   578                                  %macro		superw 1
   579                                  bx %+ %1	equ SuperInfo+($-superblock)*8
   580                                  bs %+ %1	equ $
   581                                  		zw 1
   582                                  %endmacro
   583                                  %macro		superd 1
   584                                  bx %+ %1	equ $			; no expansion for dwords
   585                                  bs %+ %1	equ $
   586                                  		zd 1
   587                                  %endmacro
   588                                  superblock	equ $
   589                                  		superw BytesPerSec
   590                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   591                              <1> bs %+ %1 equ $
   592 0000000B 0000                <1>  zw 1
   593                                  		superb SecPerClust
   594                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   595                              <1> bs %+ %1 equ $
   596 0000000D 00                  <1>  zb 1
   597                                  		superw ResSectors
   598                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   599                              <1> bs %+ %1 equ $
   600 0000000E 0000                <1>  zw 1
   601                                  		superb FATs
   602                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   603                              <1> bs %+ %1 equ $
   604 00000010 00                  <1>  zb 1
   605                                  		superw RootDirEnts
   606                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   607                              <1> bs %+ %1 equ $
   608 00000011 0000                <1>  zw 1
   609                                  		superw Sectors
   610                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   611                              <1> bs %+ %1 equ $
   612 00000013 0000                <1>  zw 1
   613                                  		superb Media
   614                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   615                              <1> bs %+ %1 equ $
   616 00000015 00                  <1>  zb 1
   617                                  		superw FATsecs
   618                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   619                              <1> bs %+ %1 equ $
   620 00000016 0000                <1>  zw 1
   621                                  		superw SecPerTrack
   622                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   623                              <1> bs %+ %1 equ $
   624 00000018 0000                <1>  zw 1
   625                                  		superw Heads
   626                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8
   627                              <1> bs %+ %1 equ $
   628 0000001A 0000                <1>  zw 1
   629                                  superinfo_size	equ ($-superblock)-1	; How much to expand
   630                                  		superd Hidden
   631                              <1> bx %+ %1 equ $
   632                              <1> bs %+ %1 equ $
   633 0000001C 00000000            <1>  zd 1
   634                                  		superd HugeSectors
   635                              <1> bx %+ %1 equ $
   636                              <1> bs %+ %1 equ $
   637 00000020 00000000            <1>  zd 1
   638                                  		superb DriveNumber
   639                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   640                              <1> bs %+ %1 equ $
   641 00000024 00                  <1>  zb 1
   642                                  		superb Reserved1
   643                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   644                              <1> bs %+ %1 equ $
   645 00000025 00                  <1>  zb 1
   646                                  		superb BootSignature	; 29h if the following fields exist
   647                              <1> bx %+ %1 equ SuperInfo+($-superblock)*8+4
   648                              <1> bs %+ %1 equ $
   649 00000026 00                  <1>  zb 1
   650                                  		superd VolumeID
   651                              <1> bx %+ %1 equ $
   652                              <1> bs %+ %1 equ $
   653 00000027 00000000            <1>  zd 1
   654 0000002B 00<rept>                bsVolumeLabel	zb 11
   655 00000036 00<rept>                bsFileSysType	zb 8			; Must be FAT12 or FAT16 for this version
   656                                  superblock_len	equ $-superblock
   657                                  
   658                                  SecPerClust	equ bxSecPerClust
   659                                  ;
   660                                  ; Note we don't check the constraints above now; we did that at install
   661                                  ; time (we hope!)
   662                                  ;
   663                                  
   664                                  ;floppy_table	equ $			; No sense in wasting memory, overwrite start
   665                                  
   666                                  start:
   667 0000003E FA                      		cli			; No interrupts yet, please
   668 0000003F FC                      		cld			; Copy upwards
   669                                  ;
   670                                  ; Set up the stack
   671                                  ;
   672 00000040 31C0                    		xor ax,ax
   673 00000042 8ED0                    		mov ss,ax
   674 00000044 BC[B4FF]                		mov sp,StackBuf		; Just below BSS
   675 00000047 8EC0                    		mov es,ax
   676                                  ;
   677                                  ; DS:SI may contain a partition table entry.  Preserve it for us.
   678                                  ;
   679 00000049 B90800                  		mov cx,8		; Save partition info
   680 0000004C 89E7                    		mov di,sp
   681 0000004E F3A5                    		rep movsw
   682                                  
   683 00000050 8ED8                    		mov ds,ax		; Now we can initialize DS...
   684                                  
   685 00000052 885560                  		mov [di+bsDriveNumber-FloppyTable],dl
   686                                  ;
   687                                  ; Now sautee the BIOS floppy info block to that it will support decent-
   688                                  ; size transfers; the floppy block is 11 bytes and is stored in the
   689                                  ; INT 1Eh vector (brilliant waste of resources, eh?)
   690                                  ;
   691                                  ; Of course, if BIOSes had been properly programmed, we wouldn't have
   692                                  ; had to waste precious space with this code.
   693                                  ;
   694 00000055 BB7800                  		mov bx,fdctab
   695 00000058 0FB437                  		lfs si,[bx]		; FS:SI -> original fdctab
   696 0000005B 0FA0                    		push fs			; Save on stack in case we need to bail
   697 0000005D 56                      		push si
   698                                  
   699                                  		; Save the old fdctab even if hard disk so the stack layout
   700                                  		; is the same.  The instructions above do not change the flags
   701 0000005E 20D2                    		and dl,dl		; If floppy disk (00-7F), assume no
   702                                  					; partition table
   703 00000060 7815                    		js harddisk
   704                                  
   705                                  floppy:
   706 00000062 B106                    		mov cl,6		; 12 bytes (CX == 0)
   707                                  		; es:di -> FloppyTable already
   708                                  		; This should be safe to do now, interrupts are off...
   709 00000064 893F                    		mov [bx],di		; FloppyTable
   710 00000066 894702                  		mov [bx+2],ax		; Segment 0
   711 00000069 64F3A5                  		fs rep movsw		; Faster to move words
   712 0000006C 8A0E[1800]              		mov cl,[bsSecPerTrack]  ; Patch the sector count
   713 00000070 884DF8                  		mov [di-8],cl
   714                                  		; AX == 0 here
   715 00000073 CD13                    		int 13h			; Some BIOSes need this
   716                                  
   717 00000075 EB27                    		jmp short not_harddisk
   718                                  ;
   719                                  ; The drive number and possibly partition information was passed to us
   720                                  ; by the BIOS or previous boot loader (MBR).  Current "best practice" is to
   721                                  ; trust that rather than what the superblock contains.
   722                                  ;
   723                                  ; Would it be better to zero out bsHidden if we don't have a partition table?
   724                                  ;
   725                                  ; Note: di points to beyond the end of PartInfo
   726                                  ;
   727                                  harddisk:
   728 00000077 F645F07F                		test byte [di-16],7Fh	; Sanity check: "active flag" should
   729 0000007B 7508                    		jnz no_partition	; be 00 or 80
   730 0000007D 668B45F8                		mov eax,[di-8]		; Partition offset (dword)
   731 00000081 66A3[1C00]              		mov [bsHidden],eax
   732                                  no_partition:
   733                                  ;
   734                                  ; Get disk drive parameters (don't trust the superblock.)  Don't do this for
   735                                  ; floppy drives -- INT 13:08 on floppy drives will (may?) return info about
   736                                  ; what the *drive* supports, not about the *media*.  Fortunately floppy disks
   737                                  ; tend to have a fixed, well-defined geometry which is stored in the superblock.
   738                                  ;
   739                                  		; DL == drive # still
   740 00000085 B408                    		mov ah,08h
   741 00000087 CD13                    		int 13h
   742 00000089 7213                    		jc no_driveparm
   743 0000008B 20E4                    		and ah,ah
   744 0000008D 750F                    		jnz no_driveparm
   745 0000008F C1EA08                  		shr dx,8
   746 00000092 42                      		inc dx			; Contains # of heads - 1
   747 00000093 8916[1A00]              		mov [bsHeads],dx
   748 00000097 83E13F                  		and cx,3fh
   749 0000009A 890E[1800]              		mov [bsSecPerTrack],cx
   750                                  no_driveparm:
   751                                  not_harddisk:
   752                                  ;
   753                                  ; Ready to enable interrupts, captain
   754                                  ;
   755 0000009E FB                      		sti
   756                                  ;
   757                                  ; Insane hack to expand the superblock to dwords
   758                                  ;
   759                                  expand_super:
   760 0000009F 6631C0                  		xor eax,eax
   761 000000A2 8EC0                    		mov es,ax			; INT 13:08 destroys ES
   762 000000A4 BE[0B00]                		mov si,superblock
   763 000000A7 BFB056                  		mov di,SuperInfo
   764 000000AA B110                    		mov cl,superinfo_size		; CH == 0
   765                                  .loop:
   766 000000AC AD                      		lodsw
   767 000000AD 4E                      		dec si
   768 000000AE 66AB                    		stosd				; Store expanded word
   769 000000B0 30E4                    		xor ah,ah
   770 000000B2 66AB                    		stosd				; Store expanded byte
   771 000000B4 E2F6                    		loop .loop
   772                                  
   773                                  ;
   774                                  ; Now we have to do some arithmetric to figure out where things are located.
   775                                  ; If Micro$oft had had brains they would already have done this for us,
   776                                  ; and stored it in the superblock at format time, but here we go,
   777                                  ; wasting precious boot sector space again...
   778                                  ;
   779                                  %define		Z di-superinfo_size*8-SuperInfo
   780                                  debugentrypt:
   781 000000B6 A1DC56                  		mov ax,[bxFATs]		; Number of FATs (eax<31:16> == 0)
   782 000000B9 668B55D8                		mov edx,[Z+bxFATsecs]	; Sectors/FAT
   783 000000BD 66F7E2                  		mul edx			; Get the size of the FAT area
   784                                  		; edx <- 0
   785 000000C0 660306[1C00]            		add eax,[bxHidden]		; Add hidden sectors
   786 000000C5 66034598                		add eax,[Z+bxResSectors]	; And reserved sectors
   787                                  
   788 000000C9 66A33057                		mov [RootDir],eax	; Location of root directory
   789 000000CD 66A33457                		mov [DataArea],eax	; First data sector
   790 000000D1 6650                    		push eax
   791                                  
   792 000000D3 668B45B0                		mov eax,[Z+bxRootDirEnts]
   793 000000D7 C1E005                  		shl ax,5		; Size of a directory entry
   794 000000DA 8B5D80                  		mov bx,[Z+bxBytesPerSec]
   795 000000DD 01D8                    		add ax,bx		; Round up, not down
   796 000000DF 48                      		dec ax
   797 000000E0 F7F3                    		div bx			; Now we have the size of the root dir
   798 000000E2 A33857                  		mov [RootDirSize],ax
   799 000000E5 A33A57                  		mov [DirScanCtr],ax
   800 000000E8 81C3E10F                		add bx,trackbuf-31
   801 000000EC 895D0C                  		mov [Z+EndofDirSec],bx	; End of a single directory sector
   802 000000EF 66014504                		add [Z+DataArea],eax
   803 000000F3 6658                    		pop eax			; Reload root directory starting point
   804                                  
   805                                  ;
   806                                  ; Now the fun begins.  We have to search the root directory for
   807                                  ; LDLINUX.SYS and load the first sector, so we have a little more
   808                                  ; space to have fun with.  Then we can go chasing through the FAT.
   809                                  ; Joy!!
   810                                  ;
   811 000000F5 6650                    sd_nextsec:	push eax
   812 000000F7 BB0010                  		mov bx,trackbuf
   813 000000FA 53                      		push bx
   814 000000FB E88200                  		call getonesec
   815 000000FE 5E                      		pop si
   816 000000FF B90B00                  sd_nextentry:	mov cx,11
   817 00000102 382C                    		cmp [si],ch		; Directory high water mark
   818 00000104 741C                    		je kaboom
   819                                  ; This no longer fits... since we'd be dead anyway if there
   820                                  ; was a nonfile named LDLINUX.SYS on the disk, it shouldn't
   821                                  ; matter...
   822                                  ;		test byte [si+11],18h	; Must be a file
   823                                  ;		jnz sd_not_file
   824 00000106 BF[EF01]                		mov di,ldlinux_name
   825 00000109 56                      		push si
   826 0000010A F3A6                    		repe cmpsb
   827 0000010C 5E                      		pop si
   828 0000010D 742E                    		je found_it
   829 0000010F 83C620                  sd_not_file:	add si,byte 32		; Distance to next
   830 00000112 3B363C57                		cmp si,[EndofDirSec]
   831 00000116 72E7                    		jb sd_nextentry
   832 00000118 6658                    		pop eax
   833 0000011A 6640                    		inc eax
   834 0000011C FF0E3A57                		dec word [DirScanCtr]
   835 00000120 75D3                    		jnz sd_nextsec
   836                                  ;
   837                                  ; kaboom: write a message and bail out.
   838                                  ;
   839                                  kaboom:
   840 00000122 31F6                    		xor si,si
   841 00000124 8ED6                    		mov ss,si		
   842 00000126 BC[B0FF]                		mov sp,StackBuf-4 	; Reset stack
   843 00000129 8EDE                    		mov ds,si		; Reset data segment
   844 0000012B 668F067800              		pop dword [fdctab]	; Restore FDC table
   845 00000130 BE[E001]                .patch:		mov si,bailmsg
   846 00000133 E83600                  		call writestr		; Returns with AL = 0
   847 00000136 98                      		cbw			; AH <- 0
   848 00000137 CD16                    		int 16h			; Wait for keypress
   849 00000139 CD19                    		int 19h			; And try once more to boot...
   850 0000013B EBFE                    .norge:		jmp short .norge	; If int 19h returned; this is the end
   851                                  
   852                                  ;
   853                                  ; found_it: now we compute the location of the first sector, then
   854                                  ;	    load it and JUMP (since we're almost out of space)
   855                                  ;
   856                                  found_it:	; Note: we actually leave two words on the stack here
   857                                  		; (who cares?)
   858 0000013D 66A1C456                		mov eax,[bxSecPerClust]
   859 00000141 89C5                    		mov bp,ax		; Load an entire cluster
   860 00000143 660FB75C1A              		movzx ebx,word [si+26]	; First cluster
   861 00000148 891E9257                		mov [RunLinClust],bx	; Save for later use
   862 0000014C 4B                      		dec bx			; First cluster is "cluster 2"
   863 0000014D 4B                      		dec bx
   864 0000014E 66F7E3                  		mul ebx
   865 00000151 6603063457              		add eax,[DataArea]
   866 00000156 BB[0002]                		mov bx,ldlinux_sys
   867 00000159 E82700                  		call getlinsec
   868 0000015C BE[EF01]                		mov si,bs_magic
   869 0000015F BF[1F02]                		mov di,ldlinux_magic
   870 00000162 B91100                  		mov cx,magic_len
   871 00000165 F3A6                    		repe cmpsb		; Make sure that the bootsector
   872 00000167 75B9                    		jne kaboom		; matches LDLINUX.SYS
   873                                  ;
   874                                  ; Done! Jump to the entry point!
   875                                  ;
   876 00000169 E9C800                  		jmp ldlinux_ent
   877                                  ;
   878                                  ;
   879                                  ; writestr: write a null-terminated string to the console
   880                                  ;	    This assumes we're on page 0.  This is only used for early
   881                                  ;           messages, so it should be OK.
   882                                  ;
   883                                  writestr:
   884 0000016C AC                      .loop:		lodsb
   885 0000016D 20C0                    		and al,al
   886 0000016F 7409                                    jz .return
   887 00000171 B40E                    		mov ah,0Eh		; Write to screen as TTY
   888 00000173 BB0700                  		mov bx,0007h		; Attribute
   889 00000176 CD10                    		int 10h
   890 00000178 EBF2                    		jmp short .loop
   891 0000017A C3                      .return:	ret
   892                                  
   893                                  ;
   894                                  ; disk_error: decrement the retry count and bail if zero.
   895                                  ;	      This gets patched once we have more space to try to
   896                                  ;             optimize transfer sizes on broken machines.
   897                                  ;
   898 0000017B 4E                      disk_error:	dec si			; SI holds the disk retry counter
   899 0000017C 74A4                    		jz kaboom
   900                                  		; End of patched "call" instruction!
   901 0000017E EB33                    		jmp short disk_try_again
   902                                  
   903                                  ;
   904                                  ; getonesec: like getlinsec, but pre-sets the count to 1
   905                                  ;
   906                                  getonesec:
   907 00000180 BD0100                  		mov bp,1
   908                                  		; Fall through to getlinsec
   909                                  
   910                                  ;
   911                                  ; getlinsec: load a sequence of BP floppy sector given by the linear sector
   912                                  ;	     number in EAX into the buffer at ES:BX.  We try to optimize
   913                                  ;	     by loading up to a whole track at a time, but the user
   914                                  ;	     is responsible for not crossing a 64K boundary.
   915                                  ;	     (Yes, BP is weird for a count, but it was available...)
   916                                  ;
   917                                  ;	     On return, BX points to the first byte after the transferred
   918                                  ;	     block.
   919                                  ;
   920                                  ;	     The "stupid patch area" gets replaced by the code
   921                                  ;	     mov bp,1 ; nop ... (BD 01 00 90 90...) when installing with
   922                                  ;	     the -s option.
   923                                  ;
   924                                  ;            This routine assumes CS == DS.
   925                                  ;
   926                                  ; Stylistic note: use "xchg" instead of "mov" when the source is a register
   927                                  ; that is dead from that point; this saves space.  However, please keep
   928                                  ; the order to dst,src to keep things sane.
   929                                  ;
   930                                  getlinsec:
   931 00000183 668B361857              		mov esi,[bxSecPerTrack]
   932                                  		;
   933                                  		; Dividing by sectors to get (track,sector): we may have
   934                                  		; up to 2^18 tracks, so we need to use 32-bit arithmetric.
   935                                  		;
   936 00000188 6631D2                  		xor edx,edx		; Zero-extend LBA to 64 bits
   937 0000018B 66F7F6                  		div esi
   938 0000018E 31C9                    		xor cx,cx
   939 00000190 87CA                    		xchg cx,dx		; CX <- sector index (0-based)
   940                                  					; EDX <- 0
   941                                  		; eax = track #
   942 00000192 66F7362857              		div dword [bxHeads]	; Convert track to head/cyl
   943                                  		;
   944                                  		; Now we have AX = cyl, DX = head, CX = sector (0-based),
   945                                  		; BP = sectors to transfer, SI = bsSecPerTrack,
   946                                  		; ES:BX = data target
   947                                  		;
   948 00000197 56                      gls_nextchunk:	push si			; <A> bsSecPerTrack
   949 00000198 55                      		push bp			; <B> Sectors to transfer
   950                                  
   951                                  		; Important - this gets patched with a call.  The call
   952                                  		; assumes cx, si and bp are set up, and can modify bp
   953                                  		; and destroy si.  Until we have the space to do so,
   954                                  		; transfer one sector at a time.
   955                                  gls_set_size:
   956                                  __BEGIN_STUPID_PATCH_AREA:
   957 00000199 BD0100                  		mov bp,1		; 3 bytes, same as a call insn
   958                                  __END_STUPID_PATCH_AREA:
   959                                  
   960 0000019C 50                      		push ax			; <C> Cylinder #
   961 0000019D 52                      		push dx			; <D> Head #
   962                                  
   963 0000019E 51                      		push cx			; <E> Sector #
   964 0000019F C0E406                  		shl ah,6		; Because IBM was STOOPID
   965                                  					; and thought 8 bits were enough
   966                                  					; then thought 10 bits were enough...
   967 000001A2 59                      		pop cx			; <E> Sector #
   968 000001A3 51                      		push cx			; <E> Sector #
   969 000001A4 41                      		inc cx			; Sector numbers are 1-based, sigh
   970 000001A5 08E1                    		or cl,ah
   971 000001A7 88C5                    		mov ch,al
   972 000001A9 88D6                    		mov dh,dl
   973 000001AB 8A16[2400]              		mov dl,[bsDriveNumber]
   974 000001AF 95                      		xchg ax,bp		; Sector to transfer count
   975                                  					; (xchg shorter than mov)
   976 000001B0 BE0600                  		mov si,retry_count	; # of times to retry a disk access
   977                                  ;
   978                                  ; Do the disk transfer... save the registers in case we fail :(
   979                                  ;
   980                                  disk_try_again: 
   981 000001B3 60                      		pusha			; <F>
   982 000001B4 B402                    		mov ah,02h		; READ DISK
   983 000001B6 CD13                    		int 13h
   984 000001B8 61                      		popa			; <F>
   985 000001B9 72C0                    		jc disk_error
   986                                  ;
   987                                  ; Disk access successful
   988                                  ;
   989 000001BB 59                      		pop cx			; <E> Sector #
   990 000001BC 89C7                    		mov di,ax		; Reduce sector left count
   991 000001BE F726[0B00]              		mul word [bsBytesPerSec] ; Figure out how much to advance ptr
   992 000001C2 01C3                    		add bx,ax		; Update buffer location
   993 000001C4 5A                      		pop dx			; <D> Head #
   994 000001C5 58                      		pop ax			; <C> Cyl #
   995 000001C6 5D                      		pop bp			; <B> Sectors left to transfer
   996 000001C7 5E                      		pop si			; <A> Number of sectors/track
   997 000001C8 29FD                    		sub bp,di		; Reduce with # of sectors just read
   998 000001CA 74AE                    		jz writestr.return	; Done!
   999 000001CC 01F9                    		add cx,di
  1000 000001CE 39F1                    		cmp cx,si
  1001 000001D0 72C5                    		jb gls_nextchunk
  1002 000001D2 42                      		inc dx			; Next track on cyl
  1003 000001D3 3B16[1A00]              		cmp dx,[bsHeads]	; Was this the last one?
  1004 000001D7 7203                    		jb gls_nonewcyl
  1005 000001D9 40                      		inc ax			; If so, new cylinder
  1006 000001DA 31D2                    		xor dx,dx		; First head on new cylinder
  1007 000001DC 29F1                    gls_nonewcyl:	sub cx,si		; First sector on new track
  1008 000001DE EBB7                    		jmp short gls_nextchunk
  1009                                  
  1010 000001E0 426F6F74206661696C-     bailmsg:	db 'Boot failed', 0Dh, 0Ah, 0
  1011 000001E9 65640D0A00         
  1012                                  
  1013                                  bs_checkpt	equ $			; Must be <= 7DEFh
  1014                                  
  1015                                  %if 1
  1016                                  bs_checkpt_off	equ ($-$$)
  1017                                  %ifndef DEPEND
  1018                                  %if bs_checkpt_off > 1EFh
  1019                                  %error "Boot sector overflow"
  1020                                  %endif
  1021                                  %endif
  1022                                  
  1023 000001EE 00                      		zb 1EFh-($-$$)
  1024                                  %endif
  1025                                  bs_magic	equ $			; From here to the magic_len equ
  1026                                  					; must match ldlinux_magic
  1027 000001EF 4C444C494E55582053-     ldlinux_name:	db 'LDLINUX SYS'	; Looks like this in the root dir
  1028 000001F8 5953               
  1029 000001FA 24BECC40                		dd HEXDATE		; Hopefully unique between compiles
  1030                                  
  1031 000001FE 55AA                    bootsignature	dw 0AA55h
  1032                                  magic_len	equ $-bs_magic
  1033                                  
  1034                                  ;
  1035                                  ; ===========================================================================
  1036                                  ;  End of boot sector
  1037                                  ; ===========================================================================
  1038                                  ;  Start of LDLINUX.SYS
  1039                                  ; ===========================================================================
  1040                                  
  1041                                  ldlinux_sys:
  1042                                  
  1043 00000200 0D0A                    syslinux_banner	db 0Dh, 0Ah
  1044                                  %if IS_MDSLINUX
  1045                                  		db 'MDSLINUX '
  1046                                  %else
  1047 00000202 5359534C494E555820      		db 'SYSLINUX '
  1048                                  %endif
  1049 0000020B 322E31302032303034-     		db version_str, ' ', date, ' ', 0
  1050 00000214 2D30362D31382000   
  1051 0000021C 0D0A1A                  		db 0Dh, 0Ah, 1Ah	; EOF if we "type" this in DOS
  1052                                  
  1053 0000021F 4C444C494E55582053-     ldlinux_magic	db 'LDLINUX SYS'
  1054 00000228 5953               
  1055 0000022A 24BECC40                		dd HEXDATE
  1056 0000022E 55AA                    		dw 0AA55h
  1057                                  
  1058                                  ;
  1059                                  ; This area is possibly patched by the installer.  It is located
  1060                                  ; immediately after the EOF + LDLINUX SYS + 4 bytes + 55 AA + alignment,
  1061                                  ; so we can find it algorithmically.
  1062                                  ;
  1063                                  		alignb 4, db 0
  1064 00000230 FF00                    MaxTransfer	dw 00FFh		; Absolutely maximum transfer size
  1065                                  
  1066 00000232 90<rept>                		align 4
  1067                                  ldlinux_ent:
  1068                                  ; 
  1069                                  ; Note that some BIOSes are buggy and run the boot sector at 07C0:0000
  1070                                  ; instead of 0000:7C00 and the like.  We don't want to add anything
  1071                                  ; more to the boot sector, so it is written to not assume a fixed
  1072                                  ; value in CS, but we don't want to deal with that anymore from now
  1073                                  ; on.
  1074                                  ;
  1075 00000234 EA[3902]0000            		jmp 0:.next
  1076                                  .next:
  1077                                  
  1078                                  ;
  1079                                  ; Tell the user we got this far
  1080                                  ;
  1081 00000239 BE[0002]                		mov si,syslinux_banner
  1082 0000023C E82DFF                  		call writestr
  1083                                  ;
  1084                                  ; Remember, the boot sector loaded only the first cluster of LDLINUX.SYS.
  1085                                  ; We can really only rely on a single sector having been loaded.  Hence
  1086                                  ; we should load the FAT into RAM and start chasing pointers...
  1087                                  ;
  1088 0000023F 31C0                    		xor ax,ax
  1089 00000241 99                      		cwd
  1090 00000242 42                      		inc dx				; DX:AX <- 64K
  1091 00000243 F736B056                		div word [bxBytesPerSec]	; sectors/64K
  1092 00000247 89C6                    		mov si,ax
  1093                                  
  1094 00000249 06                      		push es
  1095 0000024A BB0030                  		mov bx,fat_seg			; Load into fat_seg:0000
  1096 0000024D 8EC3                    		mov es,bx
  1097                                  		
  1098 0000024F 66A1[1C00]              		mov eax,[bsHidden]		; Hidden sectors
  1099 00000253 660316C856              		add edx,[bxResSectors]
  1100 00000258 6601D0                  		add eax,edx
  1101 0000025B 668B0E0857              		mov ecx,[bxFATsecs]		; Sectors/FAT
  1102                                  fat_load_loop:	
  1103 00000260 6689CD                  		mov ebp,ecx			; Make sure high EBP = 0
  1104 00000263 39F5                    		cmp bp,si
  1105 00000265 7602                    		jna fat_load
  1106 00000267 89F5                    		mov bp,si			; A full 64K moby
  1107                                  fat_load:	
  1108 00000269 31DB                    		xor bx,bx			; Offset 0 in the current ES
  1109 0000026B E80501                  		call getlinsecsr
  1110 0000026E 29E9                    		sub cx,bp
  1111 00000270 740D                    		jz fat_load_done		; Last moby?
  1112 00000272 6601E8                  		add eax,ebp			; Advance sector count
  1113 00000275 8CC3                    		mov bx,es			; Next 64K moby
  1114 00000277 81C30010                		add bx,1000h
  1115 0000027B 8EC3                    		mov es,bx
  1116 0000027D EBE1                    		jmp short fat_load_loop
  1117                                  fat_load_done:
  1118 0000027F 07                      		pop es
  1119                                  ;
  1120                                  ; Fine, now we have the FAT in memory.	How big is a cluster, really?
  1121                                  ; Also figure out how many clusters will fit in an 8K buffer, and how
  1122                                  ; many sectors and bytes that is
  1123                                  ;
  1124 00000280 668B3EB056              		mov edi,[bxBytesPerSec]		; Used a lot below
  1125 00000285 66A1C456                		mov eax,[SecPerClust]
  1126 00000289 89C6                    		mov si,ax			; Also used a lot
  1127 0000028B F7E7                    		mul di
  1128 0000028D 66A37857                		mov [ClustSize],eax		; Bytes/cluster
  1129 00000291 89C3                    		mov bx,ax
  1130 00000293 B80040                  		mov ax,trackbufsize		; High bit 0
  1131 00000296 99                      		cwd
  1132 00000297 F7F3                    		div bx
  1133 00000299 A39457                  		mov [BufSafe],ax		; # of cluster in trackbuf
  1134 0000029C F7E6                    		mul si
  1135 0000029E A39657                  		mov [BufSafeSec],ax
  1136 000002A1 F7E7                    		mul di
  1137 000002A3 A39857                  		mov [BufSafeBytes],ax
  1138 000002A6 0500A0                  		add ax,getcbuf			; Size of getcbuf is the same
  1139 000002A9 A39A57                  		mov [EndOfGetCBuf],ax		; as for trackbuf
  1140                                  ;
  1141                                  ; FAT12 or FAT16?  This computation is fscking ridiculous...
  1142                                  ;
  1143 000002AC 66A1F056                		mov eax,[bxSectors]
  1144 000002B0 21C0                    		and ax,ax
  1145 000002B2 7504                    		jnz have_secs
  1146 000002B4 66A1[2000]              		mov eax,[bsHugeSectors]
  1147 000002B8 660306[1C00]            have_secs:	add eax,[bsHidden]		; These are not included
  1148 000002BD 662B063057              		sub eax,[RootDir]		; Start of root directory
  1149 000002C2 660FB71E3857            		movzx ebx,word [RootDirSize]
  1150 000002C8 6629D8                  		sub eax,ebx			; Subtract root directory size
  1151 000002CB 6631D2                  		xor edx,edx
  1152 000002CE 66F7F6                  		div esi				; Convert to clusters
  1153 000002D1 3DF60F                  		cmp ax,4086			; FAT12 limit
  1154 000002D4 7605                    		jna is_fat12
  1155                                  		; Patch the jump
  1156 000002D6 C606[7C03]1D            		mov byte [nextcluster+1],nextcluster_fat16-(nextcluster+2)
  1157                                  is_fat12:
  1158                                  
  1159                                  ;
  1160                                  ; Patch gls_set_size so we can transfer more than one sector at a time.
  1161                                  ;
  1162 000002DB C606[9901]E8            		mov byte [gls_set_size],0xe8	; E8 = CALL NEAR
  1163 000002E0 C706[9A01]1402          		mov word [gls_set_size+1],do_gls_set_size-(gls_set_size+3)
  1164 000002E6 C606[7B01]E8            		mov byte [disk_error],0xe8
  1165 000002EB C706[7C01]4502          		mov word [disk_error+1],do_disk_error-(disk_error+3)
  1166                                  
  1167                                  ;
  1168                                  ; Now we read the rest of LDLINUX.SYS.	Don't bother loading the first
  1169                                  ; cluster again, though.
  1170                                  ;
  1171                                  load_rest:
  1172 000002F1 8B0E7857                		mov cx,[ClustSize]
  1173 000002F5 BB[0002]                		mov bx,ldlinux_sys
  1174 000002F8 01CB                    		add bx,cx
  1175 000002FA 8B369257                		mov si,[RunLinClust]
  1176 000002FE E87A00                  		call nextcluster
  1177 00000301 31D2                    		xor dx,dx
  1178 00000303 B8EC1F                  		mov ax,ldlinux_len-1		; To be on the safe side
  1179 00000306 01C8                    		add ax,cx
  1180 00000308 F7F1                    		div cx				; the number of clusters
  1181 0000030A 48                      		dec ax				; We've already read one
  1182 0000030B 7405                    		jz all_read_jmp
  1183 0000030D 89C1                    		mov cx,ax
  1184 0000030F E80300                  		call getfssec
  1185                                  ;
  1186                                  ; All loaded up
  1187                                  ;
  1188                                  all_read_jmp:
  1189 00000312 E9C900                  		jmp all_read
  1190                                  ;
  1191                                  ; -----------------------------------------------------------------------------
  1192                                  ; Subroutines that have to be in the first sector
  1193                                  ; -----------------------------------------------------------------------------
  1194                                  ;
  1195                                  ; getfssec: Get multiple clusters from a file, given the starting cluster.
  1196                                  ;
  1197                                  ;	This routine makes sure the subtransfers do not cross a 64K boundary,
  1198                                  ;	and will correct the situation if it does, UNLESS *sectors* cross
  1199                                  ;	64K boundaries.
  1200                                  ;
  1201                                  ;	ES:BX	-> Buffer
  1202                                  ;	SI	-> Starting cluster number (2-based)
  1203                                  ;	CX	-> Cluster count (0FFFFh = until end of file)
  1204                                  ;
  1205                                  ;	Returns CF=1 on EOF
  1206                                  ;
  1207                                  getfssec:
  1208 00000315 6631ED                  .getfragment:	xor ebp,ebp			; Fragment sector count
  1209 00000318 668D44FE                		lea eax,[si-2]			; Get 0-based sector address
  1210 0000031C 66F726C456              		mul dword [SecPerClust]
  1211 00000321 6603063457              		add eax,[DataArea]
  1212                                  .getseccnt:					; See if we can read > 1 clust
  1213 00000326 032EC456                		add bp,[SecPerClust]
  1214 0000032A 49                      		dec cx				; Reduce clusters left to find
  1215 0000032B 8D7C01                  		lea di,[si+1]
  1216 0000032E E84A00                  		call nextcluster
  1217 00000331 F5                      		cmc
  1218 00000332 7207                    		jc .eof				; At EOF?
  1219 00000334 E304                    		jcxz .endfragment		; Or was it the last we wanted?
  1220 00000336 39FE                    		cmp si,di			; Is file continuous?
  1221 00000338 74EC                    		je .getseccnt			; Yes, we can get
  1222 0000033A F8                      .endfragment:	clc				; Not at EOF
  1223 0000033B 9C                      .eof:		pushf				; Remember EOF or not
  1224 0000033C 56                      		push si
  1225 0000033D 51                      		push cx
  1226                                  .getchunk:
  1227 0000033E 6650                    		push eax
  1228 00000340 8CC0                    		mov ax,es			; Check for 64K boundaries.
  1229 00000342 C1E004                  		shl ax,4
  1230 00000345 01D8                    		add ax,bx
  1231 00000347 31D2                    		xor dx,dx
  1232 00000349 F7D8                    		neg ax
  1233 0000034B 0F94C2                  		setz dl				; DX <- 1 if full 64K segment
  1234 0000034E F736[0B00]              		div word [bsBytesPerSec]	; How many sectors fit?
  1235 00000352 89EE                    		mov si,bp
  1236 00000354 29C6                    		sub si,ax			; Compute remaining sectors
  1237 00000356 760E                    		jbe .lastchunk
  1238 00000358 89C5                    		mov bp,ax
  1239 0000035A 6658                    		pop eax
  1240 0000035C E81400                  		call getlinsecsr
  1241 0000035F 6601E8                  		add eax,ebp			; EBP<31:16> == 0
  1242 00000362 89F5                    		mov bp,si			; Remaining sector count
  1243 00000364 EBD8                    		jmp short .getchunk
  1244 00000366 6658                    .lastchunk:	pop eax
  1245 00000368 E818FE                  		call getlinsec
  1246 0000036B 59                      		pop cx
  1247 0000036C 5E                      		pop si
  1248 0000036D 9D                      		popf
  1249 0000036E E302                    		jcxz .return			; If we hit the count limit
  1250 00000370 73A3                    		jnc .getfragment		; If we didn't hit EOF
  1251 00000372 C3                      .return:	ret
  1252                                  
  1253                                  ;
  1254                                  ; getlinsecsr: save registers, call getlinsec, restore registers
  1255                                  ;
  1256 00000373 6660                    getlinsecsr:	pushad
  1257 00000375 E80BFE                  		call getlinsec
  1258 00000378 6661                    		popad
  1259 0000037A C3                      		ret
  1260                                  
  1261                                  ;
  1262                                  ; nextcluster: Advance a cluster pointer in SI to the next cluster
  1263                                  ;	       pointed at in the FAT tables.  CF=0 on return if end of file.
  1264                                  ;
  1265                                  nextcluster:
  1266 0000037B EB00                    		jmp short nextcluster_fat12	; This gets patched
  1267                                  
  1268                                  nextcluster_fat12:
  1269 0000037D 53                      		push bx
  1270 0000037E 1E                      		push ds
  1271 0000037F BB0030                  		mov bx,fat_seg
  1272 00000382 8EDB                    		mov ds,bx
  1273 00000384 89F3                    		mov bx,si			; Multiply by 3/2
  1274 00000386 D1EB                    		shr bx,1			; CF now set if odd
  1275 00000388 8B30                    		mov si,[si+bx]
  1276 0000038A 7303                    		jnc nc_even
  1277 0000038C C1EE04                  		shr si,4			; Needed for odd only
  1278                                  nc_even:
  1279 0000038F 81E6FF0F                		and si,0FFFh
  1280 00000393 81FEF00F                		cmp si,0FF0h			; Clears CF if at end of file
  1281 00000397 1F                      		pop ds
  1282 00000398 5B                      		pop bx
  1283 00000399 C3                      nc_return:	ret
  1284                                  
  1285                                  ;
  1286                                  ; FAT16 decoding routine.  Note that a 16-bit FAT can be up to 128K,
  1287                                  ; so we have to decide if we're in the "low" or the "high" 64K-segment...
  1288                                  ;
  1289                                  nextcluster_fat16:
  1290 0000039A 50                      		push ax
  1291 0000039B 1E                      		push ds
  1292 0000039C B80030                  		mov ax,fat_seg
  1293 0000039F D1E6                    		shl si,1
  1294 000003A1 7303                    		jnc .seg0
  1295 000003A3 B80040                  		mov ax,fat_seg+1000h
  1296 000003A6 8ED8                    .seg0:		mov ds,ax
  1297 000003A8 8B34                    		mov si,[si]
  1298 000003AA 83FEF0                  		cmp si,0FFF0h
  1299 000003AD 1F                      		pop ds
  1300 000003AE 58                      		pop ax
  1301 000003AF C3                      		ret
  1302                                  
  1303                                  ;
  1304                                  ; Routine that controls how much we can transfer in one chunk.  Called
  1305                                  ; from gls_set_size in getlinsec.
  1306                                  ;
  1307                                  do_gls_set_size:
  1308 000003B0 29CE                    		sub si,cx		; Sectors left on track
  1309 000003B2 39F5                    		cmp bp,si
  1310 000003B4 7602                    		jna .lastchunk
  1311 000003B6 89F5                    		mov bp,si		; No more than a trackful, please!
  1312                                  .lastchunk:
  1313 000003B8 3B2E[3002]              		cmp bp,[MaxTransfer]	; Absolute maximum transfer size
  1314 000003BC 7604                    		jna .oktransfer
  1315 000003BE 8B2E[3002]              		mov bp,[MaxTransfer]
  1316                                  .oktransfer:	
  1317 000003C2 C3                      		ret
  1318                                  
  1319                                  ;
  1320                                  ; This routine captures disk errors, and tries to decide if it is
  1321                                  ; time to reduce the transfer size.
  1322                                  ;
  1323                                  do_disk_error:
  1324 000003C3 4E                      		dec si			; Decrement the retry counter
  1325 000003C4 0F845AFD                		jz kaboom		; If expired, croak
  1326 000003C8 83FE02                  		cmp si,2		; If only 2 attempts left
  1327 000003CB 7704                    		ja .nodanger
  1328 000003CD B001                    		mov al,1		; Drop transfer size to 1
  1329 000003CF EB09                    		jmp short .setsize
  1330                                  .nodanger:
  1331 000003D1 83FE04                  		cmp si,retry_count-2
  1332 000003D4 7707                    		ja .again		; First time, just try again
  1333 000003D6 D0E8                    		shr al,1		; Otherwise, try to reduce
  1334 000003D8 1400                    		adc al,0		; the max transfer size, but not to 0
  1335                                  .setsize:
  1336 000003DA A2[3002]                		mov [MaxTransfer],al
  1337                                  .again:
  1338 000003DD C3                      		ret
  1339                                  
  1340                                  ;
  1341                                  ; Debug routine
  1342                                  ;
  1343                                  %ifdef debug
  1344                                  safedumpregs:
  1345                                  		cmp word [Debug_Magic],0D00Dh
  1346                                  		jnz nc_return
  1347                                  		jmp dumpregs
  1348                                  %endif
  1349                                  
  1350                                  rl_checkpt	equ $				; Must be <= 8000h
  1351                                  
  1352                                  rl_checkpt_off	equ ($-$$)
  1353                                  %ifndef DEPEND
  1354                                  %if rl_checkpt_off > 400h
  1355                                  %error "Sector 1 overflow"
  1356                                  %endif
  1357                                  %endif
  1358                                  
  1359                                  ; ----------------------------------------------------------------------------
  1360                                  ;  End of code and data that have to be in the first sector
  1361                                  ; ----------------------------------------------------------------------------
  1362                                  
  1363                                  all_read:
  1364                                  ;
  1365                                  ; Let the user (and programmer!) know we got this far.  This used to be
  1366                                  ; in Sector 1, but makes a lot more sense here.
  1367                                  ;
  1368 000003DE BE[DF1D]                		mov si,copyright_str
  1369 000003E1 E888FD                  		call writestr
  1370                                  
  1371                                  ;
  1372                                  ; Common initialization code
  1373                                  ;
  1374                                  %include "cpuinit.inc"
  1375                              <1> ;; $Id: cpuinit.inc,v 1.3 2003/04/15 21:28:18 hpa Exp $
  1376                              <1> ;; -----------------------------------------------------------------------
  1377                              <1> ;;   
  1378                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  1379                              <1> ;;
  1380                              <1> ;;   This program is free software; you can redistribute it and/or modify
  1381                              <1> ;;   it under the terms of the GNU General Public License as published by
  1382                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  1383                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  1384                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  1385                              <1> ;;
  1386                              <1> ;; -----------------------------------------------------------------------
  1387                              <1> 
  1388                              <1> ;;
  1389                              <1> ;; cpuinit.inc
  1390                              <1> ;; 
  1391                              <1> ;; CPU-dependent initialization and related checks.
  1392                              <1> ;;
  1393                              <1> 
  1394                              <1> check_escapes:
  1395 000003E4 B402                <1> 		mov ah,02h			; Check keyboard flags
  1396 000003E6 CD16                <1> 		int 16h
  1397 000003E8 A2C957              <1> 		mov [KbdFlags],al		; Save for boot prompt check
  1398 000003EB A804                <1> 		test al,04h			; Ctrl->skip 386 check
  1399 000003ED 7510                <1> 		jnz skip_checks
  1400                              <1> 
  1401                              <1> ;
  1402                              <1> ; Now check that there is sufficient low (DOS) memory
  1403                              <1> ;
  1404                              <1> ; NOTE: Linux doesn't use all of real_mode_seg, but we use the same
  1405                              <1> ; segment for COMBOOT images, which can use all 64K
  1406                              <1> ;
  1407                              <1> dosram_k	equ (real_mode_seg+0x1000) >> 6	; Minimum DOS memory (K)
  1408 000003EF CD12                <1> 		int 12h
  1409 000003F1 3D8001              <1> 		cmp ax,dosram_k
  1410 000003F4 7309                <1> 		jae enough_ram
  1411 000003F6 BE[571E]            <1> 		mov si,err_noram
  1412 000003F9 E870FD              <1> 		call writestr
  1413 000003FC E923FD              <1> 		jmp kaboom
  1414                              <1> enough_ram:
  1415                              <1> skip_checks:
  1416                              <1> 
  1417                              <1> ;
  1418                              <1> ; Check if we're 386 (as opposed to 486+); if so we need to blank out
  1419                              <1> ; the WBINVD instruction
  1420                              <1> ;
  1421                              <1> ; We check for 486 by setting EFLAGS.AC
  1422                              <1> ;
  1423                              <1> %if DO_WBINVD
  1424                              <1> 		pushfd				; Save the good flags
  1425                              <1> 		pushfd
  1426                              <1> 		pop eax
  1427                              <1> 		mov ebx,eax
  1428                              <1> 		xor eax,(1 << 18)		; AC bit
  1429                              <1> 		push eax
  1430                              <1> 		popfd
  1431                              <1> 		pushfd
  1432                              <1> 		pop eax
  1433                              <1> 		popfd				; Restore the original flags
  1434                              <1> 		xor eax,ebx
  1435                              <1> 		jnz is_486
  1436                              <1> ;
  1437                              <1> ; 386 - Looks like we better blot out the WBINVD instruction
  1438                              <1> ;
  1439                              <1> 		mov byte [try_wbinvd],0c3h		; Near RET
  1440                              <1> is_486:
  1441                              <1> %endif	; DO_WBINVD
  1442                              <1> ;
  1443                              <1> ; Mark A20 type as unknown.  This particular word needs to be in BSS,
  1444                              <1> ; so it needs to be initialized.
  1445                              <1> ;
  1446 000003FF C706B0570000        <1> 		mov word [A20Type],0
  1447                              <1> 
  1448                              <1> 
  1449                                  
  1450                                  ;
  1451                                  ; Initialization that does not need to go into the any of the pre-load
  1452                                  ; areas
  1453                                  ;
  1454                                  		; Now set up screen parameters
  1455 00000405 E8CF16                  		call adjust_screen
  1456                                  
  1457                                  		; Wipe the F-key area
  1458 00000408 B020                    		mov al,NULLFILE
  1459 0000040A BF0056                  		mov di,FKeyName
  1460 0000040D B9A000                  		mov cx,10*(1 << FILENAME_MAX_LG2)
  1461 00000410 F3AA                    		rep stosb
  1462                                  
  1463                                  ;
  1464                                  ; Now, everything is "up and running"... patch kaboom for more
  1465                                  ; verbosity and using the full screen system
  1466                                  ;
  1467                                  		; E9 = JMP NEAR
  1468 00000412 66C706[3001]E9AF0F-     		mov dword [kaboom.patch],0e9h+((kaboom2-(kaboom.patch+3)) << 8)
  1469 0000041A 00                 
  1470                                  
  1471                                  ;
  1472                                  ; Compute some parameters that depend on cluster size
  1473                                  ;
  1474 0000041B 6631C0                  		xor eax,eax
  1475 0000041E 99                      		cwd				; DX <- 0
  1476 0000041F 42                      		inc dx				; DX:AX <- 64K
  1477 00000420 F7367857                		div word [ClustSize]
  1478 00000424 66A37457                		mov [ClustPerMoby],eax		; Clusters/64K
  1479                                  
  1480                                  ;
  1481                                  ; Now we're all set to start with our *real* business.	First load the
  1482                                  ; configuration file (if any) and parse it.
  1483                                  ;
  1484                                  ; In previous versions I avoided using 32-bit registers because of a
  1485                                  ; rumour some BIOSes clobbered the upper half of 32-bit registers at
  1486                                  ; random.  I figure, though, that if there are any of those still left
  1487                                  ; they probably won't be trying to install Linux on them...
  1488                                  ;
  1489                                  ; The code is still ripe with 16-bitisms, though.  Not worth the hassle
  1490                                  ; to take'm out.  In fact, we may want to put them back if we're going
  1491                                  ; to boot ELKS at some point.
  1492                                  ;
  1493 00000428 BE[F621]                		mov si,linuxauto_cmd		; Default command: "linux auto"
  1494 0000042B BF2959                  		mov di,default_cmd
  1495 0000042E B90B00                                  mov cx,linuxauto_len
  1496 00000431 F3A4                    		rep movsb
  1497                                  
  1498 00000433 BF0055                  		mov di,KbdMap			; Default keymap 1:1
  1499 00000436 30C0                    		xor al,al
  1500 00000438 FEC5                    		inc ch				; CX <- 256
  1501 0000043A AA                      mkkeymap:	stosb
  1502 0000043B FEC0                    		inc al
  1503 0000043D E2FB                    		loop mkkeymap
  1504                                  
  1505                                  ;
  1506                                  ; Load configuration file
  1507                                  ;
  1508 0000043F BF[D620]                		mov di,syslinux_cfg
  1509 00000442 E8530D                  		call open
  1510 00000445 7403                    		jz no_config_file
  1511                                  
  1512                                  ;
  1513                                  ; Now we have the config file open.  Parse the config file and
  1514                                  ; run the user interface.
  1515                                  ;
  1516                                  %include "ui.inc"
  1517                              <1> ;; $Id: ui.inc,v 1.11 2004/05/29 22:11:23 hpa Exp $
  1518                              <1> ;; -----------------------------------------------------------------------
  1519                              <1> ;;   
  1520                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  1521                              <1> ;;
  1522                              <1> ;;   This program is free software; you can redistribute it and/or modify
  1523                              <1> ;;   it under the terms of the GNU General Public License as published by
  1524                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  1525                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  1526                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  1527                              <1> ;;
  1528                              <1> ;; -----------------------------------------------------------------------
  1529                              <1> 
  1530                              <1> ;
  1531                              <1> ; This file should be entered with the config file open (for getc)
  1532                              <1> ;
  1533 00000447 E8E612              <1> 		call parse_config		; Parse configuration file
  1534                              <1> no_config_file:
  1535                              <1> ;
  1536                              <1> ; Check whether or not we are supposed to display the boot prompt.
  1537                              <1> ;
  1538                              <1> check_for_key:
  1539 0000044A 833E[EA21]00        <1> 		cmp word [ForcePrompt],byte 0	; Force prompt?
  1540 0000044F 7509                <1> 		jnz enter_command
  1541 00000451 F606C9575B          <1> 		test byte [KbdFlags],5Bh	; Caps, Scroll, Shift, Alt
  1542 00000456 0F840F01            <1> 		jz auto_boot			; If neither, default boot
  1543                              <1> 
  1544                              <1> enter_command:
  1545 0000045A BE[091E]            <1> 		mov si,boot_prompt
  1546 0000045D E82111              <1> 		call cwritestr
  1547                              <1> 
  1548 00000460 C606CC5700          <1> 		mov byte [FuncFlag],0		; <Ctrl-F> not pressed
  1549 00000465 BF2858              <1> 		mov di,command_line
  1550                              <1> ;
  1551                              <1> ; get the very first character -- we can either time
  1552                              <1> ; out, or receive a character press at this time.  Some dorky BIOSes stuff
  1553                              <1> ; a return in the buffer on bootup, so wipe the keyboard buffer first.
  1554                              <1> ;
  1555 00000468 B401                <1> clear_buffer:	mov ah,1			; Check for pending char
  1556 0000046A CD16                <1> 		int 16h
  1557 0000046C 7406                <1> 		jz get_char_time
  1558 0000046E 31C0                <1> 		xor ax,ax			; Get char
  1559 00000470 CD16                <1> 		int 16h
  1560 00000472 EBF4                <1> 		jmp short clear_buffer
  1561                              <1> get_char_time:	
  1562 00000474 E82718              <1> 		call vgashowcursor
  1563                              <1> 		RESET_IDLE
  1564                              <2> 
  1565 00000477 8B0E[E221]          <1> 		mov cx,[KbdTimeOut]
  1566 0000047B 21C9                <1> 		and cx,cx
  1567 0000047D 7425                <1> 		jz get_char			; Timeout == 0 -> no timeout
  1568 0000047F 41                  <1> 		inc cx				; The first loop will happen
  1569                              <1> 						; immediately as we don't
  1570                              <1> 						; know the appropriate DX value
  1571 00000480 51                  <1> time_loop:	push cx
  1572 00000481 52                  <1> tick_loop:	push dx
  1573 00000482 E89A10              <1> 		call pollchar
  1574 00000485 751B                <1> 		jnz get_char_pop
  1575 00000487 8B166C04            <1> 		mov dx,[BIOS_timer]		; Get time "of day"
  1576 0000048B 58                  <1> 		pop ax
  1577 0000048C 39C2                <1> 		cmp dx,ax			; Has the timer advanced?
  1578 0000048E 74F1                <1> 		je tick_loop
  1579 00000490 59                  <1> 		pop cx
  1580                              <1> 		DO_IDLE
  1581                              <2> 
  1582 00000491 E2ED                <1> 		loop time_loop			; If so, decrement counter
  1583                              <1> 
  1584                              <1> 		; Timeout!!!!
  1585 00000493 E80E18              <1> 		call vgahidecursor
  1586 00000496 BE0053              <1> 		mov si,Ontimeout		; Copy ontimeout command
  1587 00000499 8B0E[DE21]          <1> 		mov cx,[OntimeoutLen]		; if we have one...
  1588 0000049D F3A4                <1> 		rep movsb
  1589                              <1> .stddefault:
  1590 0000049F E9D500              <1> 		jmp command_done
  1591                              <1> 
  1592 000004A2 6658                <1> get_char_pop:	pop eax				; Clear stack
  1593                              <1> get_char:
  1594 000004A4 E8F717              <1> 		call vgashowcursor
  1595 000004A7 E89F10              <1> 		call getchar
  1596 000004AA E8F717              <1> 		call vgahidecursor
  1597 000004AD 20C0                <1> 		and al,al
  1598 000004AF 7471                <1> 		jz func_key
  1599                              <1> 
  1600 000004B1 3C7F                <1> got_ascii:	cmp al,7Fh			; <DEL> == <BS>
  1601 000004B3 7449                <1> 		je backspace
  1602 000004B5 3C20                <1> 		cmp al,' '			; ASCII?
  1603 000004B7 722A                <1> 		jb not_ascii
  1604 000004B9 7706                <1> 		ja enter_char
  1605 000004BB 81FF2858            <1> 		cmp di,command_line		; Space must not be first
  1606 000004BF 74E3                <1> 		je short get_char
  1607 000004C1 F606CC5701          <1> enter_char:	test byte [FuncFlag],1
  1608 000004C6 740F                <1> 		jz .not_ctrl_f
  1609 000004C8 C606CC5700          <1> 		mov byte [FuncFlag],0
  1610 000004CD 3C30                <1> 		cmp al,'0'
  1611 000004CF 7206                <1> 		jb .not_ctrl_f
  1612 000004D1 7447                <1> 		je ctrl_f_0
  1613 000004D3 3C39                <1> 		cmp al,'9'
  1614 000004D5 7645                <1> 		jbe ctrl_f
  1615 000004D7 81FF2759            <1> .not_ctrl_f:	cmp di,max_cmd_len+command_line ; Check there's space
  1616 000004DB 73C7                <1> 		jnb short get_char
  1617 000004DD AA                  <1> 		stosb				; Save it
  1618 000004DE E8EA0B              <1> 		call writechr			; Echo to screen
  1619 000004E1 EBC1                <1> 		jmp short get_char
  1620 000004E3 C606CC5700          <1> not_ascii:	mov byte [FuncFlag],0
  1621 000004E8 3C0D                <1> 		cmp al,0Dh			; Enter
  1622 000004EA 0F848900            <1> 		je command_done
  1623 000004EE 3C06                <1> 		cmp al,06h			; <Ctrl-F>
  1624 000004F0 7421                <1> 		je set_func_flag
  1625 000004F2 3C15                <1> 		cmp al,15h			; <Ctrl-U>
  1626 000004F4 7417                <1> 		je kill_command			; Kill input line
  1627 000004F6 3C16                <1> 		cmp al,16h			; <Ctrl-V>
  1628 000004F8 744E                <1> 		je print_version
  1629 000004FA 3C08                <1> 		cmp al,08h			; Backspace
  1630 000004FC 75A6                <1> 		jne get_char
  1631 000004FE 81FF2858            <1> backspace:	cmp di,command_line		; Make sure there is anything
  1632 00000502 74A0                <1> 		je get_char			; to erase
  1633 00000504 4F                  <1> 		dec di				; Unstore one character
  1634 00000505 BE[101E]            <1> 		mov si,wipe_char		; and erase it from the screen
  1635 00000508 E87610              <1> 		call cwritestr
  1636 0000050B EB0B                <1> 		jmp short get_char_2
  1637                              <1> 
  1638                              <1> kill_command:
  1639 0000050D E86E10              <1> 		call crlf
  1640 00000510 E947FF              <1> 		jmp enter_command
  1641                              <1> 
  1642                              <1> set_func_flag:
  1643 00000513 C606CC5701          <1> 		mov byte [FuncFlag],1
  1644                              <1> get_char_2:
  1645 00000518 EB8A                <1> 		jmp short get_char
  1646                              <1> 
  1647 0000051A 040A                <1> ctrl_f_0:	add al,10			; <Ctrl-F>0 == F10
  1648 0000051C 2C31                <1> ctrl_f:		sub al,'1'
  1649 0000051E 30E4                <1> 		xor ah,ah
  1650 00000520 EB0A                <1> 		jmp short show_help
  1651                              <1> 
  1652                              <1> func_key:
  1653                              <1> 		; AL = 0 if we get here
  1654 00000522 86C4                <1> 		xchg al,ah
  1655 00000524 3C44                <1> 		cmp al,68			; F10
  1656 00000526 77F0                <1> 		ja short get_char_2
  1657 00000528 2C3B                <1> 		sub al,59			; F1
  1658 0000052A 72EC                <1> 		jb short get_char_2
  1659                              <1> show_help:	; AX = func key # (0 = F1, 9 = F10)
  1660 0000052C 57                  <1> 		push di				; Save end-of-cmdline pointer
  1661 0000052D C1E004              <1> 		shl ax,FILENAME_MAX_LG2		; Convert to pointer
  1662 00000530 050056              <1> 		add ax,FKeyName
  1663 00000533 97                  <1> 		xchg di,ax
  1664 00000534 803D20              <1> 		cmp byte [di],NULLFILE
  1665 00000537 742D                <1> 		je short fk_nofile		; Undefined F-key
  1666 00000539 E8150B              <1> 		call searchdir
  1667 0000053C 7428                <1> 		jz short fk_nofile		; File not found
  1668 0000053E 56                  <1> 		push si
  1669 0000053F E83C10              <1> 		call crlf
  1670 00000542 5E                  <1> 		pop si
  1671 00000543 E8FE0D              <1> 		call get_msg_file
  1672 00000546 EB0D                <1> 		jmp short fk_wrcmd
  1673                              <1> 
  1674                              <1> print_version:
  1675 00000548 57                  <1> 		push di				; Command line write pointer
  1676 00000549 BE[0002]            <1> 		mov si,syslinux_banner
  1677 0000054C E83210              <1> 		call cwritestr
  1678 0000054F BE[DF1D]            <1> 		mov si,copyright_str
  1679 00000552 E82C10              <1> 		call cwritestr
  1680                              <1> 
  1681                              <1> 		; ... fall through ...
  1682                              <1> 
  1683                              <1> 		; Write the boot prompt and command line again and
  1684                              <1> 		; wait for input.  Note that this expects the cursor
  1685                              <1> 		; to already have been CRLF'd, and that the old value
  1686                              <1> 		; of DI (the command line write pointer) is on the stack.
  1687                              <1> fk_wrcmd:
  1688 00000555 BE[091E]            <1> 		mov si,boot_prompt
  1689 00000558 E82610              <1> 		call cwritestr
  1690 0000055B 5F                  <1> 		pop di				; Command line write pointer
  1691 0000055C 57                  <1> 		push di
  1692 0000055D C60500              <1> 		mov byte [di],0			; Null-terminate command line
  1693 00000560 BE2858              <1> 		mov si,command_line
  1694 00000563 E81B10              <1> 		call cwritestr			; Write command line so far
  1695 00000566 5F                  <1> fk_nofile:	pop di
  1696 00000567 EBAF                <1> 		jmp short get_char_2
  1697                              <1> auto_boot:
  1698 00000569 BE2959              <1> 		mov si,default_cmd
  1699 0000056C BF2858              <1> 		mov di,command_line
  1700 0000056F B94000              <1> 		mov cx,(max_cmd_len+4) >> 2
  1701 00000572 F366A5              <1> 		rep movsd
  1702 00000575 EB0C                <1> 		jmp short load_kernel
  1703                              <1> command_done:
  1704 00000577 E80410              <1> 		call crlf
  1705 0000057A 81FF2858            <1> 		cmp di,command_line		; Did we just hit return?
  1706 0000057E 74E9                <1> 		je auto_boot
  1707 00000580 30C0                <1> 		xor al,al			; Store a final null
  1708 00000582 AA                  <1> 		stosb
  1709                              <1> 
  1710                              <1> load_kernel:					; Load the kernel now
  1711                              <1> ;
  1712                              <1> ; First we need to mangle the kernel name the way DOS would...
  1713                              <1> ;
  1714 00000583 BE2858              <1> 		mov si,command_line
  1715 00000586 BF7C57              <1>                 mov di,KernelName
  1716 00000589 56                  <1>                 push si
  1717 0000058A 57                  <1>                 push di
  1718 0000058B E8640B              <1> 		call mangle_name
  1719 0000058E 5F                  <1> 		pop di
  1720 0000058F 5E                  <1>                 pop si
  1721                              <1> ;
  1722                              <1> ; Fast-forward to first option (we start over from the beginning, since
  1723                              <1> ; mangle_name doesn't necessarily return a consistent ending state.)
  1724                              <1> ;
  1725 00000590 AC                  <1> clin_non_wsp:   lodsb
  1726 00000591 3C20                <1>                 cmp al,' '
  1727 00000593 77FB                <1>                 ja clin_non_wsp
  1728 00000595 20C0                <1> clin_is_wsp:    and al,al
  1729 00000597 7405                <1>                 jz clin_opt_ptr
  1730 00000599 AC                  <1>                 lodsb
  1731 0000059A 3C20                <1>                 cmp al,' '
  1732 0000059C 76F7                <1>                 jbe clin_is_wsp
  1733 0000059E 4E                  <1> clin_opt_ptr:   dec si                          ; Point to first nonblank
  1734 0000059F 8936A457            <1>                 mov [CmdOptPtr],si		; Save ptr to first option
  1735                              <1> ;
  1736                              <1> ; If "allowoptions 0", put a null character here in order to ignore any
  1737                              <1> ; user-specified options.
  1738                              <1> ;
  1739 000005A3 A1[EE21]            <1> 		mov ax,[AllowOptions]
  1740 000005A6 21C0                <1> 		and ax,ax
  1741 000005A8 7502                <1> 		jnz clin_opt_ok
  1742 000005AA 8804                <1> 		mov [si],al
  1743                              <1> clin_opt_ok:
  1744                              <1> 
  1745                              <1> ;
  1746                              <1> ; Now check if it is a "virtual kernel"
  1747                              <1> ;
  1748 000005AC 8B0E[E821]          <1> 		mov cx,[VKernelCtr]
  1749 000005B0 1E                  <1> 		push ds
  1750 000005B1 680020              <1> 		push word vk_seg
  1751 000005B4 1F                  <1> 		pop ds
  1752 000005B5 83F900              <1> 		cmp cx,byte 0
  1753 000005B8 7413                <1> 		je not_vk
  1754 000005BA 31F6                <1> 		xor si,si			; Point to first vkernel
  1755 000005BC 60                  <1> vk_check:	pusha
  1756 000005BD B90B00              <1> 		mov cx,FILENAME_MAX
  1757 000005C0 F3A6                <1> 		repe cmpsb			; Is this it?
  1758 000005C2 0F84A400            <1> 		je vk_found
  1759 000005C6 61                  <1> 		popa
  1760 000005C7 81C60002            <1> 		add si,vk_size
  1761 000005CB E2EF                <1> 		loop vk_check
  1762 000005CD 1F                  <1> not_vk:		pop ds
  1763                              <1> ;
  1764                              <1> ; Not a "virtual kernel" - check that's OK and construct the command line
  1765                              <1> ;
  1766 000005CE 833E[EC21]00        <1>                 cmp word [AllowImplicit],byte 0
  1767 000005D3 7447                <1>                 je bad_implicit
  1768 000005D5 06                  <1>                 push es
  1769 000005D6 56                  <1>                 push si
  1770 000005D7 57                  <1>                 push di
  1771 000005D8 BF0050              <1>                 mov di,real_mode_seg
  1772 000005DB 8EC7                <1>                 mov es,di
  1773 000005DD BE0052              <1>                 mov si,AppendBuf
  1774 000005E0 BF0090              <1>                 mov di,cmd_line_here
  1775 000005E3 8B0E[DC21]          <1>                 mov cx,[AppendLen]
  1776 000005E7 F3A4                <1>                 rep movsb
  1777 000005E9 893E[E421]          <1>                 mov [CmdLinePtr],di
  1778 000005ED 5F                  <1>                 pop di
  1779 000005EE 5E                  <1>                 pop si
  1780 000005EF 07                  <1>                 pop es
  1781                              <1> ;
  1782                              <1> ; Find the kernel on disk
  1783                              <1> ;
  1784 000005F0 C606875700          <1> get_kernel:     mov byte [KernelName+FILENAME_MAX],0	; Zero-terminate filename/extension
  1785                              <1> %if IS_SYSLINUX || IS_MDSLINUX			; SYSLINUX has to deal with DOS mangled names...
  1786 000005F5 66A18457            <1> 		mov eax,[KernelName+8]		; Save initial extension
  1787 000005F9 66A3[D421]          <1> 		mov [exten_table_end],eax	; Last case == initial ext.
  1788                              <1> %else
  1789                              <1> 		mov di,KernelName
  1790                              <1> 		xor al,al
  1791                              <1> 		mov cx,FILENAME_MAX-5		; Need 4 chars + null
  1792                              <1> 		repne scasb			; Scan for final null
  1793                              <1> 		jne .no_skip
  1794                              <1> 		dec di				; Point to final null 
  1795                              <1> .no_skip:	mov [KernelExtPtr],di
  1796                              <1> %endif
  1797 000005FD BB[C021]            <1> 		mov bx,exten_table
  1798 00000600 53                  <1> .search_loop:	push bx
  1799 00000601 BF7C57              <1>                 mov di,KernelName	      	; Search on disk
  1800 00000604 E84A0A              <1>                 call searchdir
  1801 00000607 5B                  <1> 		pop bx
  1802 00000608 0F859700            <1>                 jnz kernel_good
  1803 0000060C 668B07              <1> 		mov eax,[bx]			; Try a different extension
  1804                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  1805 0000060F 66A38457            <1> 		mov [KernelName+8],eax
  1806                              <1> %else
  1807                              <1> 		mov si,[KernelExtPtr]
  1808                              <1> 		mov [si],eax
  1809                              <1> 		mov byte [si+4],0
  1810                              <1> %endif
  1811 00000613 83C304              <1> 		add bx,byte 4
  1812 00000616 81FB[D421]          <1> 		cmp bx,exten_table_end
  1813 0000061A 76E4                <1> 		jna .search_loop		; allow == case (final case)
  1814                              <1> 		; Fall into bad_kernel
  1815                              <1> ;
  1816                              <1> ; bad_kernel: Kernel image not found
  1817                              <1> ; bad_implicit: The user entered a nonvirtual kernel name, with "implicit 0"
  1818                              <1> ;
  1819                              <1> bad_implicit:
  1820                              <1> bad_kernel:
  1821 0000061C 8B0E[E021]          <1> 		mov cx,[OnerrorLen]
  1822 00000620 21C9                <1> 		and cx,cx
  1823 00000622 751A                <1> 		jnz on_error
  1824                              <1> .really:
  1825 00000624 BE7C57              <1> 		mov si,KernelName
  1826 00000627 BFE557              <1>                 mov di,KernelCName
  1827 0000062A 57                  <1> 		push di
  1828 0000062B E81F0B              <1>                 call unmangle_name              ; Get human form
  1829 0000062E BE[141E]            <1> 		mov si,err_notfound		; Complain about missing kernel
  1830 00000631 E84D0F              <1> 		call cwritestr
  1831 00000634 5E                  <1> 		pop si				; KernelCName
  1832 00000635 E8490F              <1>                 call cwritestr
  1833 00000638 BE[D020]            <1>                 mov si,crlf_msg
  1834 0000063B E9FE09              <1>                 jmp abort_load                  ; Ask user for clue
  1835                              <1> 
  1836                              <1> ;
  1837                              <1> ; on_error: bad kernel, but we have onerror set
  1838                              <1> ;
  1839                              <1> on_error:
  1840 0000063E BE0054              <1> 		mov si,Onerror
  1841 00000641 BF2858              <1> 		mov di,command_line
  1842 00000644 56                  <1> 		push si				; <A>
  1843 00000645 57                  <1> 		push di				; <B>
  1844 00000646 51                  <1> 		push cx				; <C>
  1845 00000647 51                  <1> 		push cx				; <D>
  1846 00000648 57                  <1> 		push di				; <E>
  1847 00000649 F3A6                <1> 		repe cmpsb
  1848 0000064B 5F                  <1> 		pop di				; <E> di == command_line
  1849 0000064C 5B                  <1> 		pop bx				; <D> bx == [OnerrorLen]
  1850 0000064D 74D5                <1> 		je bad_kernel.really		; Onerror matches command_line already
  1851 0000064F F7DB                <1> 		neg bx				; bx == -[OnerrorLen]
  1852 00000651 8D8FFF00            <1> 		lea cx,[max_cmd_len+bx]
  1853                              <1> 		; CX == max_cmd_len-[OnerrorLen]
  1854 00000655 BF2659              <1> 		mov di,command_line+max_cmd_len-1
  1855 00000658 C6450100            <1> 		mov byte [di+1],0		; Enforce null-termination
  1856 0000065C 8D31                <1> 		lea si,[di+bx]
  1857 0000065E FD                  <1> 		std
  1858 0000065F F3A4                <1> 		rep movsb			; Make space in command_line
  1859 00000661 FC                  <1> 		cld
  1860 00000662 59                  <1> 		pop cx				; <C> cx == [OnerrorLen]
  1861 00000663 5F                  <1> 		pop di				; <B> di == command_line
  1862 00000664 5E                  <1> 		pop si				; <A> si  == Onerror
  1863 00000665 F3A4                <1> 		rep movsb
  1864 00000667 E919FF              <1> 		jmp load_kernel
  1865                              <1> 
  1866                              <1> ;
  1867                              <1> ; vk_found: We *are* using a "virtual kernel"
  1868                              <1> ;
  1869 0000066A 61                  <1> vk_found:	popa
  1870 0000066B 57                  <1> 		push di
  1871 0000066C BF0050              <1> 		mov di,VKernelBuf
  1872 0000066F B98000              <1> 		mov cx,vk_size >> 2
  1873 00000672 F366A5              <1> 		rep movsd
  1874 00000675 06                  <1> 		push es				; Restore old DS
  1875 00000676 1F                  <1> 		pop ds
  1876 00000677 06                  <1> 		push es
  1877 00000678 680050              <1> 		push word real_mode_seg
  1878 0000067B 07                  <1> 		pop es
  1879 0000067C BF0090              <1> 		mov di,cmd_line_here
  1880 0000067F BE1850              <1> 		mov si,VKernelBuf+vk_append
  1881 00000682 8B0E1650            <1> 		mov cx,[VKernelBuf+vk_appendlen]
  1882 00000686 F3A4                <1> 		rep movsb
  1883 00000688 893E[E421]          <1> 		mov [CmdLinePtr],di		; Where to add rest of cmd
  1884 0000068C 07                  <1> 		pop es
  1885 0000068D 5F                  <1>                 pop di                          ; DI -> KernelName
  1886 0000068E 57                  <1> 		push di	
  1887 0000068F BE0B50              <1> 		mov si,VKernelBuf+vk_rname
  1888 00000692 B90B00              <1> 		mov cx,FILENAME_MAX		; We need ECX == CX later
  1889 00000695 F3A4                <1> 		rep movsb
  1890 00000697 5F                  <1> 		pop di
  1891                              <1> %if IS_PXELINUX
  1892                              <1> 		mov al,[VKernelBuf+vk_ipappend]
  1893                              <1> 		mov [IPAppend],al
  1894                              <1> %endif
  1895 00000698 31DB                <1> 		xor bx,bx			; Try only one version
  1896                              <1> 
  1897                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  1898 0000069A E953FF              <1> 		jmp get_kernel
  1899                              <1> %else
  1900                              <1> 		; Is this a "localboot" pseudo-kernel?
  1901                              <1> 		cmp byte [VKernelBuf+vk_rname], 0
  1902                              <1> 		jne get_kernel		; No, it's real, go get it
  1903                              <1> 
  1904                              <1> 		mov ax, [VKernelBuf+vk_rname+1]
  1905                              <1> 		jmp local_boot
  1906                              <1> %endif
  1907                              <1> 
  1908                              <1> ;
  1909                              <1> ; kernel_corrupt: Called if the kernel file does not seem healthy
  1910                              <1> ;
  1911 0000069D BE[321E]            <1> kernel_corrupt: mov si,err_notkernel
  1912 000006A0 E99909              <1>                 jmp abort_load
  1913                              <1> ;
  1914                              <1> ; This is it!  We have a name (and location on the disk)... let's load
  1915                              <1> ; that sucker!!  First we have to decide what kind of file this is; base
  1916                              <1> ; that decision on the file extension.  The following extensions are
  1917                              <1> ; recognized; case insensitive:
  1918                              <1> ;
  1919                              <1> ; .com 	- COMBOOT image
  1920                              <1> ; .cbt	- COMBOOT image
  1921                              <1> ; .c32  - COM32 image
  1922                              <1> ; .bs	- Boot sector
  1923                              <1> ; .0	- PXE bootstrap program (PXELINUX only)
  1924                              <1> ; .bin  - Boot sector
  1925                              <1> ; .bss	- Boot sector, but transfer over DOS superblock (SYSLINUX only)
  1926                              <1> ; .img  - Floppy image (ISOLINUX only)
  1927                              <1> ;
  1928                              <1> ; Anything else is assumed to be a Linux kernel.
  1929                              <1> ;
  1930                              <1> kernel_good:
  1931 000006A3 60                  <1> 		pusha
  1932 000006A4 BE7C57              <1> 		mov si,KernelName
  1933 000006A7 BFE557              <1> 		mov di,KernelCName
  1934 000006AA E8A00A              <1> 		call unmangle_name
  1935 000006AD 81EFE557            <1> 		sub di,KernelCName
  1936 000006B1 893EA657            <1> 		mov [KernelCNameLen],di
  1937 000006B5 61                  <1> 		popa
  1938                              <1> 		
  1939                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  1940 000006B6 668B0E8357          <1> 		mov ecx,[KernelName+7]
  1941 000006BB B12E                <1> 		mov cl,'.'
  1942                              <1> %else
  1943                              <1> 		push di
  1944                              <1> 		push ax
  1945                              <1> 		mov di,KernelName
  1946                              <1> 		xor al,al
  1947                              <1> 		mov cx,FILENAME_MAX
  1948                              <1> 		repne scasb
  1949                              <1> 		jne .one_step
  1950                              <1> 		dec di
  1951                              <1> .one_step:	mov ecx,[di-4]			; 4 bytes before end
  1952                              <1> 		pop ax
  1953                              <1> 		pop di
  1954                              <1> %endif
  1955                              <1> 
  1956                              <1> ;
  1957                              <1> ; At this point, DX:AX contains the size of the kernel, and SI contains
  1958                              <1> ; the file handle/cluster pointer.
  1959                              <1> ;
  1960 000006BD 6681C900202020      <1> 		or ecx,20202000h		; Force lower case
  1961                              <1> 
  1962 000006C4 6681F92E636F6D      <1> 		cmp ecx,'.com'
  1963 000006CB 0F84DC03            <1> 		je is_comboot_image
  1964 000006CF 6681F92E636274      <1> 		cmp ecx,'.cbt'
  1965 000006D6 0F84D103            <1> 		je is_comboot_image
  1966 000006DA 6681F92E633332      <1> 		cmp ecx,'.c32'
  1967 000006E1 0F849D06            <1> 		je is_com32_image
  1968                              <1> %if IS_ISOLINUX
  1969                              <1> 		cmp ecx,'.img'
  1970                              <1> 		je is_disk_image
  1971                              <1> %endif
  1972 000006E5 6681F92E627373      <1> 		cmp ecx,'.bss'
  1973 000006EC 0F84A508            <1> 		je is_bss_sector
  1974 000006F0 6681F92E62696E      <1> 		cmp ecx,'.bin'
  1975 000006F7 0F849308            <1> 		je is_bootsector
  1976                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  1977 000006FB 6681F92E627320      <1> 		cmp ecx,'.bs '
  1978 00000702 0F848808            <1> 		je is_bootsector
  1979 00000706 6681F92E302020      <1> 		cmp ecx,'.0  '
  1980 0000070D 0F847D08            <1> 		je is_bootsector
  1981                              <1> %else
  1982                              <1> 		shr ecx,8
  1983                              <1> 		cmp ecx,'.bs'
  1984                              <1> 		je is_bootsector
  1985                              <1> 		shr ecx,8
  1986                              <1> 		cmp cx,'.0'
  1987                              <1> 		je is_bootsector
  1988                              <1> %endif
  1989                              <1> 		; Otherwise Linux kernel
  1990                              <1> 
  1991                                  
  1992                                  ;
  1993                                  ; Linux kernel loading code is common.
  1994                                  ;
  1995                                  %include "runkernel.inc"
  1996                              <1> ;; $Id: runkernel.inc,v 1.12 2003/08/22 03:39:37 hpa Exp $
  1997                              <1> ;; -----------------------------------------------------------------------
  1998                              <1> ;;   
  1999                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  2000                              <1> ;;
  2001                              <1> ;;   This program is free software; you can redistribute it and/or modify
  2002                              <1> ;;   it under the terms of the GNU General Public License as published by
  2003                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  2004                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  2005                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  2006                              <1> ;;
  2007                              <1> ;; -----------------------------------------------------------------------
  2008                              <1> 
  2009                              <1> ;;
  2010                              <1> ;; runkernel.inc
  2011                              <1> ;; 
  2012                              <1> ;; Common code for running a Linux kernel
  2013                              <1> ;;
  2014                              <1> 
  2015                              <1> ;
  2016                              <1> ; Hook macros, that may or may not be defined
  2017                              <1> ;
  2018                              <1> %ifndef HAVE_SPECIAL_APPEND
  2019                              <1> %macro SPECIAL_APPEND 0
  2020                              <1> %endmacro
  2021                              <1> %endif
  2022                              <1> 
  2023                              <1> %ifndef HAVE_UNLOAD_PREP
  2024                              <1> %macro UNLOAD_PREP 0
  2025                              <1> %endmacro
  2026                              <1> %endif
  2027                              <1> 
  2028                              <1> ;
  2029                              <1> ; A Linux kernel consists of three parts: boot sector, setup code, and
  2030                              <1> ; kernel code.	The boot sector is never executed when using an external
  2031                              <1> ; booting utility, but it contains some status bytes that are necessary.
  2032                              <1> ;
  2033                              <1> ; First check that our kernel is at least 1K and less than 8M (if it is
  2034                              <1> ; more than 8M, we need to change the logic for loading it anyway...)
  2035                              <1> ;
  2036                              <1> ; We used to require the kernel to be 64K or larger, but it has gotten
  2037                              <1> ; popular to use the Linux kernel format for other things, which may
  2038                              <1> ; not be so large.
  2039                              <1> ;
  2040                              <1> is_linux_kernel:
  2041 00000711 81FA8000            <1>                 cmp dx,80h			; 8 megs
  2042 00000715 7786                <1> 		ja kernel_corrupt
  2043 00000717 21D2                <1> 		and dx,dx
  2044 00000719 7507                <1> 		jnz kernel_sane
  2045 0000071B 3D0004              <1> 		cmp ax,1024			; Bootsect + 1 setup sect
  2046 0000071E 0F827BFF            <1> 		jb kernel_corrupt
  2047 00000722 50                  <1> kernel_sane:	push ax
  2048 00000723 52                  <1> 		push dx
  2049 00000724 56                  <1> 		push si
  2050 00000725 BE[BB20]            <1> 		mov si,loading_msg
  2051 00000728 E8560E              <1>                 call cwritestr
  2052                              <1> ;
  2053                              <1> ; Now start transferring the kernel
  2054                              <1> ;
  2055 0000072B 680050              <1> 		push word real_mode_seg
  2056 0000072E 07                  <1> 		pop es
  2057                              <1> 
  2058 0000072F 660FB7C0            <1> 		movzx eax,ax			; Fix this by using a 32-bit
  2059 00000733 66C1E210            <1> 		shl edx,16			; register for the kernel size
  2060 00000737 6609D0              <1> 		or eax,edx
  2061 0000073A 66A36857            <1> 		mov [KernelSize],eax
  2062 0000073E 6631D2              <1> 		xor edx,edx
  2063 00000741 66F7367857          <1> 		div dword [ClustSize]		; # of clusters total
  2064                              <1> 		; Round up...
  2065 00000746 6683C2FF            <1> 		add edx,byte -1			; Sets CF if EDX >= 1
  2066 0000074A 6683D000            <1> 		adc eax,byte 0			; Add 1 to EAX if CF set
  2067 0000074E 66A39C57            <1>                 mov [KernelClust],eax
  2068                              <1> 
  2069                              <1> ;
  2070                              <1> ; Now, if we transfer these straight, we'll hit 64K boundaries.	 Hence we
  2071                              <1> ; have to see if we're loading more than 64K, and if so, load it step by
  2072                              <1> ; step.
  2073                              <1> ;
  2074                              <1> 
  2075                              <1> ;
  2076                              <1> ; Start by loading the bootsector/setup code, to see if we need to
  2077                              <1> ; do something funky.  It should fit in the first 32K (loading 64K won't
  2078                              <1> ; work since we might have funny stuff up near the end of memory).
  2079                              <1> ; If we have larger than 32K clusters, yes, we're hosed.
  2080                              <1> ;
  2081 00000752 E8D308              <1> 		call abort_check		; Check for abort key
  2082 00000755 668B0E7457          <1> 		mov ecx,[ClustPerMoby]
  2083 0000075A 66D1E9              <1> 		shr ecx,1			; Half a moby
  2084 0000075D 663B0E9C57          <1> 		cmp ecx,[KernelClust]
  2085 00000762 7605                <1> 		jna .normalkernel
  2086 00000764 668B0E9C57          <1> 		mov ecx,[KernelClust]
  2087                              <1> .normalkernel:
  2088 00000769 66290E9C57          <1> 		sub [KernelClust],ecx
  2089 0000076E 31DB                <1> 		xor bx,bx
  2090 00000770 5E                  <1>                 pop si                          ; Cluster pointer on stack
  2091 00000771 E8A1FB              <1> 		call getfssec
  2092 00000774 26813EFE0155AA      <1>                 cmp word [es:bs_bootsign],0AA55h
  2093 0000077B 0F851EFF            <1> 		jne kernel_corrupt		; Boot sec signature missing
  2094                              <1> 
  2095                              <1> ;
  2096                              <1> ; Save the cluster pointer for later...
  2097                              <1> ;
  2098 0000077F 56                  <1> 		push si
  2099                              <1> ;
  2100                              <1> ; Get the BIOS' idea of what the size of high memory is.
  2101                              <1> ;
  2102 00000780 E84B15              <1> 		call highmemsize
  2103                              <1> ;
  2104                              <1> ; Construct the command line (append options have already been copied)
  2105                              <1> ;
  2106                              <1> construct_cmdline:
  2107 00000783 8B3E[E421]          <1> 		mov di,[CmdLinePtr]
  2108 00000787 BE[0122]            <1>                 mov si,boot_image        	; BOOT_IMAGE=
  2109 0000078A B90B00              <1>                 mov cx,boot_image_len
  2110 0000078D F3A4                <1>                 rep movsb
  2111 0000078F BEE557              <1>                 mov si,KernelCName       	; Unmangled kernel name
  2112 00000792 8B0EA657            <1>                 mov cx,[KernelCNameLen]
  2113 00000796 F3A4                <1>                 rep movsb
  2114 00000798 B020                <1>                 mov al,' '                      ; Space
  2115 0000079A AA                  <1>                 stosb
  2116                              <1> 
  2117                              <1> 		SPECIAL_APPEND			; Module-specific hook
  2118                              <1> 
  2119 0000079B 8B36A457            <1>                 mov si,[CmdOptPtr]              ; Options from user input
  2120 0000079F B98100              <1> 		mov cx,(kern_cmd_len+3) >> 2
  2121 000007A2 F366A5              <1> 		rep movsd
  2122                              <1> 
  2123                              <1> ;
  2124                              <1> ; Scan through the command line for anything that looks like we might be
  2125                              <1> ; interested in.  The original version of this code automatically assumed
  2126                              <1> ; the first option was BOOT_IMAGE=, but that is no longer certain.
  2127                              <1> ;
  2128 000007A5 BE0090              <1> 		mov si,cmd_line_here
  2129 000007A8 C606[E621]00        <1>                 mov byte [initrd_flag],0
  2130 000007AD 06                  <1>                 push es				; Set DS <- real_mode_seg
  2131 000007AE 1F                  <1>                 pop ds
  2132 000007AF AC                  <1> get_next_opt:   lodsb
  2133 000007B0 20C0                <1> 		and al,al
  2134 000007B2 0F848100            <1> 		jz cmdline_end
  2135 000007B6 3C20                <1> 		cmp al,' '
  2136 000007B8 76F5                <1> 		jbe get_next_opt
  2137 000007BA 4E                  <1> 		dec si
  2138 000007BB 668B04              <1>                 mov eax,[si]
  2139 000007BE 663D7667613D        <1>                 cmp eax,'vga='
  2140 000007C4 7432                <1> 		je is_vga_cmd
  2141 000007C6 663D6D656D3D        <1>                 cmp eax,'mem='
  2142 000007CC 7459                <1> 		je is_mem_cmd
  2143                              <1> %if IS_PXELINUX
  2144                              <1> 		cmp eax,'keep'			; Is it "keeppxe"?
  2145                              <1> 		jne .notkeep
  2146                              <1> 		cmp dword [si+3],'ppxe'
  2147                              <1> 		jne .notkeep
  2148                              <1> 		cmp byte [si+7],' '		; Must be whitespace or EOS
  2149                              <1> 		ja .notkeep
  2150                              <1> 		or byte [cs:KeepPXE],1
  2151                              <1> .notkeep:
  2152                              <1> %endif
  2153 000007CE 06                  <1>                 push es                         ; Save ES -> real_mode_seg
  2154 000007CF 0E                  <1>                 push cs
  2155 000007D0 07                  <1>                 pop es                          ; Set ES <- normal DS
  2156 000007D1 BF[E120]            <1>                 mov di,initrd_cmd
  2157 000007D4 B90700              <1> 		mov cx,initrd_cmd_len
  2158 000007D7 F3A6                <1> 		repe cmpsb
  2159 000007D9 7514                <1>                 jne not_initrd
  2160                              <1> 
  2161 000007DB BFDA57              <1> 		mov di,InitRD
  2162 000007DE 56                  <1>                 push si                         ; mangle_dir mangles si
  2163 000007DF E81009              <1>                 call mangle_name                ; Mangle ramdisk name
  2164 000007E2 5E                  <1>                 pop si
  2165 000007E3 26803EDA5720        <1> 		cmp byte [es:InitRD],NULLFILE	; Null filename?
  2166 000007E9 260F9706[E621]      <1>                 seta byte [es:initrd_flag]	; Set flag if not
  2167 000007EF 07                  <1> not_initrd:	pop es                          ; Restore ES -> real_mode_seg
  2168 000007F0 AC                  <1> skip_this_opt:  lodsb                           ; Load from command line
  2169 000007F1 3C20                <1>                 cmp al,' '
  2170 000007F3 77FB                <1>                 ja skip_this_opt
  2171 000007F5 4E                  <1>                 dec si
  2172 000007F6 EBB7                <1>                 jmp short get_next_opt
  2173                              <1> is_vga_cmd:
  2174 000007F8 83C604              <1>                 add si,4
  2175 000007FB 668B44FF            <1>                 mov eax,[si-1]
  2176 000007FF BBFFFF              <1>                 mov bx,-1
  2177 00000802 663D3D6E6F72        <1>                 cmp eax,'=nor'			; vga=normal
  2178 00000808 7417                <1>                 je vc0
  2179 0000080A 4B                  <1> 		dec bx				; bx <- -2
  2180 0000080B 663D3D657874        <1>                 cmp eax,'=ext'			; vga=ext
  2181 00000811 740E                <1>                 je vc0
  2182 00000813 4B                  <1>                 dec bx				; bx <- -3
  2183 00000814 663D3D61736B        <1>                 cmp eax,'=ask'			; vga=ask
  2184 0000081A 7405                <1>                 je vc0
  2185 0000081C E8330A              <1>                 call parseint                   ; vga=<number>
  2186 0000081F 72CF                <1> 		jc skip_this_opt		; Not an integer
  2187 00000821 891EFA01            <1> vc0:		mov [bs_vidmode],bx		; Set video mode
  2188 00000825 EBC9                <1> 		jmp short skip_this_opt
  2189                              <1> is_mem_cmd:
  2190 00000827 83C604              <1>                 add si,4
  2191 0000082A E8250A              <1>                 call parseint
  2192 0000082D 72C1                <1> 		jc skip_this_opt		; Not an integer
  2193                              <1> %if HIGHMEM_SLOP != 0
  2194                              <1> 		sub ebx,HIGHMEM_SLOP
  2195                              <1> %endif
  2196 0000082F 2E66891E6057        <1> 		mov [cs:HighMemSize],ebx
  2197 00000835 EBB9                <1> 		jmp short skip_this_opt
  2198                              <1> cmdline_end:
  2199 00000837 0E                  <1>                 push cs                         ; Restore standard DS
  2200 00000838 1F                  <1>                 pop ds
  2201 00000839 81EE0090            <1> 		sub si,cmd_line_here
  2202 0000083D 8936B257            <1> 		mov [CmdLineLen],si		; Length including final null
  2203                              <1> ;
  2204                              <1> ; Now check if we have a large kernel, which needs to be loaded high
  2205                              <1> ;
  2206 00000841 66C7066457FFFFFF37  <1> 		mov dword [RamdiskMax], HIGHMEM_MAX	; Default initrd limit
  2207 0000084A 2666813E0202486472- <1> 		cmp dword [es:su_header],HEADER_ID	; New setup code ID
  2208 00000853 53                  <1>
  2209 00000854 0F850202            <1> 		jne old_kernel		; Old kernel, load low
  2210 00000858 26813E06020002      <1> 		cmp word [es:su_version],0200h	; Setup code version 2.0
  2211 0000085F 0F82F701            <1> 		jb old_kernel		; Old kernel, load low
  2212 00000863 26813E06020102      <1>                 cmp word [es:su_version],0201h	; Version 2.01+?
  2213 0000086A 721F                <1>                 jb new_kernel                   ; If 2.00, skip this step
  2214 0000086C 26C7062402F48F      <1>                 mov word [es:su_heapend],linux_stack	; Set up the heap
  2215 00000873 26800E110280        <1>                 or byte [es:su_loadflags],80h	; Let the kernel know we care
  2216 00000879 26813E06020302      <1> 		cmp word [es:su_version],0203h	; Version 2.03+?
  2217 00000880 7209                <1> 		jb new_kernel			; Not 2.03+
  2218 00000882 2666A12C02          <1> 		mov eax,[es:su_ramdisk_max]
  2219 00000887 66A36457            <1> 		mov [RamdiskMax],eax		; Set the ramdisk limit
  2220                              <1> 
  2221                              <1> ;
  2222                              <1> ; We definitely have a new-style kernel.  Let the kernel know who we are,
  2223                              <1> ; and that we are clueful
  2224                              <1> ;
  2225                              <1> new_kernel:
  2226 0000088B 26C606100231        <1> 		mov byte [es:su_loader],my_id	; Show some ID
  2227 00000891 260FB606F101        <1> 		movzx ax,byte [es:bs_setupsecs]	; Variable # of setup sectors
  2228 00000897 A3AC57              <1> 		mov [SetupSecs],ax
  2229                              <1> ;
  2230                              <1> ; About to load the kernel.  This is a modern kernel, so use the boot flags
  2231                              <1> ; we were provided.
  2232                              <1> ;
  2233 0000089A 26A01102            <1>                 mov al,[es:su_loadflags]
  2234 0000089E A2CA57              <1> 		mov [LoadFlags],al
  2235                              <1> ;
  2236                              <1> ; Load the kernel.  We always load it at 100000h even if we're supposed to
  2237                              <1> ; load it "low"; for a "low" load we copy it down to low memory right before
  2238                              <1> ; jumping to it.
  2239                              <1> ;
  2240                              <1> read_kernel:
  2241 000008A1 BEE557              <1>                 mov si,KernelCName		; Print kernel name part of
  2242 000008A4 E8DA0C              <1>                 call cwritestr                  ; "Loading" message
  2243 000008A7 BE[C420]            <1>                 mov si,dotdot_msg		; Print dots
  2244 000008AA E8D40C              <1>                 call cwritestr
  2245                              <1> 
  2246 000008AD 66A16057            <1>                 mov eax,[HighMemSize]
  2247 000008B1 662D00001000        <1> 		sub eax,100000h			; Load address
  2248 000008B7 663B066857          <1> 		cmp eax,[KernelSize]
  2249 000008BC 0F82B400            <1> 		jb no_high_mem		; Not enough high memory
  2250                              <1> ;
  2251                              <1> ; Move the stuff beyond the setup code to high memory at 100000h
  2252                              <1> ;
  2253 000008C0 660FB736AC57        <1> 		movzx esi,word [SetupSecs]	; Setup sectors
  2254 000008C6 46                  <1> 		inc si				; plus 1 boot sector
  2255 000008C7 C1E609              <1>                 shl si,9			; Convert to bytes
  2256 000008CA 66B900800000        <1>                 mov ecx,8000h			; 32K
  2257 000008D0 6629F1              <1> 		sub ecx,esi			; Number of bytes to copy
  2258 000008D3 6651                <1> 		push ecx
  2259 000008D5 6681C600000500      <1> 		add esi,(real_mode_seg << 4)	; Pointer to source
  2260 000008DC 66BF00001000        <1>                 mov edi,100000h                 ; Copy to address 100000h
  2261                              <1> 
  2262 000008E2 E8130F              <1>                 call bcopy			; Transfer to high memory
  2263                              <1> 
  2264                              <1> 		; On exit EDI -> where to load the rest
  2265                              <1> 
  2266 000008E5 BE[C520]            <1>                 mov si,dot_msg			; Progress report
  2267 000008E8 E8960C              <1>                 call cwritestr
  2268 000008EB E83A07              <1>                 call abort_check
  2269                              <1> 
  2270 000008EE 6659                <1> 		pop ecx				; Number of bytes in the initial portion
  2271 000008F0 5E                  <1> 		pop si				; Restore file handle/cluster pointer
  2272 000008F1 66A16857            <1> 		mov eax,[KernelSize]
  2273 000008F5 662D00800000        <1> 		sub eax,8000h			; Amount of kernel not yet loaded
  2274 000008FB 7603                <1> 		jbe high_load_done		; Zero left (tiny kernel)
  2275                              <1> 
  2276 000008FD E8E510              <1> 		call load_high			; Copy the file
  2277                              <1> 
  2278                              <1> high_load_done:
  2279 00000900 B80050              <1>                 mov ax,real_mode_seg		; Set to real mode seg
  2280 00000903 8EC0                <1>                 mov es,ax
  2281                              <1> 
  2282 00000905 BE[C520]            <1>                 mov si,dot_msg
  2283 00000908 E8760C              <1>                 call cwritestr
  2284                              <1> 
  2285                              <1> ;
  2286                              <1> ; Now see if we have an initial RAMdisk; if so, do requisite computation
  2287                              <1> ; We know we have a new kernel; the old_kernel code already will have objected
  2288                              <1> ; if we tried to load initrd using an old kernel
  2289                              <1> ;
  2290                              <1> load_initrd:
  2291 0000090B F606[E621]01        <1>                 test byte [initrd_flag],1
  2292 00000910 7468                <1>                 jz nk_noinitrd
  2293 00000912 06                  <1>                 push es                         ; ES->real_mode_seg
  2294 00000913 1E                  <1>                 push ds
  2295 00000914 07                  <1>                 pop es                          ; We need ES==DS
  2296 00000915 BEDA57              <1>                 mov si,InitRD
  2297 00000918 BFF257              <1>                 mov di,InitRDCName
  2298 0000091B E82F08              <1>                 call unmangle_name              ; Create human-readable name
  2299 0000091E 81EFF257            <1>                 sub di,InitRDCName
  2300 00000922 893EA857            <1>                 mov [InitRDCNameLen],di
  2301 00000926 BFDA57              <1>                 mov di,InitRD
  2302 00000929 E82507              <1>                 call searchdir                  ; Look for it in directory
  2303 0000092C 07                  <1>                 pop es
  2304 0000092D 7433                <1> 		jz initrd_notthere
  2305 0000092F 26A31C02            <1> 		mov [es:su_ramdisklen1],ax	; Ram disk length
  2306 00000933 2689161E02          <1> 		mov [es:su_ramdisklen2],dx
  2307 00000938 668B166057          <1> 		mov edx,[HighMemSize]		; End of memory
  2308 0000093D 664A                <1> 		dec edx
  2309 0000093F 66A16457            <1> 		mov eax,[RamdiskMax]		; Highest address allowed by kernel
  2310 00000943 6639C2              <1> 		cmp edx,eax
  2311 00000946 7603                <1> 		jna memsize_ok
  2312 00000948 6689C2              <1> 		mov edx,eax			; Adjust to fit inside limit
  2313                              <1> memsize_ok:
  2314 0000094B 6642                <1> 		inc edx
  2315 0000094D 31D2                <1>                 xor dx,dx			; Round down to 64K boundary
  2316 0000094F 26662B161C02        <1> 		sub edx,[es:su_ramdisklen]	; Subtract size of ramdisk
  2317 00000955 31D2                <1>                 xor dx,dx			; Round down to 64K boundary
  2318 00000957 266689161802        <1>                 mov [es:su_ramdiskat],edx	; Load address
  2319 0000095D E81501              <1> 		call loadinitrd			; Load initial ramdisk
  2320 00000960 EB18                <1> 		jmp short initrd_end
  2321                              <1> 
  2322                              <1> initrd_notthere:
  2323 00000962 BE[7A1F]            <1>                 mov si,err_noinitrd
  2324 00000965 E8190C              <1>                 call cwritestr
  2325 00000968 BEF257              <1>                 mov si,InitRDCName
  2326 0000096B E8130C              <1>                 call cwritestr
  2327 0000096E BE[D020]            <1>                 mov si,crlf_msg
  2328 00000971 E9C806              <1>                 jmp abort_load
  2329                              <1> 
  2330 00000974 BE[9B1F]            <1> no_high_mem:    mov si,err_nohighmem		; Error routine
  2331 00000977 E9C206              <1>                 jmp abort_load
  2332                              <1> 
  2333                              <1> initrd_end:
  2334                              <1> nk_noinitrd:
  2335                              <1> ;
  2336                              <1> ; Abandon hope, ye that enter here!  We do no longer permit aborts.
  2337                              <1> ;
  2338 0000097A E8AB06              <1>                 call abort_check        	; Last chance!!
  2339                              <1> 
  2340 0000097D BE[B020]            <1> 		mov si,ready_msg
  2341 00000980 E8FE0B              <1> 		call cwritestr
  2342                              <1> 
  2343 00000983 E8F012              <1> 		call vgaclearmode		; We can't trust ourselves after this
  2344                              <1> 
  2345                              <1> 		UNLOAD_PREP			; Module-specific hook
  2346                              <1> 
  2347                              <1> ;
  2348                              <1> ; Now, if we were supposed to load "low", copy the kernel down to 10000h
  2349                              <1> ; and the real mode stuff to 90000h.  We assume that all bzImage kernels are
  2350                              <1> ; capable of starting their setup from a different address.
  2351                              <1> ;
  2352 00000986 B80050              <1> 		mov ax,real_mode_seg
  2353 00000989 8EE0                <1> 		mov fs,ax
  2354                              <1> 
  2355                              <1> ;
  2356                              <1> ; Copy command line.  Unfortunately, the kernel boot protocol requires
  2357                              <1> ; the command line to exist in the 9xxxxh range even if the rest of the
  2358                              <1> ; setup doesn't.
  2359                              <1> ;
  2360 0000098B FA                  <1> 		cli				; In case of hooked interrupts
  2361 0000098C F606CA5701          <1> 		test byte [LoadFlags],LOAD_HIGH
  2362 00000991 7415                <1> 		jz need_high_cmdline
  2363 00000993 64813E06020202      <1> 		cmp word [fs:su_version],0202h	; Support new cmdline protocol?
  2364 0000099A 720C                <1> 		jb need_high_cmdline
  2365                              <1> 		; New cmdline protocol
  2366                              <1> 		; Store 32-bit (flat) pointer to command line
  2367 0000099C 6466C7062802009005- <1> 		mov dword [fs:su_cmd_line_ptr],(real_mode_seg << 4) + cmd_line_here
  2368 000009A5 00                  <1>
  2369 000009A6 EB6D                <1> 		jmp short in_proper_place
  2370                              <1> 
  2371                              <1> need_high_cmdline:
  2372                              <1> ;
  2373                              <1> ; Copy command line up to 90000h
  2374                              <1> ;
  2375 000009A8 B80090              <1> 		mov ax,9000h
  2376 000009AB 8EC0                <1> 		mov es,ax
  2377 000009AD BE0090              <1> 		mov si,cmd_line_here
  2378 000009B0 89F7                <1> 		mov di,si
  2379 000009B2 64C70620003FA3      <1> 		mov [fs:kern_cmd_magic],word CMD_MAGIC ; Store magic
  2380 000009B9 64893E2200          <1> 		mov [fs:kern_cmd_offset],di	; Store pointer
  2381                              <1> 
  2382 000009BE 8B0EB257            <1> 		mov cx,[CmdLineLen]
  2383 000009C2 83C103              <1> 		add cx,byte 3
  2384 000009C5 C1E902              <1> 		shr cx,2			; Convert to dwords
  2385 000009C8 64F366A5            <1> 		fs rep movsd
  2386                              <1> 
  2387 000009CC 0FA0                <1> 		push fs
  2388 000009CE 07                  <1> 		pop es
  2389                              <1> 
  2390 000009CF F606CA5701          <1> 		test byte [LoadFlags],LOAD_HIGH
  2391 000009D4 753F                <1> 		jnz in_proper_place		; If high load, we're done
  2392                              <1> 
  2393                              <1> ;
  2394                              <1> ; Loading low; we can't assume it's safe to run in place.
  2395                              <1> ;
  2396                              <1> ; Copy real_mode stuff up to 90000h
  2397                              <1> ;
  2398 000009D6 B80090              <1> 		mov ax,9000h
  2399 000009D9 8EC0                <1> 		mov es,ax
  2400 000009DB 8B0EAC57            <1> 		mov cx,[SetupSecs]
  2401 000009DF 41                  <1> 		inc cx				; Setup + boot sector
  2402 000009E0 C1E107              <1> 		shl cx,7			; Sectors -> dwords
  2403 000009E3 31F6                <1> 		xor si,si
  2404 000009E5 31FF                <1> 		xor di,di
  2405 000009E7 64F366A5            <1> 		fs rep movsd			; Copy setup + boot sector
  2406                              <1> ;
  2407                              <1> ; Some kernels in the 1.2 ballpark but pre-bzImage have more than 4
  2408                              <1> ; setup sectors, but the boot protocol had not yet been defined.  They
  2409                              <1> ; rely on a signature to figure out if they need to copy stuff from
  2410                              <1> ; the "protected mode" kernel area.  Unfortunately, we used that area
  2411                              <1> ; as a transfer buffer, so it's going to find the signature there.
  2412                              <1> ; Hence, zero the low 32K beyond the setup area.
  2413                              <1> ;
  2414 000009EB 8B3EAC57            <1> 		mov di,[SetupSecs]
  2415 000009EF 47                  <1> 		inc di				; Setup + boot sector
  2416 000009F0 B94000              <1> 		mov cx,32768/512		; Sectors/32K
  2417 000009F3 29F9                <1> 		sub cx,di			; Remaining sectors
  2418 000009F5 C1E709              <1> 		shl di,9			; Sectors -> bytes
  2419 000009F8 C1E107              <1> 		shl cx,7			; Sectors -> dwords
  2420 000009FB 6631C0              <1> 		xor eax,eax
  2421 000009FE F366AB              <1> 		rep stosd			; Clear region
  2422                              <1> ;
  2423                              <1> ; Copy the kernel down to the "low" location
  2424                              <1> ;
  2425 00000A01 668B0E6857          <1> 		mov ecx,[KernelSize]
  2426 00000A06 66BE00001000        <1> 		mov esi,100000h
  2427 00000A0C 66BF00000100        <1> 		mov edi,10000h
  2428 00000A12 E8E30D              <1> 		call bcopy
  2429                              <1> 
  2430                              <1> ;
  2431                              <1> ; Now everything is where it needs to be...
  2432                              <1> ;
  2433                              <1> ; When we get here, es points to the final segment, either
  2434                              <1> ; 9000h or real_mode_seg
  2435                              <1> ;
  2436                              <1> in_proper_place:
  2437                              <1> 
  2438                              <1> ;
  2439                              <1> ; If the default root device is set to FLOPPY (0000h), change to
  2440                              <1> ; /dev/fd0 (0200h)
  2441                              <1> ;
  2442 00000A15 26833EFC0100        <1> 		cmp word [es:bs_rootdev],byte 0
  2443 00000A1B 7507                <1> 		jne root_not_floppy
  2444 00000A1D 26C706FC010002      <1> 		mov word [es:bs_rootdev],0200h
  2445                              <1> root_not_floppy:
  2446                              <1> 
  2447                              <1> ;
  2448                              <1> ; Copy the disk table to high memory, then re-initialize the floppy
  2449                              <1> ; controller
  2450                              <1> ;
  2451                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  2452 00000A24 2E0FB5367800        <1> 		lgs si,[cs:fdctab]
  2453 00000A2A BFF48F              <1> 		mov di,linux_fdctab
  2454 00000A2D B90600              <1> 		mov cx,6			; 12 bytes
  2455 00000A30 65F3A5              <1> 		gs rep movsw
  2456 00000A33 2EC7067800F48F      <1> 		mov [cs:fdctab],word linux_fdctab ; Save new floppy tab pos
  2457 00000A3A 2E8C067A00          <1> 		mov [cs:fdctab+2],es
  2458                              <1> %endif
  2459                              <1> ;
  2460                              <1> ; Linux wants the floppy motor shut off before starting the kernel,
  2461                              <1> ; at least bootsect.S seems to imply so.
  2462                              <1> ;
  2463                              <1> kill_motor:
  2464 00000A3F 31C0                <1> 		xor ax,ax
  2465 00000A41 31D2                <1> 		xor dx,dx
  2466 00000A43 CD13                <1> 		int 13h
  2467                              <1> 
  2468                              <1> ;
  2469                              <1> ; If we're debugging, wait for a keypress so we can read any debug messages
  2470                              <1> ;
  2471                              <1> %ifdef debug
  2472                              <1>                 xor ax,ax
  2473                              <1>                 int 16h
  2474                              <1> %endif
  2475                              <1> ;
  2476                              <1> ; Set up segment registers and the Linux real-mode stack
  2477                              <1> ; Note: es == the real mode segment
  2478                              <1> ;
  2479 00000A45 FA                  <1> 		cli
  2480 00000A46 8CC3                <1> 		mov bx,es
  2481 00000A48 8EDB                <1> 		mov ds,bx
  2482 00000A4A 8EE3                <1> 		mov fs,bx
  2483 00000A4C 8EEB                <1> 		mov gs,bx
  2484 00000A4E 8ED3                <1> 		mov ss,bx
  2485 00000A50 BCF48F              <1> 		mov sp,linux_stack
  2486                              <1> ;
  2487                              <1> ; We're done... now RUN THAT KERNEL!!!!
  2488                              <1> ; Setup segment == real mode segment + 020h; we need to jump to offset
  2489                              <1> ; zero in the real mode segment.
  2490                              <1> ;
  2491 00000A53 83C320              <1> 		add bx,020h
  2492 00000A56 53                  <1> 		push bx
  2493 00000A57 6A00                <1> 		push word 0h
  2494 00000A59 CB                  <1> 		retf
  2495                              <1> 
  2496                              <1> ;
  2497                              <1> ; Load an older kernel.  Older kernels always have 4 setup sectors, can't have
  2498                              <1> ; initrd, and are always loaded low.
  2499                              <1> ;
  2500                              <1> old_kernel:
  2501 00000A5A F606[E621]01        <1>                 test byte [initrd_flag],1	; Old kernel can't have initrd
  2502 00000A5F 7406                <1>                 jz load_old_kernel
  2503 00000A61 BE[E61F]            <1>                 mov si,err_oldkernel
  2504 00000A64 E9D505              <1>                 jmp abort_load
  2505                              <1> load_old_kernel:
  2506 00000A67 C706AC570400        <1> 		mov word [SetupSecs],4		; Always 4 setup sectors
  2507 00000A6D C606CA5700          <1> 		mov byte [LoadFlags],0		; Always low
  2508 00000A72 E92CFE              <1> 		jmp read_kernel
  2509                              <1> 
  2510                              <1> ;
  2511                              <1> ; Load RAM disk into high memory
  2512                              <1> ;
  2513                              <1> ; Need to be set:
  2514                              <1> ;	su_ramdiskat	- Where in memory to load
  2515                              <1> ;	su_ramdisklen	- Size of file
  2516                              <1> ;	SI		- initrd filehandle/cluster pointer
  2517                              <1> ;
  2518                              <1> loadinitrd:
  2519 00000A75 06                  <1>                 push es                         ; Save ES on entry
  2520 00000A76 B80050              <1> 		mov ax,real_mode_seg
  2521 00000A79 8EC0                <1>                 mov es,ax
  2522 00000A7B 26668B3E1802        <1>                 mov edi,[es:su_ramdiskat]	; initrd load address
  2523 00000A81 56                  <1> 		push si
  2524 00000A82 BE[B920]            <1> 		mov si,crlfloading_msg		; Write "Loading "
  2525 00000A85 E8F90A              <1> 		call cwritestr
  2526 00000A88 BEF257              <1>                 mov si,InitRDCName		; Write ramdisk name
  2527 00000A8B E8F30A              <1>                 call cwritestr
  2528 00000A8E BE[C420]            <1>                 mov si,dotdot_msg		; Write dots
  2529 00000A91 E8ED0A              <1>                 call cwritestr
  2530 00000A94 5E                  <1> 		pop si
  2531                              <1> 
  2532 00000A95 2666A11C02          <1> 		mov eax,[es:su_ramdisklen]
  2533 00000A9A E8480F              <1> 		call load_high			; Load the file
  2534                              <1> 
  2535 00000A9D E8DE0A              <1> 		call crlf
  2536 00000AA0 07                  <1>                 pop es                          ; Restore original ES
  2537 00000AA1 C3                  <1>                 ret
  2538                                  
  2539                                  ;
  2540                                  ; COMBOOT-loading code
  2541                                  ;
  2542                                  %include "comboot.inc"
  2543                              <1> ;; $Id: comboot.inc,v 1.24 2004/02/03 06:35:00 hpa Exp $
  2544                              <1> ;; -----------------------------------------------------------------------
  2545                              <1> ;;   
  2546                              <1> ;;   Copyright 1994-2004 H. Peter Anvin - All Rights Reserved
  2547                              <1> ;;
  2548                              <1> ;;   This program is free software; you can redistribute it and/or modify
  2549                              <1> ;;   it under the terms of the GNU General Public License as published by
  2550                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  2551                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  2552                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  2553                              <1> ;;
  2554                              <1> ;; -----------------------------------------------------------------------
  2555                              <1> 
  2556                              <1> ;;
  2557                              <1> ;; comboot.inc
  2558                              <1> ;; 
  2559                              <1> ;; Common code for running a COMBOOT image
  2560                              <1> ;;
  2561                              <1> 
  2562                              <1> ; Parameter registers definition; this is the definition
  2563                              <1> ; of the stack frame used by INT 21h and INT 22h.
  2564                              <1> %define		P_FLAGS		word [bp+44]
  2565                              <1> %define		P_FLAGSL	byte [bp+44]
  2566                              <1> %define		P_FLAGSH	byte [bp+45]
  2567                              <1> %define		P_CS		word [bp+42]
  2568                              <1> %define		P_IP		word [bp+40]
  2569                              <1> %define		P_DS		word [bp+38]
  2570                              <1> %define		P_ES		word [bp+36]
  2571                              <1> %define		P_FS		word [bp+34]
  2572                              <1> %define		P_GS		word [bp+32]
  2573                              <1> %define		P_EAX		dword [bp+28]
  2574                              <1> %define		P_AX		word [bp+28]
  2575                              <1> %define		P_HAX		word [bp+30]
  2576                              <1> %define		P_AL		byte [bp+28]
  2577                              <1> %define		P_AH		byte [bp+29]
  2578                              <1> %define		P_ECX		dword [bp+24]
  2579                              <1> %define		P_CX		word [bp+24]
  2580                              <1> %define		P_HCX		word [bp+26]
  2581                              <1> %define		P_CL		byte [bp+24]
  2582                              <1> %define		P_CH		byte [bp+25]
  2583                              <1> %define		P_EDX		dword [bp+20]
  2584                              <1> %define		P_DX		word [bp+20]
  2585                              <1> %define		P_HDX		word [bp+22]
  2586                              <1> %define		P_DL		byte [bp+20]
  2587                              <1> %define		P_DH		byte [bp+21]
  2588                              <1> %define		P_EBX		dword [bp+16]
  2589                              <1> %define		P_BX		word [bp+16]
  2590                              <1> %define		P_HBX		word [bp+18]
  2591                              <1> %define		P_BL		byte [bp+16]
  2592                              <1> %define		P_BH		byte [bp+17]
  2593                              <1> %define		P_EBP		dword [bp+8]
  2594                              <1> %define		P_BP		word [bp+8]
  2595                              <1> %define		P_HBP		word [bp+10]
  2596                              <1> %define		P_ESI		dword [bp+4]
  2597                              <1> %define		P_SI		word [bp+4]
  2598                              <1> %define		P_HSI		word [bp+6]
  2599                              <1> %define		P_EDI		dword [bp]
  2600                              <1> %define		P_DI		word [bp]
  2601                              <1> %define		P_HDI		word [bp+2]
  2602                              <1> 
  2603                              <1> ; Looks like a COMBOOT image but too large
  2604                              <1> comboot_too_large:
  2605 00000AA2 BE[3620]            <1> 		mov si,err_comlarge
  2606 00000AA5 E8D90A              <1> 		call cwritestr
  2607 00000AA8 E9AFF9              <1> 		jmp enter_command
  2608                              <1> 
  2609                              <1> ;
  2610                              <1> ; Load a COMBOOT image.  A COMBOOT image is basically a DOS .COM file,
  2611                              <1> ; except that it may, of course, not contain any DOS system calls.  We
  2612                              <1> ; do, however, allow the execution of INT 20h to return to SYSLINUX.
  2613                              <1> ;
  2614                              <1> is_comboot_image:
  2615 00000AAB 21D2                <1> 		and dx,dx
  2616 00000AAD 75F3                <1> 		jnz comboot_too_large
  2617 00000AAF 3D00FF              <1> 		cmp ax,0ff00h		; Max size in bytes
  2618 00000AB2 73EE                <1> 		jae comboot_too_large
  2619                              <1> 
  2620 00000AB4 56                  <1> 		push si			; Save file handle
  2621                              <1> 
  2622 00000AB5 E8BB04              <1> 		call make_plain_cmdline
  2623                              <1> 
  2624 00000AB8 E86700              <1> 		call comboot_setup_api
  2625                              <1> 
  2626 00000ABB B90050              <1> 		mov cx,comboot_seg
  2627 00000ABE 8EC1                <1> 		mov es,cx
  2628                              <1> 
  2629 00000AC0 31FF                <1> 		xor di,di
  2630 00000AC2 B94000              <1> 		mov cx,64		; 256 bytes (size of PSP)
  2631 00000AC5 6631C0              <1> 		xor eax,eax		; Clear PSP
  2632 00000AC8 F366AB              <1> 		rep stosd
  2633                              <1> 
  2634 00000ACB 26C7060000CD20      <1> 		mov word [es:0], 020CDh	; INT 20h instruction
  2635                              <1> 		; First non-free paragraph
  2636                              <1> 		; This is valid because comboot_seg == real_mode_seg
  2637                              <1> 		; == the highest segment used by all derivatives
  2638 00000AD2 CD12                <1> 		int 12h			; Get DOS memory size
  2639 00000AD4 C1E006              <1> 		shl ax,6		; Kilobytes -> paragraphs
  2640 00000AD7 26A30200            <1> 		mov word [es:02h],ax
  2641                              <1> 
  2642                              <1> %ifndef DEPEND
  2643                              <1> %if real_mode_seg != comboot_seg
  2644                              <1> %error "This code assumes real_mode_seg == comboot_seg"
  2645                              <1> %endif
  2646                              <1> %endif
  2647                              <1> 		; Copy the command line from high memory
  2648 00000ADB BE0090              <1> 		mov si,cmd_line_here
  2649 00000ADE B97D00              <1> 		mov cx,125		; Max cmdline len (minus space and CR)
  2650 00000AE1 BF8100              <1> 		mov di,081h		; Offset in PSP for command line
  2651 00000AE4 B020                <1> 		mov al,' '		; DOS command lines begin with a space
  2652 00000AE6 AA                  <1> 		stosb
  2653                              <1> 
  2654 00000AE7 26AC                <1> .loop:		es lodsb
  2655 00000AE9 20C0                <1> 		and al,al
  2656 00000AEB 7403                <1> 		jz .done
  2657 00000AED AA                  <1> 		stosb
  2658 00000AEE E2F7                <1> 		loop .loop
  2659                              <1> .done:
  2660                              <1> 
  2661 00000AF0 B00D                <1> 		mov al,0Dh		; CR after last character
  2662 00000AF2 AA                  <1> 		stosb
  2663 00000AF3 89F8                <1> 		mov ax,di
  2664 00000AF5 2C82                <1> 		sub al,82h		; Include space but not CR
  2665 00000AF7 26A28000            <1> 		mov [es:80h],al		; Store command line length
  2666                              <1> 
  2667                              <1> 		; Now actually load the file...
  2668 00000AFB 5E                  <1> 		pop si			; File handle
  2669 00000AFC BB0001              <1> 		mov bx,100h		; Load at <seg>:0100h
  2670 00000AFF 8B0E7457            <1> 		mov cx,[ClustPerMoby]	; Absolute maximum # of clusters
  2671 00000B03 E80FF8              <1> 		call getfssec
  2672                              <1> 
  2673                              <1> 		; And invoke the program...
  2674 00000B06 89266C57            <1> 		mov [SavedSSSP],sp
  2675 00000B0A 8C166E57            <1> 		mov [SavedSSSP+2],ss	; Save away SS:SP
  2676                              <1> 
  2677 00000B0E 8CC0                <1> 		mov ax,es
  2678 00000B10 8ED8                <1> 		mov ds,ax
  2679 00000B12 8ED0                <1> 		mov ss,ax
  2680 00000B14 31E4                <1> 		xor sp,sp
  2681 00000B16 6A00                <1> 		push word 0		; Return to address 0 -> exit
  2682                              <1> 
  2683 00000B18 EA00010050          <1> 		jmp comboot_seg:100h	; Run it
  2684                              <1> 
  2685                              <1> ; Proper return vector
  2686 00000B1D FA                  <1> comboot_return:	cli			; Don't trust anyone
  2687 00000B1E 31C0                <1> 		xor ax,ax
  2688 00000B20 EB54                <1> 		jmp comboot_exit
  2689                              <1> 
  2690                              <1> ;
  2691                              <1> ; Set up the COMBOOT API interrupt vectors.  This is also used
  2692                              <1> ; by the COM32 code.
  2693                              <1> ;
  2694                              <1> comboot_setup_api:
  2695 00000B22 BF8000              <1> 		mov di,4*0x20		; DOS interrupt vectors
  2696 00000B25 66B8[1D0B0000]      <1> 		mov eax,comboot_return	; INT 20h = exit
  2697 00000B2B 66AB                <1> 		stosd
  2698 00000B2D B8[410B]            <1> 		mov ax,comboot_int21	; INT 21h = DOS-compatible syscalls
  2699 00000B30 66AB                <1> 		stosd
  2700 00000B32 B8[280C]            <1> 		mov ax,comboot_int22	; INT 22h = proprietary syscalls
  2701 00000B35 66AB                <1> 		stosd
  2702 00000B37 B8[720B]            <1> 		mov ax,comboot_bogus
  2703 00000B3A B91D00              <1> 		mov cx,29		; All remaining DOS vectors
  2704 00000B3D F366AB              <1> 		rep stosd
  2705 00000B40 C3                  <1> 		ret
  2706                              <1> 
  2707                              <1> ; INT 21h: generic DOS system call
  2708 00000B41 FA                  <1> comboot_int21:	cli
  2709 00000B42 1E                  <1> 		push ds
  2710 00000B43 06                  <1> 		push es
  2711 00000B44 0FA0                <1> 		push fs
  2712 00000B46 0FA8                <1> 		push gs
  2713 00000B48 6660                <1> 		pushad
  2714 00000B4A FC                  <1> 		cld
  2715 00000B4B 8CCD                <1> 		mov bp,cs
  2716 00000B4D 8EDD                <1> 		mov ds,bp
  2717 00000B4F 8EC5                <1> 		mov es,bp
  2718 00000B51 89E5                <1> 		mov bp,sp			; Set up stack frame
  2719                              <1> 
  2720 00000B53 E8810F              <1> 		call adjust_screen		; The COMBOOT program might have changed the screen
  2721                              <1> 
  2722 00000B56 B90A00              <1> 		mov cx,int21_count
  2723 00000B59 BE[390D]            <1> 		mov si,int21_table
  2724 00000B5C AC                  <1> .again:		lodsb
  2725 00000B5D 3A461D              <1> 		cmp al,P_AH
  2726 00000B60 AD                  <1> 		lodsw
  2727 00000B61 E0F9                <1> 		loopne .again
  2728                              <1> 		; The last function in the list is the
  2729                              <1> 		; "no such function" function
  2730                              <1> 
  2731 00000B63 FFD0                <1> 		call ax			; Call the invoked function
  2732                              <1> comboot_resume:
  2733 00000B65 0F92462C            <1> 		setc P_FLAGSL		; Propagate CF->error
  2734 00000B69 6661                <1> 		popad
  2735 00000B6B 0FA9                <1> 		pop gs
  2736 00000B6D 0FA1                <1> 		pop fs
  2737 00000B6F 07                  <1> 		pop es
  2738 00000B70 1F                  <1> 		pop ds
  2739 00000B71 CF                  <1> 		iret
  2740                              <1> 
  2741                              <1> ; Attempted to execute non-21h DOS system call
  2742 00000B72 FA                  <1> comboot_bogus:	cli			; Don't trust anyone
  2743 00000B73 B8[1820]            <1> 		mov ax,err_notdos
  2744                              <1> ;
  2745                              <1> ; Generic COMBOOT return to command line code
  2746                              <1> ;  AX -> message (if any)
  2747                              <1> ;  BX -> where to go next
  2748                              <1> ;
  2749                              <1> comboot_exit:
  2750 00000B76 BB[5A04]            <1> 		mov bx,enter_command	; Normal return to command prompt
  2751                              <1> comboot_exit_special:
  2752 00000B79 31D2                <1> 		xor dx,dx
  2753 00000B7B 8EDA                <1> 		mov ds,dx
  2754 00000B7D 8EC2                <1> 		mov es,dx
  2755 00000B7F 0FB2266C57          <1> 		lss sp,[SavedSSSP]
  2756 00000B84 FB                  <1> 		sti
  2757 00000B85 FC                  <1> 		cld
  2758 00000B86 E84E0F              <1> 		call adjust_screen	; The COMBOOT program might have changed the screen
  2759 00000B89 21C0                <1> 		and ax,ax
  2760 00000B8B 740A                <1> 		je .nomsg
  2761 00000B8D BEE557              <1> 		mov si,KernelCName
  2762 00000B90 E8EE09              <1> 		call cwritestr
  2763 00000B93 96                  <1> 		xchg si,ax
  2764 00000B94 E8EA09              <1> 		call cwritestr
  2765 00000B97 FFE3                <1> .nomsg:		jmp bx
  2766                              <1> 
  2767                              <1> ;
  2768                              <1> ; INT 21h system calls
  2769                              <1> ;
  2770                              <1> comboot_getkey:				; 01 = get key with echo
  2771 00000B99 E80211              <1> 		call vgashowcursor
  2772 00000B9C E86600              <1> 		call comboot_getchar
  2773 00000B9F E80211              <1> 		call vgahidecursor
  2774 00000BA2 E82605              <1> 		call writechr
  2775 00000BA5 F8                  <1> 		clc
  2776 00000BA6 C3                  <1> 		ret
  2777                              <1> 
  2778                              <1> comboot_writechr:			; 02 = writechr
  2779 00000BA7 8A4614              <1> 		mov al,P_DL
  2780 00000BAA E81E05              <1> 		call writechr
  2781 00000BAD F8                  <1> 		clc
  2782 00000BAE C3                  <1> 		ret
  2783                              <1> 
  2784                              <1> comboot_writeserial:			; 04 = write serial port
  2785 00000BAF 8A4614              <1> 		mov al,P_DL
  2786 00000BB2 E82C09              <1> 		call write_serial
  2787 00000BB5 F8                  <1> 		clc
  2788 00000BB6 C3                  <1> 		ret
  2789                              <1> 
  2790                              <1> comboot_getkeynoecho:			; 08 = get key w/o echo
  2791 00000BB7 E84B00              <1> 		call comboot_getchar
  2792 00000BBA F8                  <1> 		clc
  2793 00000BBB C3                  <1> 		ret
  2794                              <1> 
  2795                              <1> comboot_writestr:			; 09 = write DOS string
  2796 00000BBC 8E4626              <1> 		mov es,P_DS
  2797 00000BBF 8B7614              <1> 		mov si,P_DX
  2798 00000BC2 26AC                <1> .loop:		es lodsb
  2799 00000BC4 3C24                <1> 		cmp al,'$'		; End string with $ - bizarre
  2800 00000BC6 7405                <1> 		je .done
  2801 00000BC8 E80005              <1> 		call writechr
  2802 00000BCB EBF5                <1> 		jmp short .loop
  2803 00000BCD F8                  <1> .done:		clc
  2804 00000BCE C3                  <1> 		ret
  2805                              <1> 
  2806                              <1> comboot_checkkey:			; 0B = check keyboard status
  2807 00000BCF 803E[750D]00        <1> 		cmp byte [APIKeyFlag],00h
  2808 00000BD4 7503                <1> 		jnz .waiting
  2809 00000BD6 E84609              <1> 		call pollchar
  2810 00000BD9 0F94C0              <1> .waiting:	setz al
  2811 00000BDC FEC8                <1> 		dec al			; AL = 0FFh if present, 0 if not
  2812 00000BDE 88461C              <1> 		mov P_AL,al
  2813 00000BE1 F8                  <1> 		clc
  2814 00000BE2 C3                  <1> 		ret
  2815                              <1> 
  2816                              <1> comboot_checkver:			; 30 = check DOS version
  2817                              <1> 		; We return 0 in all DOS-compatible version registers,
  2818                              <1> 		; but the high part of eax-ebx-ecx-edx spell "SYSLINUX"
  2819 00000BE3 66C7461C00005359    <1> 		mov P_EAX,'SY' << 16
  2820 00000BEB 66C746100000534C    <1> 		mov P_EBX,'SL' << 16
  2821 00000BF3 66C746180000494E    <1> 		mov P_ECX,'IN' << 16
  2822 00000BFB 66C7461400005558    <1> 		mov P_EDX,'UX' << 16
  2823 00000C03 F8                  <1> 		clc
  2824 00000C04 C3                  <1> 		ret
  2825                              <1> 
  2826                              <1> comboot_getchar:
  2827 00000C05 803E[750D]00        <1> 		cmp byte [APIKeyFlag],00h
  2828 00000C0A 7513                <1> 		jne .queued
  2829 00000C0C E83A09              <1> 		call getchar		; If not queued get input
  2830 00000C0F 20C0                <1> 		and al,al		; Function key?
  2831 00000C11 7508                <1> 		jnz .done
  2832 00000C13 8826[740D]          <1> 		mov [APIKeyWait],ah	; High part of key
  2833 00000C17 FE06[750D]          <1> 		inc byte [APIKeyFlag]	; Set flag
  2834 00000C1B 88461C              <1> .done:		mov P_AL,al
  2835 00000C1E C3                  <1> 		ret
  2836 00000C1F A0[740D]            <1> .queued:	mov al,[APIKeyWait]
  2837 00000C22 FE0E[750D]          <1> 		dec byte [APIKeyFlag]
  2838 00000C26 EBF3                <1> 		jmp .done
  2839                              <1> 
  2840                              <1> ;
  2841                              <1> ; INT 22h - SYSLINUX-specific system calls
  2842                              <1> ;           System call number in ax
  2843                              <1> ;
  2844                              <1> comboot_int22:
  2845 00000C28 FA                  <1> 		cli
  2846 00000C29 1E                  <1> 		push ds
  2847 00000C2A 06                  <1> 		push es
  2848 00000C2B 0FA0                <1> 		push fs
  2849 00000C2D 0FA8                <1> 		push gs
  2850 00000C2F 6660                <1> 		pushad
  2851 00000C31 FC                  <1> 		cld
  2852 00000C32 8CCD                <1> 		mov bp,cs
  2853 00000C34 8EDD                <1> 		mov ds,bp
  2854 00000C36 8EC5                <1> 		mov es,bp
  2855 00000C38 89E5                <1> 		mov bp,sp			; Set up stack frame
  2856                              <1> 
  2857 00000C3A E89A0E              <1> 		call adjust_screen		; The COMBOOT program might have changed the screen
  2858                              <1> 
  2859 00000C3D 83F80E              <1> 		cmp ax,int22_count
  2860 00000C40 7202                <1> 		jb .ok
  2861 00000C42 31C0                <1> 		xor ax,ax			; Function 0 -> unimplemented
  2862                              <1> .ok:
  2863 00000C44 93                  <1> 		xchg ax,bx
  2864 00000C45 01DB                <1> 		add bx,bx
  2865 00000C47 FF97[580D]          <1> 		call [bx+int22_table]
  2866 00000C4B E917FF              <1> 		jmp comboot_resume		; On return
  2867                              <1> 
  2868                              <1> ;
  2869                              <1> ; INT 22h AX=0000h	Unimplemented call
  2870                              <1> ;
  2871                              <1> comapi_err:
  2872 00000C4E F9                  <1> 		stc
  2873 00000C4F C3                  <1> 		ret
  2874                              <1> 
  2875                              <1> ;
  2876                              <1> ; INT 22h AX=0001h	Get SYSLINUX version
  2877                              <1> ;
  2878                              <1> comapi_get_version:
  2879                              <1> 		; Number of API functions supported
  2880 00000C50 C7461C0E00          <1> 		mov P_AX,int22_count
  2881                              <1> 		; SYSLINUX version
  2882 00000C55 C746180A02          <1> 		mov P_CX,(VER_MAJOR << 8)+VER_MINOR
  2883                              <1> 		; SYSLINUX derivative ID byte
  2884 00000C5A C746143100          <1> 		mov P_DX,my_id
  2885                              <1> 		; For future use
  2886 00000C5F 8C4E10              <1> 		mov P_BX,cs	; cs == 0
  2887                              <1> 
  2888 00000C62 8C5E24              <1> 		mov P_ES,ds
  2889                              <1> 		; ES:SI -> version banner
  2890 00000C65 C74604[0002]        <1> 		mov P_SI,syslinux_banner
  2891                              <1> 		; ES:DI -> copyright string
  2892 00000C6A C74600[DF1D]        <1> 		mov P_DI,copyright_str
  2893                              <1> 
  2894                              <1> comapi_nop:
  2895 00000C6F F8                  <1> 		clc
  2896 00000C70 C3                  <1> 		ret
  2897                              <1> 
  2898                              <1> ;
  2899                              <1> ; INT 22h AX=0002h	Write string
  2900                              <1> ;
  2901                              <1> ; Write null-terminated string in ES:BX
  2902                              <1> ;
  2903                              <1> comapi_writestr:
  2904 00000C71 8E5E24              <1> 		mov ds,P_ES
  2905 00000C74 8B7610              <1> 		mov si,P_BX
  2906 00000C77 E8F2F4              <1> 		call writestr
  2907 00000C7A F8                  <1> 		clc
  2908 00000C7B C3                  <1> 		ret
  2909                              <1> 
  2910                              <1> ;
  2911                              <1> ; INT 22h AX=0003h	Run command
  2912                              <1> ;
  2913                              <1> ; Terminates the COMBOOT program and executes the command line in
  2914                              <1> ; ES:BX as if it had been entered by the user.
  2915                              <1> ;
  2916                              <1> comapi_run:
  2917 00000C7C 8E5E24              <1> 		mov ds,P_ES
  2918 00000C7F 8B7610              <1> 		mov si,P_BX
  2919 00000C82 BF2858              <1> 		mov di,command_line
  2920                              <1> .copyloop:
  2921 00000C85 AC                  <1> 		lodsb
  2922 00000C86 AA                  <1> 		stosb
  2923 00000C87 20C0                <1> 		and al,al
  2924 00000C89 75FA                <1> 		jnz .copyloop
  2925 00000C8B 31C0                <1> 		xor ax,ax
  2926 00000C8D BB[8305]            <1> 		mov bx,load_kernel		; Run a new kernel
  2927 00000C90 E9E6FE              <1> 		jmp comboot_exit_special	; Terminate task, clean up
  2928                              <1> 
  2929                              <1> ;
  2930                              <1> ; INT 22h AX=0004h	Run default command		
  2931                              <1> ;
  2932                              <1> ; Terminates the COMBOOT program and executes the default command line
  2933                              <1> ; as if a timeout had happened or the user pressed <Enter>.
  2934                              <1> ;
  2935                              <1> comapi_run_default:
  2936 00000C93 BB[6905]            <1> 		mov bx,auto_boot
  2937 00000C96 E9E0FE              <1> 		jmp comboot_exit_special
  2938                              <1> 
  2939                              <1> ;
  2940                              <1> ; INT 22h AX=0005h	Force text mode
  2941                              <1> ;
  2942                              <1> ; Puts the video in standard text mode
  2943                              <1> ;
  2944                              <1> comapi_textmode:
  2945 00000C99 E8DA0F              <1> 		call vgaclearmode
  2946 00000C9C F8                  <1> 		clc
  2947 00000C9D C3                  <1> 		ret
  2948                              <1> 
  2949                              <1> ;
  2950                              <1> ; INT 22h AX=0006h	Open file
  2951                              <1> ;
  2952                              <1> comapi_open:
  2953 00000C9E 1E                  <1> 		push ds
  2954 00000C9F 8E5E24              <1> 		mov ds,P_ES
  2955 00000CA2 8B7604              <1> 		mov si,P_SI
  2956 00000CA5 BFDA57              <1> 		mov di,InitRD
  2957 00000CA8 57                  <1> 		push di
  2958 00000CA9 E84604              <1> 		call mangle_name
  2959 00000CAC 5F                  <1> 		pop di
  2960 00000CAD 1F                  <1> 		pop ds
  2961 00000CAE E8A003              <1> 		call searchdir
  2962 00000CB1 7411                <1> 		jz .err
  2963 00000CB3 89461C              <1> 		mov P_AX,ax
  2964 00000CB6 89561E              <1> 		mov P_HAX,dx
  2965 00000CB9 A17857              <1> 		mov ax,[ClustSize]
  2966 00000CBC 894618              <1> 		mov P_CX,ax
  2967 00000CBF 897604              <1> 		mov P_SI,si
  2968 00000CC2 F8                  <1> 		clc
  2969 00000CC3 C3                  <1> 		ret
  2970                              <1> .err:
  2971 00000CC4 F9                  <1> 		stc
  2972 00000CC5 C3                  <1> 		ret
  2973                              <1> 
  2974                              <1> 
  2975                              <1> ;
  2976                              <1> ; INT 22h AX=0007h	Read file
  2977                              <1> ;
  2978                              <1> comapi_read:
  2979 00000CC6 8E4624              <1> 		mov es,P_ES
  2980 00000CC9 8B5E10              <1> 		mov bx,P_BX
  2981 00000CCC 8B7604              <1> 		mov si,P_SI
  2982 00000CCF 8B4E18              <1> 		mov cx,P_CX
  2983 00000CD2 E840F6              <1> 		call getfssec
  2984 00000CD5 7302                <1> 		jnc .noteof
  2985 00000CD7 31F6                <1> 		xor si,si		; SI <- 0 on EOF, CF <- 0
  2986 00000CD9 897604              <1> .noteof:	mov P_SI,si
  2987 00000CDC C3                  <1> 		ret
  2988                              <1> 
  2989                              <1> ;
  2990                              <1> ; INT 22h AX=0008h	Close file
  2991                              <1> ;
  2992                              <1> comapi_close:
  2993                              <1> 		; Do nothing for now.  Eventually implement
  2994                              <1> 		; an internal API for this.
  2995 00000CDD F8                  <1> 		clc
  2996 00000CDE C3                  <1> 		ret
  2997                              <1> 
  2998                              <1> ;
  2999                              <1> ; INT 22h AX=0009h	Call PXE stack
  3000                              <1> ;
  3001                              <1> %if IS_PXELINUX
  3002                              <1> comapi_pxecall:
  3003                              <1> 		mov bx,P_BX
  3004                              <1> 		mov es,P_ES
  3005                              <1> 		mov di,P_DI
  3006                              <1> 		call pxenv
  3007                              <1> 		mov P_AX,ax
  3008                              <1> 		clc
  3009                              <1> 		ret
  3010                              <1> %else
  3011                              <1> comapi_pxecall	equ comapi_err			; Not available
  3012                              <1> %endif
  3013                              <1> 
  3014                              <1> ;
  3015                              <1> ; INT 22h AX=000Ah	Get Derivative-Specific Info
  3016                              <1> ;
  3017                              <1> comapi_derinfo:
  3018 00000CDF C6461C31            <1> 		mov P_AL,my_id
  3019                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  3020 00000CE3 A0[2400]            <1> 		mov al,[bsDriveNumber]
  3021 00000CE6 884614              <1> 		mov P_DL,al
  3022 00000CE9 8C4E24              <1> 		mov P_ES,cs
  3023 00000CEC C74610[B4FF]        <1> 		mov P_BX,PartInfo
  3024                              <1> %elif IS_PXELINUX
  3025                              <1> 		mov ax,[APIVer]
  3026                              <1> 		mov P_DX,ax
  3027                              <1> 		mov ax,[StrucPtr]
  3028                              <1> 		mov P_BX,ax
  3029                              <1> 		mov ax,[StrucPtr+2]
  3030                              <1> 		mov P_ES,ax
  3031                              <1> 		mov ax,[InitStack]
  3032                              <1> 		mov P_SI,ax
  3033                              <1> 		mov ax,[InitStack+2]
  3034                              <1> 		mov P_FS,ax
  3035                              <1> %elif IS_ISOLINUX
  3036                              <1> 		mov al,[DriveNo]
  3037                              <1> 		mov P_DL,al
  3038                              <1> 		mov P_ES,cs
  3039                              <1> 		mov P_BX,spec_packet
  3040                              <1> %endif
  3041 00000CF1 F8                  <1> 		clc
  3042 00000CF2 C3                  <1> 		ret
  3043                              <1> 
  3044                              <1> ;
  3045                              <1> ; INT 22h AX=000Bh	Get Serial Console Configuration
  3046                              <1> ;
  3047                              <1> comapi_serialcfg:
  3048 00000CF3 A1[F021]            <1> 		mov ax,[SerialPort]
  3049 00000CF6 894614              <1> 		mov P_DX,ax
  3050 00000CF9 A1C257              <1> 		mov ax,[BaudDivisor]
  3051 00000CFC 894618              <1> 		mov P_CX,ax
  3052 00000CFF A1C457              <1> 		mov ax,[FlowControl]
  3053 00000D02 08E0                <1> 		or al,ah
  3054 00000D04 8A26C657            <1> 		mov ah,[FlowIgnore]
  3055 00000D08 C0EC04              <1> 		shr ah,4
  3056 00000D0B 894610              <1> 		mov P_BX,ax
  3057 00000D0E F8                  <1> 		clc
  3058 00000D0F C3                  <1> 		ret
  3059                              <1> 
  3060                              <1> ;
  3061                              <1> ; INT 22h AX=000Ch	Perform final cleanup
  3062                              <1> ;
  3063                              <1> comapi_cleanup:
  3064                              <1> %if IS_PXELINUX
  3065                              <1> 		; Unload PXE if requested
  3066                              <1> 		test dl,3
  3067                              <1> 		setnz [KeepPXE]
  3068                              <1> 		sub bp,sp		; unload_pxe may move the stack around
  3069                              <1> 		call unload_pxe
  3070                              <1> 		add bp,sp		; restore frame pointer...
  3071                              <1> %elif IS_SYSLINUX || IS_MDSLINUX
  3072                              <1> 		; Restore original FDC table
  3073 00000D10 66A1[B0FF]          <1> 		mov eax,[OrigFDCTabPtr]
  3074 00000D14 66A37800            <1> 		mov [fdctab],eax
  3075                              <1> %endif
  3076                              <1> 		; Reset the floppy disk subsystem
  3077 00000D18 31C0                <1> 		xor ax,ax
  3078 00000D1A 31D2                <1> 		xor dx,dx
  3079 00000D1C CD13                <1> 		int 13h
  3080 00000D1E F8                  <1> 		clc
  3081 00000D1F C3                  <1> 		ret
  3082                              <1> 
  3083                              <1> 
  3084                              <1> ;
  3085                              <1> ; INT 22h AX=000Dh	Clean up then replace bootstrap
  3086                              <1> ;
  3087                              <1> comapi_chainboot:
  3088 00000D20 E8EDFF              <1> 		call comapi_cleanup
  3089 00000D23 668B7604            <1> 		mov esi,P_ESI
  3090 00000D27 668B5610            <1> 		mov edx,P_EBX
  3091 00000D2B 8B5E26              <1> 		mov bx,P_DS
  3092 00000D2E 66FF7600            <1> 		push P_EDI
  3093 00000D32 66FF7618            <1> 		push P_ECX
  3094 00000D36 E9B802              <1> 		jmp replace_bootstrap
  3095                              <1> 
  3096                              <1> ;
  3097                              <1> ; This stuff should really be in the data section...
  3098                              <1> ;
  3099                              <1> %macro 		int21 2
  3100                              <1> 		db %1
  3101                              <1> 		dw %2
  3102                              <1> %endmacro
  3103                              <1> 
  3104                              <1> int21_table:
  3105                              <1> 		int21	00h, comboot_return
  3106 00000D39 00                  <2>  db %1
  3107 00000D3A [1D0B]              <2>  dw %2
  3108                              <1> 		int21	01h, comboot_getkey
  3109 00000D3C 01                  <2>  db %1
  3110 00000D3D [990B]              <2>  dw %2
  3111                              <1> 		int21	02h, comboot_writechr
  3112 00000D3F 02                  <2>  db %1
  3113 00000D40 [A70B]              <2>  dw %2
  3114                              <1> 		int21	04h, comboot_writeserial
  3115 00000D42 04                  <2>  db %1
  3116 00000D43 [AF0B]              <2>  dw %2
  3117                              <1> 		int21	08h, comboot_getkeynoecho
  3118 00000D45 08                  <2>  db %1
  3119 00000D46 [B70B]              <2>  dw %2
  3120                              <1> 		int21	09h, comboot_writestr
  3121 00000D48 09                  <2>  db %1
  3122 00000D49 [BC0B]              <2>  dw %2
  3123                              <1> 		int21	0Bh, comboot_checkkey
  3124 00000D4B 0B                  <2>  db %1
  3125 00000D4C [CF0B]              <2>  dw %2
  3126                              <1> 		int21	30h, comboot_checkver
  3127 00000D4E 30                  <2>  db %1
  3128 00000D4F [E30B]              <2>  dw %2
  3129                              <1> 		int21	4Ch, comboot_return
  3130 00000D51 4C                  <2>  db %1
  3131 00000D52 [1D0B]              <2>  dw %2
  3132                              <1> 		int21	 -1, comboot_bogus
  3133 00000D54 FF                  <2>  db %1
  3134 00000D55 [720B]              <2>  dw %2
  3135                              <1> int21_count	equ ($-int21_table)/3
  3136                              <1> 
  3137 00000D57 00                  <1> 		align 2, db 0
  3138                              <1> int22_table:
  3139 00000D58 [4E0C]              <1> 		dw comapi_err			; 0000 unimplemented syscall
  3140 00000D5A [500C]              <1> 		dw comapi_get_version		; 0001 get SYSLINUX version
  3141 00000D5C [710C]              <1> 		dw comapi_writestr		; 0002 write string
  3142 00000D5E [7C0C]              <1> 		dw comapi_run			; 0003 run specified command
  3143 00000D60 [930C]              <1> 		dw comapi_run_default		; 0004 run default command
  3144 00000D62 [990C]              <1> 		dw comapi_textmode		; 0005 force text mode
  3145 00000D64 [9E0C]              <1> 		dw comapi_open			; 0006 open file
  3146 00000D66 [C60C]              <1> 		dw comapi_read			; 0007 read file
  3147 00000D68 [DD0C]              <1> 		dw comapi_close			; 0008 close file
  3148 00000D6A [4E0C]              <1> 		dw comapi_pxecall		; 0009 call PXE stack
  3149 00000D6C [DF0C]              <1> 		dw comapi_derinfo		; 000A derivative-specific info
  3150 00000D6E [F30C]              <1> 		dw comapi_serialcfg		; 000B get serial port config
  3151 00000D70 [100D]              <1> 		dw comapi_cleanup		; 000C perform final cleanup
  3152 00000D72 [200D]              <1> 		dw comapi_chainboot		; 000D clean up then bootstrap
  3153                              <1> int22_count	equ ($-int22_table)/2
  3154                              <1> 
  3155 00000D74 00                  <1> APIKeyWait	db 0
  3156 00000D75 00                  <1> APIKeyFlag	db 0
  3157                                  %include "com32.inc"
  3158                              <1> ;; $Id: com32.inc,v 1.5 2003/11/24 02:44:42 hpa Exp $
  3159                              <1> ;; -----------------------------------------------------------------------
  3160                              <1> ;;   
  3161                              <1> ;;   Copyright 1994-2003 H. Peter Anvin - All Rights Reserved
  3162                              <1> ;;
  3163                              <1> ;;   This program is free software; you can redistribute it and/or modify
  3164                              <1> ;;   it under the terms of the GNU General Public License as published by
  3165                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  3166                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  3167                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  3168                              <1> ;;
  3169                              <1> ;; -----------------------------------------------------------------------
  3170                              <1> 
  3171                              <1> ;;
  3172                              <1> ;; com32.inc
  3173                              <1> ;;
  3174                              <1> ;; Common code for running a COM32 image
  3175                              <1> ;;
  3176                              <1> 
  3177                              <1> ;
  3178                              <1> ; Load a COM32 image.  A COM32 image is the 32-bit analogue to a DOS
  3179                              <1> ; .com file.  A COM32 image is loaded at address 0x101000, with %esp
  3180                              <1> ; set to the high end of usable memory.
  3181                              <1> ;
  3182                              <1> ; A COM32 image should begin with the magic bytes:
  3183                              <1> ; B8 FF 4C CD 21, which is "mov eax,0x21cd4cff" in 32-bit mode and
  3184                              <1> ; "mov ax,0x4cff; int 0x21" in 16-bit mode.  This will abort the
  3185                              <1> ; program with an error if run in 16-bit mode.
  3186                              <1> ;
  3187                              <1> pm_idt:		equ 0x100000
  3188                              <1> pm_entry:	equ 0x101000
  3189                              <1> 
  3190                              <1> 		bits 16
  3191                              <1> 		align 2
  3192                              <1> com32_pmidt:
  3193 00000D76 0008                <1> 		dw 8*256		; Limit
  3194 00000D78 00001000            <1> 		dd pm_idt		; Address
  3195                              <1> 
  3196                              <1> com32_rmidt:
  3197 00000D7C FFFF                <1> 		dw 0ffffh		; Limit
  3198 00000D7E 00000000            <1> 		dd 0			; Address
  3199                              <1> 
  3200                              <1> is_com32_image:
  3201 00000D82 56                  <1> 		push si			; Save file handle
  3202                              <1> 
  3203 00000D83 E8ED01              <1> 		call make_plain_cmdline
  3204                              <1> 		; Copy the command line into the low cmdline buffer
  3205 00000D86 B80050              <1> 		mov ax,real_mode_seg
  3206 00000D89 8EE0                <1> 		mov fs,ax
  3207 00000D8B BE0090              <1> 		mov si,cmd_line_here
  3208 00000D8E BF2858              <1> 		mov di,command_line
  3209 00000D91 8B0E[E421]          <1> 		mov cx,[CmdLinePtr]
  3210 00000D95 41                  <1> 		inc cx			; Include final null
  3211 00000D96 29F1                <1> 		sub cx,si
  3212 00000D98 64F3A4              <1> 		fs rep movsb
  3213                              <1> 
  3214 00000D9B E8300F              <1> 		call highmemsize	; We need the high memory size...
  3215 00000D9E E881FD              <1> 		call comboot_setup_api	; Set up the COMBOOT-style API
  3216                              <1> 
  3217 00000DA1 66BF00101000        <1> 		mov edi,pm_entry	; Load address
  3218 00000DA7 6692                <1> 		xchg eax,edx		; Gotta fix this insanity...
  3219 00000DA9 66C1E010            <1> 		shl eax,16
  3220 00000DAD 89D0                <1> 		mov ax,dx
  3221 00000DAF 5E                  <1> 		pop si			; File handle
  3222 00000DB0 E8320C              <1> 		call load_high
  3223 00000DB3 E8C807              <1> 		call crlf
  3224                              <1> 
  3225                              <1> com32_start:
  3226 00000DB6 66BB[FF0D0000]      <1> 		mov ebx,com32_call_start	; Where to go in PM
  3227                              <1> 
  3228                              <1> com32_enter_pm:
  3229 00000DBC FA                  <1> 		cli
  3230 00000DBD 8CC8                <1> 		mov ax,cs
  3231 00000DBF 8ED8                <1> 		mov ds,ax
  3232 00000DC1 89266C57            <1> 		mov [SavedSSSP],sp
  3233 00000DC5 8C166E57            <1> 		mov [SavedSSSP+2],ss
  3234 00000DC9 FC                  <1> 		cld
  3235 00000DCA E8380B              <1> 		call a20_test
  3236 00000DCD 7503                <1> 		jnz .a20ok
  3237 00000DCF E8B20A              <1> 		call enable_a20
  3238                              <1> 
  3239                              <1> .a20ok:
  3240 00000DD2 0F0116[C817]        <1> 		lgdt [bcopy_gdt]	; We can use the same GDT just fine
  3241 00000DD7 0F011E[760D]        <1> 		lidt [com32_pmidt]	; Set up the IDT
  3242 00000DDC 0F20C0              <1> 		mov eax,cr0
  3243 00000DDF 0C01                <1> 		or al,1
  3244 00000DE1 0F22C0              <1> 		mov cr0,eax		; Enter protected mode
  3245 00000DE4 EA[E90D]2000        <1> 		jmp 20h:.in_pm
  3246                              <1> 		
  3247                              <1> 		bits 32
  3248                              <1> .in_pm:
  3249 00000DE9 31C0                <1> 		xor eax,eax		; Available for future use...
  3250 00000DEB 8EE0                <1> 		mov fs,eax
  3251 00000DED 8EE8                <1> 		mov gs,eax
  3252                              <1> 
  3253 00000DEF B028                <1> 		mov al,28h		; Set up data segments
  3254 00000DF1 8EC0                <1> 		mov es,eax
  3255 00000DF3 8ED8                <1> 		mov ds,eax
  3256 00000DF5 8ED0                <1> 		mov ss,eax
  3257                              <1> 
  3258 00000DF7 8B2570570000        <1> 		mov esp,[PMESP]		; Load protmode %esp if available
  3259 00000DFD FFE3                <1> 		jmp ebx			; Go to where we need to go
  3260                              <1> 
  3261                              <1> ;
  3262                              <1> ; This is invoked right before the actually starting the COM32
  3263                              <1> ; progam, in 32-bit mode...
  3264                              <1> ;
  3265                              <1> com32_call_start:
  3266                              <1> 		;
  3267                              <1> 		; Point the stack to the end of high memory
  3268                              <1> 		;
  3269 00000DFF 678B266057          <1> 		mov esp,[word HighMemSize]
  3270                              <1> 
  3271                              <1> 		;
  3272                              <1> 		; Set up the protmode IDT and the interrupt jump buffers
  3273                              <1> 		; We set these up in the system area at 0x100000,
  3274                              <1> 		; but we could also put them beyond the stack.
  3275                              <1> 		;
  3276 00000E04 BF00001000          <1> 		mov edi,pm_idt
  3277                              <1> 
  3278                              <1> 		; Form an interrupt gate descriptor
  3279 00000E09 B800082000          <1> 		mov eax,0x00200000+((pm_idt+8*256)&0x0000ffff)
  3280 00000E0E BB00EE1000          <1> 		mov ebx,0x0000ee00+((pm_idt+8*256)&0xffff0000)
  3281 00000E13 31C9                <1> 		xor ecx,ecx
  3282 00000E15 FEC5                <1> 		inc ch				; ecx <- 256
  3283                              <1> 
  3284 00000E17 51                  <1> 		push ecx
  3285                              <1> .make_idt:
  3286 00000E18 AB                  <1> 		stosd
  3287 00000E19 83C008              <1> 		add eax,8
  3288 00000E1C 93                  <1> 		xchg eax,ebx
  3289 00000E1D AB                  <1> 		stosd
  3290 00000E1E 93                  <1> 		xchg eax,ebx
  3291 00000E1F E2F7                <1> 		loop .make_idt
  3292                              <1> 
  3293 00000E21 59                  <1> 		pop ecx
  3294                              <1> 
  3295                              <1> 		; Each entry in the interrupt jump buffer contains
  3296                              <1> 		; the following instructions:
  3297                              <1> 		;
  3298                              <1> 		; 00000000 60                pushad
  3299                              <1> 		; 00000001 B0xx              mov al,<interrupt#>
  3300                              <1> 		; 00000003 E9xxxxxxxx        jmp com32_handle_interrupt
  3301                              <1> 
  3302 00000E22 B860B000E9          <1> 		mov eax,0e900b060h
  3303 00000E27 BB[D606F0FF]        <1> 		mov ebx,com32_handle_interrupt-(pm_idt+8*256+8)
  3304                              <1> 
  3305                              <1> .make_ijb:
  3306 00000E2C AB                  <1> 		stosd
  3307 00000E2D 284FFE              <1> 		sub [edi-2],cl			; Interrupt #
  3308 00000E30 93                  <1> 		xchg eax,ebx
  3309 00000E31 AB                  <1> 		stosd
  3310 00000E32 83E808              <1> 		sub eax,8
  3311 00000E35 93                  <1> 		xchg eax,ebx
  3312 00000E36 E2F4                <1> 		loop .make_ijb
  3313                              <1> 
  3314                              <1> 		; Now everything is set up for interrupts...
  3315                              <1> 
  3316 00000E38 68[F10E0000]        <1> 		push dword com32_farcall	; Farcall entry point
  3317 00000E3D 6800000100          <1> 		push dword (1 << 16)		; 64K bounce buffer
  3318 00000E42 6800000500          <1> 		push dword (comboot_seg << 4)	; Bounce buffer address
  3319 00000E47 68[F90E0000]        <1> 		push dword com32_intcall	; Intcall entry point
  3320 00000E4C 6828580000          <1> 		push dword command_line		; Command line pointer
  3321 00000E51 6A05                <1> 		push dword 5			; Argument count
  3322 00000E53 FB                  <1> 		sti				; Interrupts OK now
  3323 00000E54 E8(00101000)        <1> 		call pm_entry			; Run the program...
  3324                              <1> 		; ... on return, fall through to com32_exit ...
  3325                              <1> 
  3326                              <1> com32_exit:
  3327 00000E59 66BB[9E0E]          <1> 		mov bx,com32_done	; Return to command loop
  3328                              <1> 
  3329                              <1> com32_enter_rm:
  3330 00000E5D FA                  <1> 		cli
  3331 00000E5E FC                  <1> 		cld
  3332 00000E5F 892570570000        <1> 		mov [PMESP],esp		; Save exit %esp
  3333 00000E65 31E4                <1> 		xor esp,esp		; Make sure the high bits are zero
  3334 00000E67 EA[6E0E0000]0800    <1> 		jmp 08h:.in_pm16	; Return to 16-bit mode first
  3335                              <1> 
  3336                              <1> 		bits 16
  3337                              <1> .in_pm16:
  3338 00000E6E B81800              <1> 		mov ax,18h		; Real-mode-like segment
  3339 00000E71 8EC0                <1> 		mov es,ax
  3340 00000E73 8ED8                <1> 		mov ds,ax
  3341 00000E75 8ED0                <1> 		mov ss,ax
  3342 00000E77 8EE0                <1> 		mov fs,ax
  3343 00000E79 8EE8                <1> 		mov gs,ax
  3344                              <1> 
  3345 00000E7B 0F011E[7C0D]        <1> 		lidt [com32_rmidt]	; Real-mode IDT (rm needs no GDT)
  3346 00000E80 0F20C0              <1> 		mov eax,cr0
  3347 00000E83 24FE                <1> 		and al,~1
  3348 00000E85 0F22C0              <1> 		mov cr0,eax
  3349 00000E88 EA[8D0E]0000        <1> 		jmp 0:.in_rm
  3350                              <1> 
  3351                              <1> .in_rm:					; Back in real mode
  3352 00000E8D 8CC8                <1> 		mov ax,cs		; Set up sane segments
  3353 00000E8F 8ED8                <1> 		mov ds,ax
  3354 00000E91 8EC0                <1> 		mov es,ax
  3355 00000E93 8EE0                <1> 		mov fs,ax
  3356 00000E95 8EE8                <1> 		mov gs,ax
  3357 00000E97 0FB2266C57          <1> 		lss sp,[SavedSSSP]	; Restore stack
  3358 00000E9C FFE3                <1> 		jmp bx			; Go to whereever we need to go...
  3359                              <1> 
  3360                              <1> com32_done:
  3361 00000E9E E8860A              <1> 		call disable_a20
  3362 00000EA1 FB                  <1> 		sti
  3363 00000EA2 E9B5F5              <1> 		jmp enter_command
  3364                              <1> 
  3365                              <1> ;
  3366                              <1> ; 16-bit support code
  3367                              <1> ;
  3368                              <1> 		bits 16
  3369                              <1> 
  3370                              <1> ;
  3371                              <1> ; 16-bit interrupt-handling code
  3372                              <1> ;
  3373                              <1> com32_int_rm:
  3374 00000EA5 9C                  <1> 		pushf				; Flags on stack
  3375 00000EA6 0E                  <1> 		push cs				; Return segment
  3376 00000EA7 68[AD0E]            <1> 		push word .cont			; Return address
  3377 00000EAA 6652                <1> 		push dword edx			; Segment:offset of IVT entry
  3378 00000EAC CB                  <1> 		retf				; Invoke IVT routine
  3379                              <1> .cont:		; ... on resume ...
  3380 00000EAD 66BB[EF0E0000]      <1> 		mov ebx,com32_int_resume
  3381 00000EB3 E906FF              <1> 		jmp com32_enter_pm		; Go back to PM
  3382                              <1> 
  3383                              <1> ;
  3384                              <1> ; 16-bit system call handling code
  3385                              <1> ;
  3386                              <1> com32_sys_rm:
  3387 00000EB6 0FA9                <1> 		pop gs
  3388 00000EB8 0FA1                <1> 		pop fs
  3389 00000EBA 07                  <1> 		pop es
  3390 00000EBB 1F                  <1> 		pop ds
  3391 00000EBC 6661                <1> 		popad
  3392 00000EBE 669D                <1> 		popfd
  3393 00000EC0 2E8926BC57          <1> 		mov [cs:Com32SysSP],sp
  3394 00000EC5 CB                  <1> 		retf				; Invoke routine
  3395                              <1> .return:
  3396                              <1> 		; We clean up SP here because we don't know if the
  3397                              <1> 		; routine returned with RET, RETF or IRET
  3398 00000EC6 2E8B26BC57          <1> 		mov sp,[cs:Com32SysSP]
  3399 00000ECB 669C                <1> 		pushfd
  3400 00000ECD 6660                <1> 		pushad
  3401 00000ECF 1E                  <1> 		push ds
  3402 00000ED0 06                  <1> 		push es
  3403 00000ED1 0FA0                <1> 		push fs
  3404 00000ED3 0FA8                <1> 		push gs
  3405 00000ED5 66BB[490F0000]      <1> 		mov ebx,com32_sys_resume
  3406 00000EDB E9DEFE              <1> 		jmp com32_enter_pm
  3407                              <1> 
  3408                              <1> ;
  3409                              <1> ; 32-bit support code
  3410                              <1> ;
  3411                              <1> 		bits 32
  3412                              <1> 
  3413                              <1> ;
  3414                              <1> ; This is invoked on getting an interrupt in protected mode.  At
  3415                              <1> ; this point, we need to context-switch to real mode and invoke
  3416                              <1> ; the interrupt routine.
  3417                              <1> ;
  3418                              <1> ; When this gets invoked, the registers are saved on the stack and
  3419                              <1> ; AL contains the register number.
  3420                              <1> ;
  3421                              <1> com32_handle_interrupt:
  3422 00000EDE 0FB6C0              <1> 		movzx eax,al
  3423 00000EE1 31DB                <1> 		xor ebx,ebx		; Actually makes the code smaller
  3424 00000EE3 8B1483              <1> 		mov edx,[ebx+eax*4]	; Get the segment:offset of the routine
  3425 00000EE6 66BB[A50E]          <1> 		mov bx,com32_int_rm
  3426 00000EEA E96EFFFFFF          <1> 		jmp com32_enter_rm	; Go to real mode
  3427                              <1> 
  3428                              <1> com32_int_resume:
  3429 00000EEF 61                  <1> 		popad
  3430 00000EF0 CF                  <1> 		iret
  3431                              <1> 
  3432                              <1> ;
  3433                              <1> ; Intcall/farcall invocation.  We manifest a structure on the real-mode stack,
  3434                              <1> ; containing the com32sys_t structure from <com32.h> as well as
  3435                              <1> ; the following entries (from low to high address):
  3436                              <1> ; - Target offset
  3437                              <1> ; - Target segment
  3438                              <1> ; - Return offset
  3439                              <1> ; - Return segment (== real mode cs == 0)
  3440                              <1> ; - Return flags
  3441                              <1> ;
  3442                              <1> com32_farcall:
  3443 00000EF1 9C                  <1> 		pushfd				; Save IF among other things...
  3444 00000EF2 60                  <1> 		pushad				; We only need to save some, but...
  3445                              <1> 
  3446 00000EF3 8B442428            <1> 		mov eax,[esp+10*4]		; CS:IP
  3447 00000EF7 EB0E                <1> 		jmp com32_syscall
  3448                              <1> 
  3449                              <1> 
  3450                              <1> com32_intcall:
  3451 00000EF9 9C                  <1> 		pushfd				; Save IF among other things...
  3452 00000EFA 60                  <1> 		pushad				; We only need to save some, but...
  3453                              <1> 
  3454 00000EFB 0FB6442428          <1> 		movzx eax,byte [esp+10*4]	; INT number
  3455 00000F00 8B048500000000      <1> 		mov eax,[eax*4]			; Get CS:IP from low memory
  3456                              <1> 
  3457                              <1> com32_syscall:
  3458 00000F07 FC                  <1> 		cld
  3459                              <1> 
  3460 00000F08 670FB73E6C57        <1> 		movzx edi,word [word SavedSSSP]
  3461 00000F0E 670FB71E6E57        <1> 		movzx ebx,word [word SavedSSSP+2]
  3462 00000F14 83EF36              <1> 		sub edi,54		; Allocate 54 bytes
  3463 00000F17 6667893E6C57        <1> 		mov [word SavedSSSP],di
  3464 00000F1D C1E304              <1> 		shl ebx,4
  3465 00000F20 01DF                <1> 		add edi,ebx		; Create linear address
  3466                              <1> 
  3467 00000F22 8B74242C            <1> 		mov esi,[esp+11*4]	; Source regs
  3468 00000F26 31C9                <1> 		xor ecx,ecx
  3469 00000F28 B10B                <1> 		mov cl,11		; 44 bytes to copy
  3470 00000F2A F3A5                <1> 		rep movsd
  3471                              <1> 
  3472                              <1> 		; EAX is already set up to be CS:IP
  3473 00000F2C AB                  <1> 		stosd			; Save in stack frame
  3474 00000F2D B8[C60E0000]        <1> 		mov eax,com32_sys_rm.return	; Return seg:offs
  3475 00000F32 AB                  <1> 		stosd			; Save in stack frame
  3476 00000F33 8B47F4              <1> 		mov eax,[edi-12]	; Return flags
  3477 00000F36 25D70C2000          <1> 		and eax,0x200cd7	; Mask (potentially) unsafe flags
  3478 00000F3B 8947F4              <1> 		mov [edi-12],eax	; Primary flags entry
  3479 00000F3E 66AB                <1> 		stosw			; Return flags
  3480                              <1> 
  3481 00000F40 66BB[B60E]          <1> 		mov bx,com32_sys_rm
  3482 00000F44 E914FFFFFF          <1> 		jmp com32_enter_rm	; Go to real mode
  3483                              <1> 
  3484                              <1> 		; On return, the 44-byte return structure is on the
  3485                              <1> 		; real-mode stack, plus the 10 additional bytes used
  3486                              <1> 		; by the target address (see above.)
  3487                              <1> com32_sys_resume:
  3488 00000F49 670FB7366C57        <1> 		movzx esi,word [word SavedSSSP]
  3489 00000F4F 670FB7066E57        <1> 		movzx eax,word [word SavedSSSP+2]
  3490 00000F55 8B7C2430            <1> 		mov edi,[esp+12*4]	; Dest regs
  3491 00000F59 C1E004              <1> 		shl eax,4
  3492 00000F5C 01C6                <1> 		add esi,eax		; Create linear address
  3493 00000F5E 21FF                <1> 		and edi,edi		; NULL pointer?
  3494 00000F60 7502                <1> 		jnz .do_copy
  3495 00000F62 89F7                <1> .no_copy:	mov edi,esi		; Do a dummy copy-to-self
  3496 00000F64 31C9                <1> .do_copy:	xor ecx,ecx
  3497 00000F66 B10B                <1> 		mov cl,11		; 44 bytes
  3498 00000F68 F3A5                <1> 		rep movsd		; Copy register block
  3499                              <1> 
  3500 00000F6A 6783066C5736        <1> 		add dword [word SavedSSSP],54	; Remove from stack
  3501                              <1> 
  3502 00000F70 61                  <1> 		popad
  3503 00000F71 9D                  <1> 		popfd
  3504 00000F72 C3                  <1> 		ret			; Return to 32-bit program
  3505                              <1> 
  3506                              <1> 		bits 16
  3507                                  %include "cmdline.inc"
  3508                              <1> ;; $Id: cmdline.inc,v 1.1 2003/11/24 02:44:42 hpa Exp $
  3509                              <1> ;; -----------------------------------------------------------------------
  3510                              <1> ;;   
  3511                              <1> ;;   Copyright 2003 H. Peter Anvin - All Rights Reserved
  3512                              <1> ;;
  3513                              <1> ;;   This program is free software; you can redistribute it and/or modify
  3514                              <1> ;;   it under the terms of the GNU General Public License as published by
  3515                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  3516                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  3517                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  3518                              <1> ;;
  3519                              <1> ;; -----------------------------------------------------------------------
  3520                              <1> 
  3521                              <1> ;;
  3522                              <1> ;; cmdline.inc
  3523                              <1> ;;
  3524                              <1> ;; Common routine to assemble [null-terminated] command line into
  3525                              <1> ;; real_mode_seg:cmd_line_here.
  3526                              <1> ;; Not used by plain kernel due to BOOT_IMAGE= etc.
  3527                              <1> ;;
  3528                              <1> 
  3529                              <1> ;
  3530                              <1> ; Assumes DS == CS
  3531                              <1> make_plain_cmdline:
  3532 00000F73 06                  <1> 		push es
  3533                              <1> 		; ui.inc has already copied the actual command line
  3534 00000F74 B80050              <1> 		mov ax,real_mode_seg
  3535 00000F77 8EC0                <1> 		mov es,ax
  3536                              <1> 
  3537 00000F79 8B36A457            <1> 		mov si,[CmdOptPtr]
  3538 00000F7D 8B3E[E421]          <1> 		mov di,[CmdLinePtr]
  3539                              <1> 		
  3540 00000F81 AC                  <1> .loop:		lodsb
  3541 00000F82 AA                  <1> 		stosb
  3542 00000F83 20C0                <1> 		and al,al
  3543 00000F85 75FA                <1> 		jnz .loop
  3544                              <1> 
  3545 00000F87 4F                  <1> 		dec di
  3546 00000F88 893E[E421]          <1> 		mov [CmdLinePtr],di
  3547                              <1> 
  3548 00000F8C 07                  <1> 		pop es
  3549 00000F8D C3                  <1> 		ret
  3550                              <1> 
  3551                              <1> 
  3552                                  
  3553                                  ;
  3554                                  ; Boot sector loading code
  3555                                  ;
  3556                                  %include "bootsect.inc"
  3557                              <1> ;; $Id: bootsect.inc,v 1.11 2003/11/26 05:42:33 hpa Exp $
  3558                              <1> ;; -----------------------------------------------------------------------
  3559                              <1> ;;   
  3560                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  3561                              <1> ;;
  3562                              <1> ;;   This program is free software; you can redistribute it and/or modify
  3563                              <1> ;;   it under the terms of the GNU General Public License as published by
  3564                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  3565                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  3566                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  3567                              <1> ;;
  3568                              <1> ;; -----------------------------------------------------------------------
  3569                              <1> 
  3570                              <1> ;;
  3571                              <1> ;; bootsect.inc
  3572                              <1> ;; 
  3573                              <1> ;; Load a boot sector (or other bootstrap program.)
  3574                              <1> ;;
  3575                              <1> ;; Unlike previous versions of this software, this doesn't require that
  3576                              <1> ;; the length is 512 bytes.  This allows PXE bootstraps and WinNT
  3577                              <1> ;; "CD boot sectors" to be invoked.
  3578                              <1> ;;
  3579                              <1> 
  3580                              <1> ;
  3581                              <1> ; Load a boot sector
  3582                              <1> ;
  3583                              <1> is_bootsector:
  3584                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  3585                              <1> 		; Transfer zero bytes
  3586 00000F8E C606CE5700          <1> 		mov byte [CopySuper],0
  3587 00000F93 EB05                <1> 		jmp short load_bootsec
  3588                              <1> 
  3589                              <1> is_bss_sector:
  3590                              <1> 		; Transfer the superblock
  3591 00000F95 C606CE5733          <1> 		mov byte [CopySuper],superblock_len
  3592                              <1> %endif
  3593                              <1> load_bootsec:
  3594 00000F9A 92                  <1> 		xchg dx,ax
  3595 00000F9B 66C1E010            <1> 		shl eax,16
  3596 00000F9F 92                  <1> 		xchg dx,ax		; Now EAX = file length
  3597 00000FA0 66BF00001000        <1> 		mov edi, 100000h
  3598 00000FA6 6657                <1> 		push edi		; Save load address
  3599 00000FA8 E83A0A              <1> 		call load_high
  3600 00000FAB E8D005              <1> 		call crlf
  3601                              <1> 
  3602 00000FAE 6681EF00001000      <1> 		sub edi,100000h
  3603 00000FB5 6657                <1> 		push edi		; Save length
  3604                              <1> 
  3605                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  3606 00000FB7 660FB60ECE57        <1> 		movzx ecx,byte [CopySuper]
  3607 00000FBD E30F                <1> 		jcxz .not_bss
  3608                              <1> 
  3609                              <1> 		; For a BSS boot sector we have to patch.
  3610 00000FBF 66BE[0B000000]      <1> 		mov esi,superblock
  3611 00000FC5 66BF0B001000        <1> 		mov edi,100000h+(superblock-bootsec)
  3612 00000FCB E82A08              <1> 		call bcopy
  3613                              <1> 
  3614                              <1> .not_bss:
  3615                              <1> %endif
  3616                              <1> 
  3617 00000FCE 6631D2              <1> 		xor edx,edx
  3618 00000FD1 6631F6              <1> 		xor esi,esi
  3619                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  3620                              <1> 		; Restore original FDC table
  3621 00000FD4 66A1[B0FF]          <1> 		mov eax,[OrigFDCTabPtr]
  3622 00000FD8 66A37800            <1> 		mov [fdctab],eax
  3623                              <1> 
  3624 00000FDC 8A16[2400]          <1> 		mov dl,[bsDriveNumber]
  3625 00000FE0 BE[B4FF]            <1> 		mov si,PartInfo		; Partition info buffer
  3626 00000FE3 BFEE07              <1> 		mov di,800h-18		; Put partition info here
  3627 00000FE6 57                  <1> 		push di
  3628 00000FE7 B90800              <1> 		mov cx,8		; 16 bytes
  3629 00000FEA 31C0                <1> 		xor ax,ax
  3630 00000FEC F3A5                <1> 		rep movsw
  3631 00000FEE 5E                  <1> 		pop si			; DS:SI points to partition info
  3632                              <1> %elif IS_ISOLINUX
  3633                              <1> 		mov dl,[DriveNo]
  3634                              <1> %elif IS_PXELINUX
  3635                              <1> 		mov byte [KeepPXE],1	; Chainloading another NBP
  3636                              <1> 		call reset_pxe
  3637                              <1> %endif
  3638 00000FEF 31DB                <1> 		xor bx,bx
  3639                              <1> 
  3640                              <1> ; 
  3641                              <1> ; Entrypoint for "shut down and replace bootstrap" -- also invoked by
  3642                              <1> ; the COMBOOT API.  This routine expects two dword on the stack:
  3643                              <1> ; linear address and length.  Additionally, the values of ESI and EDX
  3644                              <1> ; are passed on to the new bootstrap; the value of BX becomes the new
  3645                              <1> ; DS.
  3646                              <1> ; 
  3647                              <1> replace_bootstrap:
  3648                              <1> 
  3649                              <1> 		;
  3650                              <1> 		; Prepare for shutting down
  3651                              <1> 		;
  3652 00000FF1 E8820C              <1> 		call vgaclearmode
  3653                              <1> 
  3654                              <1> 		;
  3655                              <1> 		; Set up initial stack frame (not used by PXE if keeppxe is set)
  3656                              <1> 		;
  3657 00000FF4 31C0                <1> 		xor ax,ax
  3658 00000FF6 8ED8                <1> 		mov ds,ax
  3659 00000FF8 8EC0                <1> 		mov es,ax		
  3660                              <1> 
  3661                              <1> %if IS_PXELINUX
  3662                              <1> 		test byte [KeepPXE],01h
  3663                              <1> 		jz .stdstack
  3664                              <1> 		les di,[InitStack]	; Reset stack to PXE original
  3665                              <1> 		jmp .stackok
  3666                              <1> %endif
  3667                              <1> .stdstack:
  3668 00000FFA BFD47B              <1> 		mov di,7C00h-44
  3669 00000FFD 57                  <1> 		push di
  3670 00000FFE B91600              <1> 		mov cx,22		; 44 bytes
  3671 00001001 F3AB                <1> 		rep stosw
  3672 00001003 5F                  <1> 		pop di
  3673                              <1> .stackok:
  3674                              <1> 
  3675 00001004 266689551C          <1> 		mov [es:di+28],edx
  3676 00001009 266689750C          <1> 		mov [es:di+12],esi
  3677 0000100E 26895D06            <1> 		mov [es:di+6],bx
  3678                              <1> 
  3679 00001012 6659                <1> 		pop ecx			; Byte count to copy
  3680 00001014 665E                <1> 		pop esi			; Copy from...
  3681                              <1> 
  3682 00001016 FA                  <1> 		cli
  3683 00001017 8CC0                <1> 		mov ax,es
  3684 00001019 8ED0                <1> 		mov ss,ax
  3685 0000101B 660FB7E7            <1> 		movzx esp,di
  3686 0000101F 66BF007C0000        <1> 		mov edi,7C00h		; Copy to...
  3687                              <1> 
  3688 00001025 E96E09              <1> 		jmp bcopy_over_self
  3689                              <1> 
  3690                              <1> %if IS_SYSLINUX || IS_MDSLINUX
  3691                              <1> 		; Nothing
  3692                              <1> %else
  3693                              <1> is_bss_sector:
  3694                              <1> 		mov si,err_bssimage
  3695                              <1> 		call cwritestr
  3696                              <1> 		jmp enter_command
  3697                              <1> %endif
  3698                                  
  3699                                  ;
  3700                                  ; abort_check: let the user abort with <ESC> or <Ctrl-C>
  3701                                  ;
  3702                                  abort_check:
  3703 00001028 E8F404                  		call pollchar
  3704 0000102B 7423                    		jz ac_ret1
  3705 0000102D 60                      		pusha
  3706 0000102E E81805                  		call getchar
  3707 00001031 3C1B                    		cmp al,27			; <ESC>
  3708 00001033 7404                    		je ac_kill
  3709 00001035 3C03                    		cmp al,3			; <Ctrl-C>
  3710 00001037 7516                    		jne ac_ret2
  3711 00001039 BE[C720]                ac_kill:	mov si,aborted_msg
  3712                                  
  3713                                  ;
  3714                                  ; abort_load: Called by various routines which wants to print a fatal
  3715                                  ;             error message and return to the command prompt.  Since this
  3716                                  ;             may happen at just about any stage of the boot process, assume
  3717                                  ;             our state is messed up, and just reset the segment registers
  3718                                  ;             and the stack forcibly.
  3719                                  ;
  3720                                  ;             SI    = offset (in _text) of error message to print
  3721                                  ;
  3722                                  abort_load:
  3723 0000103C 8CC8                                    mov ax,cs                       ; Restore CS = DS = ES
  3724 0000103E 8ED8                                    mov ds,ax
  3725 00001040 8EC0                                    mov es,ax
  3726 00001042 FA                                      cli
  3727 00001043 BC[AEFF]                                mov sp,StackBuf-2*3    		; Reset stack
  3728 00001046 8ED0                                    mov ss,ax                       ; Just in case...
  3729 00001048 FB                                      sti
  3730 00001049 E83505                                  call cwritestr                  ; Expects SI -> error msg
  3731 0000104C E90BF4                  al_ok:          jmp enter_command               ; Return to command prompt
  3732                                  ;
  3733                                  ; End of abort_check
  3734                                  ;
  3735 0000104F 61                      ac_ret2:	popa
  3736 00001050 C3                      ac_ret1:	ret
  3737                                  
  3738                                  ;
  3739                                  ; searchdir: Search the root directory for a pre-mangled filename in
  3740                                  ;	     DS:DI.  This routine is similar to the one in the boot
  3741                                  ;	     sector, but is a little less Draconian when it comes to
  3742                                  ;	     error handling, plus it reads the root directory in
  3743                                  ;	     larger chunks than a sector at a time (which is probably
  3744                                  ;	     a waste of coding effort, but I like to do things right).
  3745                                  ;
  3746                                  ;	     FIXME: usually we can load the entire root dir in memory,
  3747                                  ;	     and files are usually at the beginning anyway.  It probably
  3748                                  ;	     would be worthwhile to remember if we have the first chunk
  3749                                  ;	     in memory and skip the load if that (it would speed up online
  3750                                  ;	     help, mainly.)
  3751                                  ;
  3752                                  ;	     NOTE: This file considers finding a zero-length file an
  3753                                  ;	     error.  This is so we don't have to deal with that special
  3754                                  ;	     case elsewhere in the program (most loops have the test
  3755                                  ;	     at the end).
  3756                                  ;
  3757                                  ;	     If successful:
  3758                                  ;		ZF clear
  3759                                  ;		SI	= cluster # for the first cluster
  3760                                  ;		DX:AX	= file length in bytes
  3761                                  ;	     If unsuccessful
  3762                                  ;		ZF set
  3763                                  ;
  3764                                  
  3765                                  searchdir:
  3766 00001051 55                      		push bp
  3767 00001052 A1[1100]                		mov ax,[bsRootDirEnts]
  3768 00001055 A33A57                  		mov [DirScanCtr],ax
  3769 00001058 A13857                  		mov ax,[RootDirSize]
  3770 0000105B A39057                  		mov [DirBlocksLeft],ax
  3771 0000105E 66A13057                		mov eax,[RootDir]
  3772                                  scan_group:
  3773 00001062 660FB72E9057            		movzx ebp,word [DirBlocksLeft]
  3774 00001068 21ED                    		and bp,bp
  3775 0000106A 745D                    		jz dir_return
  3776 0000106C 3B2E9657                		cmp bp,[BufSafeSec]
  3777 00001070 7604                    		jna load_last
  3778 00001072 8B2E9657                		mov bp,[BufSafeSec]
  3779                                  load_last:
  3780 00001076 292E9057                		sub [DirBlocksLeft],bp
  3781 0000107A 6650                    		push eax
  3782 0000107C A1[0B00]                		mov ax,[bsBytesPerSec]
  3783 0000107F F7E5                    		mul bp
  3784 00001081 05E10F                  		add ax,trackbuf-31
  3785 00001084 A33C57                  		mov [EndofDirSec],ax	; End of loaded
  3786 00001087 6658                    		pop eax
  3787 00001089 BB0010                  		mov bx,trackbuf
  3788 0000108C E8E4F2                  		call getlinsecsr
  3789 0000108F BE0010                  		mov si,trackbuf
  3790 00001092 803C00                  dir_test_name:	cmp byte [si],0		; Directory high water mark
  3791 00001095 7432                    		je dir_return		; Failed
  3792 00001097 F6440B18                                test byte [si+11],18h	; Check it really is a file
  3793 0000109B 750B                                    jnz dir_not_this
  3794 0000109D 57                      		push di
  3795 0000109E 56                      		push si
  3796 0000109F B90B00                  		mov cx,11		; Filename = 11 bytes
  3797 000010A2 F3A6                    		repe cmpsb
  3798 000010A4 5E                      		pop si
  3799 000010A5 5F                      		pop di
  3800 000010A6 7414                    		je dir_success
  3801 000010A8 83C620                  dir_not_this:   add si,byte 32
  3802 000010AB FF0E3A57                		dec word [DirScanCtr]
  3803 000010AF 7418                    		jz dir_return		; Out of it...
  3804 000010B1 3B363C57                		cmp si,[EndofDirSec]
  3805 000010B5 72DB                    		jb dir_test_name
  3806 000010B7 6601E8                  		add eax,ebp		; Increment linear sector number
  3807 000010BA EBA6                    		jmp short scan_group
  3808                                  dir_success:
  3809 000010BC 8B441C                  		mov ax,[si+28]		; Length of file
  3810 000010BF 8B541E                  		mov dx,[si+30]
  3811 000010C2 8B741A                  		mov si,[si+26]		; Cluster pointer
  3812 000010C5 89C3                    		mov bx,ax
  3813 000010C7 09D3                    		or bx,dx		; Sets ZF iff DX:AX is zero
  3814                                  dir_return:
  3815 000010C9 5D                      		pop bp
  3816 000010CA C3                      		ret
  3817                                  
  3818                                  ;
  3819                                  ; writechr:	Write a single character in AL to the console without
  3820                                  ;		mangling any registers; handle video pages correctly.
  3821                                  ;
  3822                                  writechr:
  3823 000010CB E81304                  		call write_serial	; write to serial port if needed
  3824 000010CE 669C                    		pushfd
  3825 000010D0 6660                    		pushad
  3826 000010D2 B40E                    		mov ah,0Eh
  3827 000010D4 B307                    		mov bl,07h		; attribute
  3828 000010D6 2E8A3E6204              		mov bh,[cs:BIOS_page]	; current page
  3829 000010DB CD10                    		int 10h
  3830 000010DD 6661                    		popad
  3831 000010DF 669D                    		popfd
  3832 000010E1 C3                      		ret
  3833                                  
  3834                                  ;
  3835                                  ;
  3836                                  ; kaboom2: once everything is loaded, replace the part of kaboom
  3837                                  ;	   starting with "kaboom.patch" with this part
  3838                                  
  3839                                  kaboom2:
  3840 000010E2 BE[6E20]                		mov si,err_bootfailed
  3841 000010E5 E89904                  		call cwritestr
  3842 000010E8 E85E04                  		call getchar
  3843 000010EB E8880B                  		call vgaclearmode
  3844 000010EE CD19                    		int 19h			; And try once more to boot...
  3845 000010F0 EBFE                    .norge:		jmp short .norge	; If int 19h returned; this is the end
  3846                                  
  3847                                  ;
  3848                                  ; mangle_name: Mangle a DOS filename pointed to by DS:SI into a buffer pointed
  3849                                  ;	       to by ES:DI; ends on encountering any whitespace
  3850                                  ;
  3851                                  
  3852                                  mangle_name:
  3853 000010F2 B90B00                  		mov cx,11			; # of bytes to write
  3854                                  mn_loop:
  3855 000010F5 AC                      		lodsb
  3856 000010F6 3C20                    		cmp al,' '			; If control or space, end
  3857 000010F8 762A                    		jna mn_end
  3858 000010FA 3C2E                    		cmp al,'.'			; Period -> space-fill
  3859 000010FC 740C                    		je mn_is_period
  3860 000010FE 3C61                    		cmp al,'a'
  3861 00001100 721F                    		jb mn_not_lower
  3862 00001102 3C7A                    		cmp al,'z'
  3863 00001104 770E                    		ja mn_not_uslower
  3864 00001106 2C20                    		sub al,020h
  3865 00001108 EB17                    		jmp short mn_not_lower
  3866 0000110A B020                    mn_is_period:	mov al,' '			; We need to space-fill
  3867 0000110C 83F903                  mn_period_loop: cmp cx,3			; If <= 3 characters left
  3868 0000110F 76E4                    		jbe mn_loop			; Just ignore it
  3869 00001111 AA                      		stosb				; Otherwise, write a period
  3870 00001112 E2F8                    		loop mn_period_loop		; Dec CX and (always) jump
  3871 00001114 3C81                    mn_not_uslower: cmp al,ucase_low
  3872 00001116 7209                    		jb mn_not_lower
  3873 00001118 3CA4                    		cmp al,ucase_high
  3874 0000111A 7705                    		ja mn_not_lower
  3875 0000111C BB[A810]                		mov bx,ucase_tab-ucase_low
  3876 0000111F 2ED7                                    cs xlatb
  3877 00001121 AA                      mn_not_lower:	stosb
  3878 00001122 E2D1                    		loop mn_loop			; Don't continue if too long
  3879                                  mn_end:
  3880 00001124 B020                    		mov al,' '			; Space-fill name
  3881 00001126 F3AA                    		rep stosb			; Doesn't do anything if CX=0
  3882 00001128 C3                      		ret				; Done
  3883                                  
  3884                                  ;
  3885                                  ; Upper-case table for extended characters; this is technically code page 865,
  3886                                  ; but code page 437 users will probably not miss not being able to use the
  3887                                  ; cent sign in kernel images too much :-)
  3888                                  ;
  3889                                  ; The table only covers the range 129 to 164; the rest we can deal with.
  3890                                  ;
  3891                                  ucase_low	equ 129
  3892                                  ucase_high	equ 164
  3893 00001129 9A90418E418F804545-     ucase_tab	db 154, 144, 'A', 142, 'A', 143, 128, 'EEEIII'
  3894 00001132 45494949           
  3895 00001136 8E8F9092924F994F55-     		db 142, 143, 144, 146, 146, 'O', 153, 'OUUY', 153, 154
  3896 0000113F 5559999A           
  3897 00001143 9D9C9D9E9F41494F55-     		db 157, 156, 157, 158, 159, 'AIOU', 165
  3898 0000114C A5                 
  3899                                  
  3900                                  ;
  3901                                  ; unmangle_name: Does the opposite of mangle_name; converts a DOS-mangled
  3902                                  ;                filename to the conventional representation.  This is needed
  3903                                  ;                for the BOOT_IMAGE= parameter for the kernel.
  3904                                  ;                NOTE: A 13-byte buffer is mandatory, even if the string is
  3905                                  ;                known to be shorter.
  3906                                  ;
  3907                                  ;                DS:SI -> input mangled file name
  3908                                  ;                ES:DI -> output buffer
  3909                                  ;
  3910                                  ;                On return, DI points to the first byte after the output name,
  3911                                  ;                which is set to a null byte.
  3912                                  ;
  3913                                  unmangle_name:
  3914 0000114D 56                                      push si                 ; Save pointer to original name
  3915 0000114E B90800                                  mov cx,8
  3916 00001151 89FD                                    mov bp,di
  3917 00001153 AC                      un_copy_body:   lodsb
  3918 00001154 E82600                                  call lower_case
  3919 00001157 AA                                      stosb
  3920 00001158 3C20                                    cmp al,' '
  3921 0000115A 7602                                    jbe un_cb_space
  3922 0000115C 89FD                                    mov bp,di               ; Position of last nonblank+1
  3923 0000115E E2F3                    un_cb_space:    loop un_copy_body
  3924 00001160 89EF                                    mov di,bp
  3925 00001162 B02E                                    mov al,'.'              ; Don't save
  3926 00001164 AA                                      stosb
  3927 00001165 B90300                                  mov cx,3
  3928 00001168 AC                      un_copy_ext:    lodsb
  3929 00001169 E81100                                  call lower_case
  3930 0000116C AA                                      stosb
  3931 0000116D 3C20                                    cmp al,' '
  3932 0000116F 7602                                    jbe un_ce_space
  3933 00001171 89FD                                    mov bp,di
  3934 00001173 E2F3                    un_ce_space:    loop un_copy_ext
  3935 00001175 89EF                                    mov di,bp
  3936 00001177 26C60500                                mov byte [es:di], 0
  3937 0000117B 5E                                      pop si
  3938 0000117C C3                                      ret
  3939                                  
  3940                                  ;
  3941                                  ; lower_case: Lower case a character in AL
  3942                                  ;
  3943                                  lower_case:
  3944 0000117D 3C41                                    cmp al,'A'
  3945 0000117F 7216                                    jb lc_ret
  3946 00001181 3C5A                                    cmp al,'Z'
  3947 00001183 7703                                    ja lc_1
  3948 00001185 0C20                                    or al,20h
  3949 00001187 C3                                      ret
  3950 00001188 3C80                    lc_1:           cmp al,lcase_low
  3951 0000118A 720B                                    jb lc_ret
  3952 0000118C 3CA5                                    cmp al,lcase_high
  3953 0000118E 7707                                    ja lc_ret
  3954 00001190 53                                      push bx
  3955 00001191 BB[391D]                                mov bx,lcase_tab-lcase_low
  3956 00001194 2ED7                                   	cs xlatb
  3957 00001196 5B                                      pop bx
  3958 00001197 C3                      lc_ret:         ret
  3959                                  
  3960                                  ; -----------------------------------------------------------------------------
  3961                                  ;  Common modules
  3962                                  ; -----------------------------------------------------------------------------
  3963                                  
  3964                                  %include "getc.inc"		; getc et al
  3965                              <1> ;; $Id: getc.inc,v 1.3 2002/10/24 22:11:46 hpa Exp $
  3966                              <1> ;; -----------------------------------------------------------------------
  3967                              <1> ;;   
  3968                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  3969                              <1> ;;
  3970                              <1> ;;   This program is free software; you can redistribute it and/or modify
  3971                              <1> ;;   it under the terms of the GNU General Public License as published by
  3972                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  3973                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  3974                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  3975                              <1> ;;
  3976                              <1> ;; -----------------------------------------------------------------------
  3977                              <1> 
  3978                              <1> ;;
  3979                              <1> ;; getc.inc
  3980                              <1> ;;
  3981                              <1> ;; Simple file handling library (open, getc, ungetc)
  3982                              <1> ;;
  3983                              <1> 
  3984                              <1> ;
  3985                              <1> ; open,getc:	Load a file a character at a time for parsing in a manner
  3986                              <1> ;		similar to the C library getc routine.	Only one simultaneous
  3987                              <1> ;		use is supported.  Note: "open" trashes the trackbuf.
  3988                              <1> ;
  3989                              <1> ;		open:	Input:	mangled filename in DS:DI
  3990                              <1> ;			Output: ZF set on file not found or zero length
  3991                              <1> ;
  3992                              <1> ;		openfd:	Input:	file handle in SI
  3993                              <1> ;			Output:	none
  3994                              <1> ;
  3995                              <1> ;		getc:	Output: CF set on end of file
  3996                              <1> ;				Character loaded in AL
  3997                              <1> ;
  3998                              <1> open:
  3999 00001198 E8B6FE              <1> 		call searchdir
  4000 0000119B 7427                <1> 		jz open_return
  4001                              <1> openfd:
  4002 0000119D 9C                  <1> 		pushf
  4003 0000119E A38C57              <1> 		mov [FBytes1],ax
  4004 000011A1 89168E57            <1> 		mov [FBytes2],dx
  4005 000011A5 03067857            <1> 		add ax,[ClustSize]
  4006 000011A9 83D200              <1> 		adc dx,byte 0
  4007 000011AC 83E801              <1> 		sub ax,byte 1
  4008 000011AF 83DA00              <1> 		sbb dx,byte 0
  4009 000011B2 F7367857            <1> 		div word [ClustSize]
  4010 000011B6 A39E57              <1> 		mov [FClust],ax		; Number of clusters
  4011 000011B9 8936A057            <1> 		mov [FNextClust],si	; Cluster pointer
  4012 000011BD A19A57              <1> 		mov ax,[EndOfGetCBuf]	; Pointer at end of buffer ->
  4013 000011C0 A3A257              <1> 		mov [FPtr],ax		;  nothing loaded yet
  4014 000011C3 9D                  <1> 		popf			; Restore no ZF
  4015 000011C4 C3                  <1> open_return:	ret
  4016                              <1> 
  4017                              <1> getc:
  4018 000011C5 F9                  <1> 		stc			; If we exit here -> EOF
  4019 000011C6 668B0E8C57          <1> 		mov ecx,[FBytes]
  4020 000011CB 67E33B              <1> 		jecxz getc_ret
  4021 000011CE 8B36A257            <1> 		mov si,[FPtr]
  4022 000011D2 3B369A57            <1> 		cmp si,[EndOfGetCBuf]
  4023 000011D6 7226                <1> 		jb getc_loaded
  4024                              <1> 		; Buffer empty -- load another set
  4025 000011D8 8B0E9E57            <1> 		mov cx,[FClust]
  4026 000011DC 3B0E9457            <1> 		cmp cx,[BufSafe]
  4027 000011E0 7604                <1> 		jna getc_oksize
  4028 000011E2 8B0E9457            <1> 		mov cx,[BufSafe]
  4029 000011E6 290E9E57            <1> getc_oksize:	sub [FClust],cx		; Reduce remaining clusters
  4030 000011EA 8B36A057            <1> 		mov si,[FNextClust]
  4031 000011EE 06                  <1> 		push es			; ES may be != DS, save old ES
  4032 000011EF 1E                  <1> 		push ds
  4033 000011F0 07                  <1> 		pop es
  4034 000011F1 BB00A0              <1> 		mov bx,getcbuf
  4035 000011F4 53                  <1> 		push bx
  4036 000011F5 E81DF1              <1> 		call getfssec		; Load a trackbuf full of data
  4037 000011F8 8936A057            <1> 		mov [FNextClust],si	; Store new next pointer
  4038 000011FC 5E                  <1> 		pop si			; SI -> newly loaded data
  4039 000011FD 07                  <1> 		pop es			; Restore ES
  4040 000011FE AC                  <1> getc_loaded:	lodsb			; Load a byte, increment SI
  4041 000011FF 8936A257            <1> 		mov [FPtr],si		; Update next byte pointer
  4042 00001203 66FF0E8C57          <1> 		dec dword [FBytes]	; Update bytes left counter
  4043 00001208 F8                  <1> 		clc			; Not EOF
  4044 00001209 C3                  <1> getc_ret:	ret
  4045                              <1> 
  4046                              <1> ;
  4047                              <1> ; ungetc:	Push a character (in AL) back into the getc buffer
  4048                              <1> ;		Note: if more than one byte is pushed back, this may cause
  4049                              <1> ;		bytes to be written below the getc buffer boundary.  If there
  4050                              <1> ;		is a risk for this to occur, the getcbuf base address should
  4051                              <1> ;		be moved up.
  4052                              <1> ;
  4053                              <1> ungetc:
  4054 0000120A 8B36A257            <1> 		mov si,[FPtr]
  4055 0000120E 4E                  <1> 		dec si
  4056 0000120F 8804                <1> 		mov [si],al
  4057 00001211 8936A257            <1> 		mov [FPtr],si
  4058 00001215 66FF068C57          <1> 		inc dword [FBytes]
  4059 0000121A C3                  <1> 		ret
  4060                              <1> 
  4061                              <1> ;
  4062                              <1> ; skipspace:	Skip leading whitespace using "getc".  If we hit end-of-line
  4063                              <1> ;		or end-of-file, return with carry set; ZF = true of EOF
  4064                              <1> ;		ZF = false for EOLN; otherwise CF = ZF = 0.
  4065                              <1> ;
  4066                              <1> ;		Otherwise AL = first character after whitespace
  4067                              <1> ;
  4068                              <1> skipspace:
  4069 0000121B E8A7FF              <1> skipspace_loop: call getc
  4070 0000121E 720D                <1> 		jc skipspace_eof
  4071 00001220 3C1A                <1> 		cmp al,1Ah			; DOS EOF
  4072 00001222 7409                <1> 		je skipspace_eof
  4073 00001224 3C0A                <1> 		cmp al,0Ah
  4074 00001226 7409                <1> 		je skipspace_eoln
  4075 00001228 3C20                <1> 		cmp al,' '
  4076 0000122A 76EF                <1> 		jbe skipspace_loop
  4077 0000122C C3                  <1> 		ret				; CF = ZF = 0
  4078 0000122D 38C0                <1> skipspace_eof:	cmp al,al			; Set ZF
  4079 0000122F F9                  <1> 		stc				; Set CF
  4080 00001230 C3                  <1> 		ret
  4081 00001231 04FF                <1> skipspace_eoln: add al,0FFh			; Set CF, clear ZF
  4082 00001233 C3                  <1> 		ret
  4083                              <1> 
  4084                              <1> ;
  4085                              <1> ; getint:	Load an integer from the getc file.
  4086                              <1> ;		Return CF if error; otherwise return integer in EBX
  4087                              <1> ;
  4088                              <1> getint:
  4089 00001234 BFA056              <1> 		mov di,NumBuf
  4090 00001237 81FFAF56            <1> gi_getnum:	cmp di,NumBufEnd	; Last byte in NumBuf
  4091 0000123B 730F                <1> 		jae gi_loaded
  4092 0000123D 57                  <1> 		push di
  4093 0000123E E884FF              <1> 		call getc
  4094 00001241 5F                  <1> 		pop di
  4095 00001242 7208                <1> 		jc gi_loaded
  4096 00001244 AA                  <1> 		stosb
  4097 00001245 3C2D                <1> 		cmp al,'-'
  4098 00001247 73EE                <1> 		jnb gi_getnum
  4099 00001249 E8BEFF              <1> 		call ungetc		; Unget non-numeric
  4100 0000124C C60500              <1> gi_loaded:	mov byte [di],0
  4101 0000124F BEA056              <1> 		mov si,NumBuf
  4102                              <1> 		; Fall through to parseint
  4103                              <1> 
  4104                              <1> ;
  4105                              <1> ; parseint:	Convert an integer to a number in EBX
  4106                              <1> ;		Get characters from string in DS:SI
  4107                              <1> ;		Return CF on error
  4108                              <1> ;		DS:SI points to first character after number
  4109                              <1> ;
  4110                              <1> ;               Syntaxes accepted: [-]dec, [-]0+oct, [-]0x+hex, val+K, val+M
  4111                              <1> ;
  4112                              <1> parseint:
  4113 00001252 6650                <1>                 push eax
  4114 00001254 6651                <1>                 push ecx
  4115 00001256 55                  <1> 		push bp
  4116 00001257 6631C0              <1> 		xor eax,eax		; Current digit (keep eax == al)
  4117 0000125A 6689C3              <1> 		mov ebx,eax		; Accumulator
  4118 0000125D 6689D9              <1> 		mov ecx,ebx		; Base
  4119 00001260 31ED                <1>                 xor bp,bp               ; Used for negative flag
  4120 00001262 AC                  <1> pi_begin:	lodsb
  4121 00001263 3C2D                <1> 		cmp al,'-'
  4122 00001265 7505                <1> 		jne pi_not_minus
  4123 00001267 83F501              <1> 		xor bp,1		; Set unary minus flag
  4124 0000126A EBF6                <1> 		jmp short pi_begin
  4125                              <1> pi_not_minus:
  4126 0000126C 3C30                <1> 		cmp al,'0'
  4127 0000126E 724F                <1> 		jb pi_err
  4128 00001270 7408                <1> 		je pi_octhex
  4129 00001272 3C39                <1> 		cmp al,'9'
  4130 00001274 7749                <1> 		ja pi_err
  4131 00001276 B10A                <1> 		mov cl,10		; Base = decimal
  4132 00001278 EB17                <1> 		jmp short pi_foundbase
  4133                              <1> pi_octhex:
  4134 0000127A AC                  <1> 		lodsb
  4135 0000127B 3C30                <1> 		cmp al,'0'
  4136 0000127D 7225                <1> 		jb pi_km		; Value is zero
  4137 0000127F 0C20                <1> 		or al,20h		; Downcase
  4138 00001281 3C78                <1> 		cmp al,'x'
  4139 00001283 7408                <1> 		je pi_ishex
  4140 00001285 3C37                <1> 		cmp al,'7'
  4141 00001287 7736                <1> 		ja pi_err
  4142 00001289 B108                <1> 		mov cl,8		; Base = octal
  4143 0000128B EB04                <1> 		jmp short pi_foundbase
  4144                              <1> pi_ishex:
  4145 0000128D B030                <1> 		mov al,'0'		; No numeric value accrued yet
  4146 0000128F B110                <1> 		mov cl,16		; Base = hex
  4147                              <1> pi_foundbase:
  4148 00001291 E83A00              <1>                 call unhexchar
  4149 00001294 720E                <1>                 jc pi_km                ; Not a (hex) digit
  4150 00001296 38C8                <1>                 cmp al,cl
  4151 00001298 730A                <1> 		jae pi_km		; Invalid for base
  4152 0000129A 660FAFD9            <1> 		imul ebx,ecx		; Multiply accumulated by base
  4153 0000129E 6601C3              <1>                 add ebx,eax             ; Add current digit
  4154 000012A1 AC                  <1> 		lodsb
  4155 000012A2 EBED                <1> 		jmp short pi_foundbase
  4156                              <1> pi_km:
  4157 000012A4 4E                  <1> 		dec si			; Back up to last non-numeric
  4158 000012A5 AC                  <1> 		lodsb
  4159 000012A6 0C20                <1> 		or al,20h
  4160 000012A8 3C6B                <1> 		cmp al,'k'
  4161 000012AA 7416                <1> 		je pi_isk
  4162 000012AC 3C6D                <1> 		cmp al,'m'
  4163 000012AE 7418                <1> 		je pi_ism
  4164 000012B0 4E                  <1> 		dec si			; Back up
  4165 000012B1 21ED                <1> pi_fini:	and bp,bp
  4166 000012B3 7404                <1> 		jz pi_ret		; CF=0!
  4167 000012B5 66F7DB              <1> 		neg ebx			; Value was negative
  4168 000012B8 F8                  <1> pi_done:	clc
  4169 000012B9 5D                  <1> pi_ret:		pop bp
  4170 000012BA 6659                <1>                 pop ecx
  4171 000012BC 6658                <1>                 pop eax
  4172 000012BE C3                  <1> 		ret
  4173 000012BF F9                  <1> pi_err:		stc
  4174 000012C0 EBF7                <1> 		jmp short pi_ret
  4175 000012C2 66C1E30A            <1> pi_isk:		shl ebx,10		; x 2^10
  4176 000012C6 EBF0                <1> 		jmp short pi_done
  4177 000012C8 66C1E314            <1> pi_ism:		shl ebx,20		; x 2^20
  4178 000012CC EBEA                <1> 		jmp short pi_done
  4179                              <1> 
  4180                              <1> ;
  4181                              <1> ; unhexchar:    Convert a hexadecimal digit in AL to the equivalent number;
  4182                              <1> ;               return CF=1 if not a hex digit
  4183                              <1> ;
  4184                              <1> unhexchar:
  4185 000012CE 3C30                <1>                 cmp al,'0'
  4186 000012D0 7215                <1> 		jb uxc_ret		; If failure, CF == 1 already
  4187 000012D2 3C39                <1>                 cmp al,'9'
  4188 000012D4 7703                <1>                 ja uxc_1
  4189 000012D6 2C30                <1> 		sub al,'0'		; CF <- 0
  4190 000012D8 C3                  <1> 		ret
  4191 000012D9 0C20                <1> uxc_1:          or al,20h		; upper case -> lower case
  4192 000012DB 3C61                <1> 		cmp al,'a'
  4193 000012DD 7208                <1>                 jb uxc_ret		; If failure, CF == 1 already
  4194 000012DF 3C66                <1>                 cmp al,'f'
  4195 000012E1 7703                <1>                 ja uxc_err
  4196 000012E3 2C57                <1>                 sub al,'a'-10           ; CF <- 0
  4197 000012E5 C3                  <1>                 ret
  4198 000012E6 F9                  <1> uxc_err:        stc
  4199 000012E7 C3                  <1> uxc_ret:	ret
  4200                              <1> 
  4201                              <1> ;
  4202                              <1> ;
  4203                              <1> ; getline:	Get a command line, converting control characters to spaces
  4204                              <1> ;               and collapsing streches to one; a space is appended to the
  4205                              <1> ;               end of the string, unless the line is empty.
  4206                              <1> ;		The line is terminated by ^J, ^Z or EOF and is written
  4207                              <1> ;		to ES:DI.  On return, DI points to first char after string.
  4208                              <1> ;		CF is set if we hit EOF.
  4209                              <1> ;
  4210                              <1> getline:
  4211 000012E8 E830FF              <1> 		call skipspace
  4212 000012EB B201                <1>                 mov dl,1                ; Empty line -> empty string.
  4213 000012ED 742B                <1>                 jz gl_eof               ; eof
  4214 000012EF 7226                <1>                 jc gl_eoln              ; eoln
  4215 000012F1 E816FF              <1> 		call ungetc
  4216 000012F4 52                  <1> gl_fillloop:	push dx
  4217 000012F5 57                  <1> 		push di
  4218 000012F6 E8CCFE              <1> 		call getc
  4219 000012F9 5F                  <1> 		pop di
  4220 000012FA 5A                  <1> 		pop dx
  4221 000012FB 721E                <1> 		jc gl_ret		; CF set!
  4222 000012FD 3C20                <1> 		cmp al,' '
  4223 000012FF 7605                <1> 		jna gl_ctrl
  4224 00001301 31D2                <1> 		xor dx,dx
  4225 00001303 AA                  <1> gl_store:	stosb
  4226 00001304 EBEE                <1> 		jmp short gl_fillloop
  4227 00001306 3C0A                <1> gl_ctrl:	cmp al,10
  4228 00001308 7411                <1> 		je gl_ret		; CF clear!
  4229 0000130A 3C1A                <1> 		cmp al,26
  4230 0000130C 740C                <1> 		je gl_eof
  4231 0000130E 20D2                <1> 		and dl,dl
  4232 00001310 75E2                <1> 		jnz gl_fillloop		; Ignore multiple spaces
  4233 00001312 B020                <1> 		mov al,' '		; Ctrl -> space
  4234 00001314 42                  <1> 		inc dx
  4235 00001315 EBEC                <1> 		jmp short gl_store
  4236 00001317 F8                  <1> gl_eoln:        clc                     ; End of line is not end of file
  4237 00001318 EB01                <1>                 jmp short gl_ret
  4238 0000131A F9                  <1> gl_eof:         stc
  4239 0000131B 9C                  <1> gl_ret:		pushf			; We want the last char to be space!
  4240 0000131C 20D2                <1> 		and dl,dl
  4241 0000131E 7503                <1> 		jnz gl_xret
  4242 00001320 B020                <1> 		mov al,' '
  4243 00001322 AA                  <1> 		stosb
  4244 00001323 9D                  <1> gl_xret:	popf
  4245 00001324 C3                  <1> 		ret
  4246                                  %include "conio.inc"		; Console I/O
  4247                              <1> ;; $Id: conio.inc,v 1.6 2004/01/29 06:54:51 hpa Exp $
  4248                              <1> ;; -----------------------------------------------------------------------
  4249                              <1> ;;   
  4250                              <1> ;;   Copyright 1994-2004 H. Peter Anvin - All Rights Reserved
  4251                              <1> ;;
  4252                              <1> ;;   This program is free software; you can redistribute it and/or modify
  4253                              <1> ;;   it under the terms of the GNU General Public License as published by
  4254                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  4255                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  4256                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  4257                              <1> ;;
  4258                              <1> ;; -----------------------------------------------------------------------
  4259                              <1> 
  4260                              <1> ;;
  4261                              <1> ;; conio.inc
  4262                              <1> ;;
  4263                              <1> ;; Console I/O code, except:
  4264                              <1> ;;   writechr, writestr		- module-dependent
  4265                              <1> ;;   cwritestr, crlf		- writestr.inc
  4266                              <1> ;;   writehex*			- writehex.inc
  4267                              <1> ;;
  4268                              <1> 
  4269                              <1> ;
  4270                              <1> ; loadkeys:	Load a LILO-style keymap; SI and DX:AX set by searchdir
  4271                              <1> ;
  4272                              <1> loadkeys:
  4273 00001325 21D2                <1> 		and dx,dx			; Should be 256 bytes exactly
  4274 00001327 751A                <1> 		jne loadkeys_ret
  4275 00001329 3D0001              <1> 		cmp ax,256
  4276 0000132C 7515                <1> 		jne loadkeys_ret
  4277                              <1> 
  4278 0000132E BB0010              <1> 		mov bx,trackbuf
  4279 00001331 B90100              <1> 		mov cx,1			; 1 cluster should be >= 256 bytes
  4280 00001334 E8DEEF              <1> 		call getfssec
  4281                              <1> 
  4282 00001337 BE0010              <1> 		mov si,trackbuf
  4283 0000133A BF0055              <1> 		mov di,KbdMap
  4284 0000133D B94000              <1> 		mov cx,256 >> 2
  4285 00001340 F366A5              <1> 		rep movsd
  4286                              <1> 
  4287 00001343 C3                  <1> loadkeys_ret:	ret
  4288                              <1> 		
  4289                              <1> ;
  4290                              <1> ; get_msg_file: Load a text file and write its contents to the screen,
  4291                              <1> ;               interpreting color codes.  Is called with SI and DX:AX
  4292                              <1> ;               set by routine searchdir
  4293                              <1> ;
  4294                              <1> get_msg_file:
  4295 00001344 06                  <1> 		push es
  4296 00001345 66C1E210            <1> 		shl edx,16			; EDX <- DX:AX (length of file)
  4297 00001349 89C2                <1> 		mov dx,ax
  4298 0000134B B80010              <1> 		mov ax,xfer_buf_seg		; Use for temporary storage
  4299 0000134E 8EC0                <1> 		mov es,ax
  4300                              <1> 
  4301 00001350 C606C75707          <1>                 mov byte [TextAttribute],07h	; Default grey on white
  4302 00001355 C606CD5707          <1> 		mov byte [DisplayMask],07h	; Display text in all modes
  4303 0000135A E86601              <1> 		call msg_initvars
  4304                              <1> 
  4305 0000135D 6652                <1> get_msg_chunk:  push edx			; EDX = length of file
  4306 0000135F 31DB                <1> 		xor bx,bx			; == xbs_textbuf
  4307 00001361 8B0E9457            <1> 		mov cx,[BufSafe]
  4308 00001365 E8ADEF              <1> 		call getfssec
  4309 00001368 665A                <1> 		pop edx
  4310 0000136A 56                  <1> 		push si				; Save current cluster
  4311 0000136B 31F6                <1> 		xor si,si			; == xbs_textbuf
  4312 0000136D 8B0E9857            <1> 		mov cx,[BufSafeBytes]		; Number of bytes left in chunk
  4313                              <1> print_msg_file:
  4314 00001371 51                  <1> 		push cx
  4315 00001372 6652                <1> 		push edx
  4316 00001374 26AC                <1> 		es lodsb
  4317 00001376 3C1A                <1>                 cmp al,1Ah                      ; DOS EOF?
  4318 00001378 7418                <1> 		je msg_done_pop
  4319 0000137A 56                  <1> 		push si
  4320 0000137B 8A0E[CD1C]          <1> 		mov cl,[UsingVGA]
  4321 0000137F FEC1                <1> 		inc cl				; 01h = text mode, 02h = graphics
  4322 00001381 FF16AA57            <1>                 call [NextCharJump]		; Do what shall be done
  4323 00001385 5E                  <1> 		pop si
  4324 00001386 665A                <1> 		pop edx
  4325 00001388 59                  <1>                 pop cx
  4326 00001389 664A                <1> 		dec edx
  4327 0000138B 7408                <1> 		jz msg_done
  4328 0000138D E2E2                <1> 		loop print_msg_file
  4329 0000138F 5E                  <1> 		pop si
  4330 00001390 EBCB                <1> 		jmp short get_msg_chunk
  4331                              <1> msg_done_pop:
  4332 00001392 83C406              <1>                 add sp,byte 6			; Drop pushed EDX, CX
  4333                              <1> msg_done:
  4334 00001395 5E                  <1> 		pop si
  4335 00001396 07                  <1> 		pop es
  4336 00001397 C3                  <1> 		ret
  4337                              <1> msg_putchar:                                    ; Normal character
  4338 00001398 3C0F                <1>                 cmp al,0Fh                      ; ^O = color code follows
  4339 0000139A 7454                <1>                 je msg_ctrl_o
  4340 0000139C 3C0D                <1>                 cmp al,0Dh                      ; Ignore <CR>
  4341 0000139E 744F                <1>                 je msg_ignore
  4342 000013A0 3C0A                <1>                 cmp al,0Ah                      ; <LF> = newline
  4343 000013A2 7453                <1>                 je msg_newline
  4344 000013A4 3C0C                <1>                 cmp al,0Ch                      ; <FF> = clear screen
  4345 000013A6 0F848200            <1>                 je msg_formfeed
  4346 000013AA 3C19                <1> 		cmp al,19h			; <EM> = return to text mode
  4347 000013AC 0F84F700            <1> 		je msg_novga
  4348 000013B0 3C18                <1> 		cmp al,18h			; <CAN> = VGA filename follows
  4349 000013B2 0F84C000            <1> 		je msg_vga
  4350 000013B6 7306                <1> 		jnb .not_modectl
  4351 000013B8 3C10                <1> 		cmp al,10h			; 10h to 17h are mode controls
  4352 000013BA 0F831501            <1> 		jae msg_modectl
  4353                              <1> .not_modectl:
  4354                              <1> 
  4355 000013BE E81901              <1> msg_normal:	call write_serial_displaymask	; Write to serial port
  4356 000013C1 840ECD57            <1> 		test [DisplayMask],cl
  4357 000013C5 7428                <1> 		jz msg_ignore			; Not screen
  4358 000013C7 8A1EC757            <1>                 mov bl,[TextAttribute]
  4359 000013CB 8A3E6204            <1> 		mov bh,[BIOS_page]
  4360 000013CF B409                <1>                 mov ah,09h                      ; Write character/attribute
  4361 000013D1 B90100              <1>                 mov cx,1                        ; One character only
  4362 000013D4 CD10                <1>                 int 10h                         ; Write to screen
  4363 000013D6 A0BE57              <1>                 mov al,[CursorCol]
  4364 000013D9 40                  <1>                 inc ax
  4365 000013DA 3A06C057            <1>                 cmp al,[VidCols]
  4366 000013DE 771D                <1>                 ja msg_line_wrap		; Screen wraparound
  4367 000013E0 A2BE57              <1>                 mov [CursorCol],al
  4368                              <1> 
  4369 000013E3 8A3E6204            <1> msg_gotoxy:     mov bh,[BIOS_page]
  4370 000013E7 8B16BE57            <1>                 mov dx,[CursorDX]
  4371 000013EB B402                <1>                 mov ah,02h                      ; Set cursor position
  4372 000013ED CD10                <1>                 int 10h
  4373 000013EF C3                  <1> msg_ignore:     ret
  4374                              <1> msg_ctrl_o:                                     ; ^O = color code follows
  4375 000013F0 C706AA57[4D14]      <1>                 mov word [NextCharJump],msg_setbg
  4376 000013F6 C3                  <1>                 ret
  4377                              <1> msg_newline:                                    ; Newline char or end of line
  4378 000013F7 BE[D020]            <1> 		mov si,crlf_msg
  4379 000013FA E81001              <1> 		call write_serial_str_displaymask
  4380                              <1> msg_line_wrap:					; Screen wraparound
  4381 000013FD 840ECD57            <1> 		test [DisplayMask],cl
  4382 00001401 74EC                <1> 		jz msg_ignore
  4383 00001403 C606BE5700          <1>                 mov byte [CursorCol],0
  4384 00001408 A0BF57              <1>                 mov al,[CursorRow]
  4385 0000140B 40                  <1>                 inc ax
  4386 0000140C 3A06C157            <1>                 cmp al,[VidRows]
  4387 00001410 7705                <1>                 ja msg_scroll
  4388 00001412 A2BF57              <1>                 mov [CursorRow],al
  4389 00001415 EBCC                <1>                 jmp short msg_gotoxy
  4390 00001417 31C9                <1> msg_scroll:     xor cx,cx                       ; Upper left hand corner
  4391 00001419 8B16C057            <1>                 mov dx,[ScreenSize]
  4392 0000141D 8836BF57            <1>                 mov [CursorRow],dh		; New cursor at the bottom
  4393 00001421 8A3E[F521]          <1>                 mov bh,[ScrollAttribute]
  4394 00001425 B80106              <1>                 mov ax,0601h                    ; Scroll up one line
  4395 00001428 CD10                <1>                 int 10h
  4396 0000142A EBB7                <1>                 jmp short msg_gotoxy
  4397                              <1> msg_formfeed:                                   ; Form feed character
  4398 0000142C BE[D320]            <1> 		mov si,crff_msg
  4399 0000142F E8DB00              <1> 		call write_serial_str_displaymask
  4400 00001432 840ECD57            <1> 		test [DisplayMask],cl
  4401 00001436 74B7                <1> 		jz msg_ignore
  4402 00001438 31C9                <1>                 xor cx,cx
  4403 0000143A 890EBE57            <1>                 mov [CursorDX],cx		; Upper lefthand corner
  4404 0000143E 8B16C057            <1>                 mov dx,[ScreenSize]
  4405 00001442 8A3EC757            <1>                 mov bh,[TextAttribute]
  4406 00001446 B80006              <1>                 mov ax,0600h                    ; Clear screen region
  4407 00001449 CD10                <1>                 int 10h
  4408 0000144B EB96                <1>                 jmp msg_gotoxy
  4409                              <1> msg_setbg:                                      ; Color background character
  4410 0000144D E87EFE              <1>                 call unhexchar
  4411 00001450 722F                <1>                 jc msg_color_bad
  4412 00001452 C0E004              <1>                 shl al,4
  4413 00001455 840ECD57            <1> 		test [DisplayMask],cl
  4414 00001459 7403                <1> 		jz .dontset
  4415 0000145B A2C757              <1>                 mov [TextAttribute],al
  4416                              <1> .dontset:
  4417 0000145E C706AA57[6514]      <1>                 mov word [NextCharJump],msg_setfg
  4418 00001464 C3                  <1>                 ret
  4419                              <1> msg_setfg:                                      ; Color foreground character
  4420 00001465 E866FE              <1>                 call unhexchar
  4421 00001468 7217                <1>                 jc msg_color_bad
  4422 0000146A 840ECD57            <1> 		test [DisplayMask],cl
  4423 0000146E 7404                <1> 		jz .dontset
  4424 00001470 0806C757            <1>                 or [TextAttribute],al		; setbg set foreground to 0
  4425                              <1> .dontset:
  4426 00001474 EB10                <1> 		jmp short msg_putcharnext
  4427                              <1> msg_vga:
  4428 00001476 C706AA57[8D14]      <1> 		mov word [NextCharJump],msg_filename
  4429 0000147C BF1058              <1> 		mov di, VGAFileBuf
  4430 0000147F EB21                <1> 		jmp short msg_setvgafileptr
  4431                              <1> 
  4432                              <1> msg_color_bad:
  4433 00001481 C606C75707          <1>                 mov byte [TextAttribute],07h	; Default attribute
  4434                              <1> msg_putcharnext:
  4435 00001486 C706AA57[9813]      <1>                 mov word [NextCharJump],msg_putchar
  4436 0000148C C3                  <1> 		ret
  4437                              <1> 
  4438                              <1> msg_filename:					; Getting VGA filename
  4439 0000148D 3C0A                <1> 		cmp al,0Ah			; <LF> = end of filename
  4440 0000148F 741B                <1> 		je msg_viewimage
  4441 00001491 3C20                <1> 		cmp al,' '
  4442 00001493 7611                <1> 		jbe msg_ret			; Ignore space/control char
  4443 00001495 8B3EBA57            <1> 		mov di,[VGAFilePtr]
  4444 00001499 81FF1D58            <1> 		cmp di,VGAFileBufEnd
  4445 0000149D 7307                <1> 		jnb msg_ret
  4446 0000149F 8805                <1> 		mov [di],al			; Can't use stosb (DS:)
  4447 000014A1 47                  <1> 		inc di
  4448                              <1> msg_setvgafileptr:
  4449 000014A2 893EBA57            <1> 		mov [VGAFilePtr],di
  4450 000014A6 C3                  <1> msg_ret:	ret
  4451                              <1> 
  4452                              <1> msg_novga:
  4453 000014A7 E8CC07              <1> 		call vgaclearmode
  4454 000014AA EB17                <1> 		jmp short msg_initvars
  4455                              <1> 
  4456                              <1> msg_viewimage:
  4457 000014AC 06                  <1> 		push es
  4458 000014AD 1E                  <1> 		push ds
  4459 000014AE 07                  <1> 		pop es				; ES <- DS
  4460 000014AF BE1058              <1> 		mov si,VGAFileBuf
  4461 000014B2 BF1D58              <1> 		mov di,VGAFileMBuf
  4462 000014B5 57                  <1> 		push di
  4463 000014B6 E839FC              <1> 		call mangle_name
  4464 000014B9 5F                  <1> 		pop di
  4465 000014BA E894FB              <1> 		call searchdir
  4466 000014BD 07                  <1> 		pop es
  4467 000014BE 74C6                <1> 		jz msg_putcharnext		; Not there
  4468 000014C0 E82D06              <1> 		call vgadisplayfile
  4469                              <1> 		; Fall through
  4470                              <1> 
  4471                              <1> 		; Subroutine to initialize variables, also needed
  4472                              <1> 		; after loading a graphics file
  4473                              <1> msg_initvars:
  4474 000014C3 60                  <1>                 pusha
  4475 000014C4 8A3E6204            <1>                 mov bh,[BIOS_page]
  4476 000014C8 B403                <1>                 mov ah,03h                      ; Read cursor position
  4477 000014CA CD10                <1>                 int 10h
  4478 000014CC 8916BE57            <1>                 mov [CursorDX],dx
  4479 000014D0 61                  <1>                 popa
  4480 000014D1 EBB3                <1> 		jmp short msg_putcharnext	; Initialize state machine
  4481                              <1> 
  4482                              <1> msg_modectl:
  4483 000014D3 2407                <1> 		and al,07h
  4484 000014D5 A2CD57              <1> 		mov [DisplayMask],al
  4485 000014D8 EBAC                <1> 		jmp short msg_putcharnext
  4486                              <1> 
  4487                              <1> ;
  4488                              <1> ; write_serial:	If serial output is enabled, write character on serial port
  4489                              <1> ; write_serial_displaymask: d:o, but ignore if DisplayMask & 04h == 0
  4490                              <1> ;
  4491                              <1> write_serial_displaymask:
  4492 000014DA F606CD5704          <1> 		test byte [DisplayMask], 04h
  4493 000014DF 742B                <1> 		jz write_serial.end
  4494                              <1> write_serial:
  4495 000014E1 669C                <1> 		pushfd
  4496 000014E3 6660                <1> 		pushad
  4497 000014E5 8B1E[F021]          <1> 		mov bx,[SerialPort]
  4498 000014E9 21DB                <1> 		and bx,bx
  4499 000014EB 741B                <1> 		je .noserial
  4500 000014ED 50                  <1> 		push ax
  4501 000014EE 8A26C557            <1> 		mov ah,[FlowInput]
  4502                              <1> .waitspace:
  4503                              <1> 		; Wait for space in transmit register
  4504 000014F2 8D5705              <1> 		lea dx,[bx+5]			; DX -> LSR
  4505 000014F5 EC                  <1> 		in al,dx
  4506 000014F6 A820                <1> 		test al,20h
  4507 000014F8 74F8                <1> 		jz .waitspace
  4508                              <1> 
  4509                              <1> 		; Wait for input flow control
  4510 000014FA 42                  <1> 		inc dx				; DX -> MSR
  4511 000014FB EC                  <1> 		in al,dx
  4512 000014FC 20E0                <1> 		and al,ah
  4513 000014FE 38E0                <1> 		cmp al,ah
  4514 00001500 75F0                <1> 		jne .waitspace	
  4515                              <1> .no_flow:		
  4516                              <1> 
  4517 00001502 87D3                <1> 		xchg dx,bx			; DX -> THR
  4518 00001504 58                  <1> 		pop ax
  4519 00001505 E87603              <1> 		call slow_out			; Send data
  4520 00001508 6661                <1> .noserial:	popad
  4521 0000150A 669D                <1> 		popfd
  4522 0000150C C3                  <1> .end:		ret
  4523                              <1> 
  4524                              <1> ;
  4525                              <1> ; write_serial_str: write_serial for strings
  4526                              <1> ; write_serial_str_displaymask: d:o, but ignore if DisplayMask & 04h == 0
  4527                              <1> ;
  4528                              <1> write_serial_str_displaymask:
  4529 0000150D F606CD5704          <1> 		test byte [DisplayMask], 04h
  4530 00001512 740A                <1> 		jz write_serial_str.end
  4531                              <1> 
  4532                              <1> write_serial_str:
  4533 00001514 AC                  <1> .loop		lodsb
  4534 00001515 20C0                <1> 		and al,al
  4535 00001517 7405                <1> 		jz .end
  4536 00001519 E8C5FF              <1> 		call write_serial
  4537 0000151C EBF6                <1> 		jmp short .loop
  4538 0000151E C3                  <1> .end:		ret
  4539                              <1> 
  4540                              <1> ;
  4541                              <1> ; pollchar: check if we have an input character pending (ZF = 0)
  4542                              <1> ;
  4543                              <1> pollchar:
  4544 0000151F 6660                <1> 		pushad
  4545 00001521 B401                <1> 		mov ah,1		; Poll keyboard
  4546 00001523 CD16                <1> 		int 16h
  4547 00001525 751F                <1> 		jnz .done		; Keyboard response
  4548 00001527 8B16[F021]          <1> 		mov dx,[SerialPort]
  4549 0000152B 21D2                <1> 		and dx,dx
  4550 0000152D 7417                <1> 		jz .done		; No serial port -> no input
  4551 0000152F 83C205              <1> 		add dx,byte 5		; DX -> LSR
  4552 00001532 EC                  <1> 		in al,dx
  4553 00001533 A801                <1> 		test al,1		; ZF = 0 if data pending
  4554 00001535 740F                <1> 		jz .done
  4555 00001537 42                  <1> 		inc dx			; DX -> MSR
  4556 00001538 8A26C657            <1> 		mov ah,[FlowIgnore]	; Required status bits
  4557 0000153C EC                  <1> 		in al,dx
  4558 0000153D 20E0                <1> 		and al,ah
  4559 0000153F 38E0                <1> 		cmp al,ah
  4560 00001541 0F95C0              <1> 		setne al
  4561 00001544 FEC8                <1> 		dec al			; Set ZF = 0 if equal
  4562 00001546 6661                <1> .done:		popad
  4563 00001548 C3                  <1> 		ret
  4564                              <1> 
  4565                              <1> ;
  4566                              <1> ; getchar: Read a character from keyboard or serial port
  4567                              <1> ;
  4568                              <1> getchar:
  4569                              <1> 		RESET_IDLE
  4570                              <2> 
  4571                              <1> .again:
  4572                              <1> 		DO_IDLE
  4573                              <2> 
  4574 00001549 B401                <1> 		mov ah,1		; Poll keyboard
  4575 0000154B CD16                <1> 		int 16h
  4576 0000154D 7522                <1> 		jnz .kbd		; Keyboard input?
  4577 0000154F 8B1E[F021]          <1> 		mov bx,[SerialPort]
  4578 00001553 21DB                <1> 		and bx,bx
  4579 00001555 74F2                <1> 		jz .again
  4580 00001557 8D5705              <1> 		lea dx,[bx+5]		; DX -> LSR
  4581 0000155A EC                  <1> 		in al,dx
  4582 0000155B A801                <1> 		test al,1
  4583 0000155D 74EA                <1> 		jz .again
  4584 0000155F 42                  <1> 		inc dx			; DX -> MSR
  4585 00001560 8A26C657            <1> 		mov ah,[FlowIgnore]
  4586 00001564 EC                  <1> 		in al,dx
  4587 00001565 20E0                <1> 		and al,ah
  4588 00001567 38E0                <1> 		cmp al,ah
  4589 00001569 75DE                <1> 		jne .again
  4590 0000156B 30E4                <1> .serial:	xor ah,ah		; Avoid confusion
  4591 0000156D 87D3                <1> 		xchg dx,bx		; Data port
  4592 0000156F EC                  <1> 		in al,dx
  4593 00001570 C3                  <1> 		ret
  4594 00001571 31C0                <1> .kbd:		xor ax,ax		; Get keyboard input
  4595 00001573 CD16                <1> 		int 16h
  4596 00001575 20C0                <1> 		and al,al
  4597 00001577 7404                <1> 		jz .func_key
  4598 00001579 BB0055              <1> 		mov bx,KbdMap		; Convert character sets
  4599 0000157C D7                  <1> 		xlatb
  4600 0000157D C3                  <1> .func_key:	ret
  4601                              <1> 
  4602                              <1> %ifdef DEBUG_TRACERS
  4603                              <1> ;
  4604                              <1> ; debug hack to print a character with minimal code impact
  4605                              <1> ;
  4606                              <1> debug_tracer:	pushad
  4607                              <1> 		pushfd
  4608                              <1> 		mov bp,sp
  4609                              <1> 		mov bx,[bp+9*4]		; Get return address
  4610                              <1> 		mov al,[cs:bx]		; Get data byte
  4611                              <1> 		inc word [bp+9*4]	; Return to after data byte
  4612                              <1> 		call writechr
  4613                              <1> 		popfd
  4614                              <1> 		popad
  4615                              <1> 		ret
  4616                              <1> %endif	; DEBUG_TRACERS
  4617                                  %include "writestr.inc"		; String output
  4618                              <1> ;; $Id: writestr.inc,v 1.2 2002/11/19 01:00:31 hpa Exp $
  4619                              <1> ;; -----------------------------------------------------------------------
  4620                              <1> ;;   
  4621                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  4622                              <1> ;;
  4623                              <1> ;;   This program is free software; you can redistribute it and/or modify
  4624                              <1> ;;   it under the terms of the GNU General Public License as published by
  4625                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  4626                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  4627                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  4628                              <1> ;;
  4629                              <1> ;; -----------------------------------------------------------------------
  4630                              <1> 
  4631                              <1> ;;
  4632                              <1> ;; writestr.inc
  4633                              <1> ;;
  4634                              <1> ;; Code to write a simple string.
  4635                              <1> ;;
  4636                              <1> 
  4637                              <1> ;
  4638                              <1> ; crlf: Print a newline
  4639                              <1> ;
  4640 0000157E BE[D020]            <1> crlf:		mov si,crlf_msg
  4641                              <1> 		; Fall through
  4642                              <1> 
  4643                              <1> ;
  4644                              <1> ; cwritestr: write a null-terminated string to the console, saving
  4645                              <1> ;            registers on entry.
  4646                              <1> ;
  4647                              <1> ; Note: writestr and cwritestr are distinct in SYSLINUX (only)
  4648                              <1> ;
  4649                              <1> cwritestr:
  4650 00001581 669C                <1> 		pushfd
  4651 00001583 6660                <1>                 pushad
  4652 00001585 AC                  <1> .top:		lodsb
  4653 00001586 20C0                <1> 		and al,al
  4654 00001588 7405                <1>                 jz .end
  4655 0000158A E83EFB              <1> 		call writechr
  4656 0000158D EBF6                <1>                 jmp short .top
  4657 0000158F 6661                <1> .end:		popad
  4658 00001591 669D                <1> 		popfd
  4659 00001593 C3                  <1>                 ret
  4660                                  %include "parseconfig.inc"	; High-level config file handling
  4661                              <1> ;; $Id: parseconfig.inc,v 1.11 2003/11/27 05:36:16 hpa Exp $
  4662                              <1> ;; -----------------------------------------------------------------------
  4663                              <1> ;;   
  4664                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  4665                              <1> ;;
  4666                              <1> ;;   This program is free software; you can redistribute it and/or modify
  4667                              <1> ;;   it under the terms of the GNU General Public License as published by
  4668                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  4669                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  4670                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  4671                              <1> ;;
  4672                              <1> ;; -----------------------------------------------------------------------
  4673                              <1> 
  4674                              <1> ;;
  4675                              <1> ;; parseconfig.inc
  4676                              <1> ;;
  4677                              <1> ;; Configuration file operations
  4678                              <1> ;;
  4679                              <1> 
  4680                              <1> ;
  4681                              <1> ; "default" command
  4682                              <1> ; 
  4683 00001594 BF2959              <1> pc_default:	mov di,default_cmd
  4684 00001597 E84EFD              <1> 		call getline
  4685 0000159A C645FF00            <1> 		mov byte [di-1],0		; null-terminate
  4686 0000159E C3                  <1> 		ret
  4687                              <1> 
  4688                              <1> ;
  4689                              <1> ; "ontimeout" command
  4690                              <1> ;
  4691 0000159F BF0053              <1> pc_ontimeout:	mov di,Ontimeout
  4692 000015A2 E843FD              <1> 		call getline
  4693 000015A5 81EF0153            <1> 		sub di,Ontimeout+1		; Don't need final space
  4694 000015A9 893E[DE21]          <1> 		mov [OntimeoutLen],di
  4695 000015AD C3                  <1> 		ret
  4696                              <1> 
  4697                              <1> ;
  4698                              <1> ; "onerror" command
  4699                              <1> ;
  4700 000015AE BF0054              <1> pc_onerror:	mov di,Onerror
  4701 000015B1 E834FD              <1> 		call getline
  4702 000015B4 81EF0054            <1> 		sub di,Onerror
  4703 000015B8 893E[E021]          <1> 		mov [OnerrorLen],di
  4704 000015BC C3                  <1> 		ret
  4705                              <1> 
  4706                              <1> ;
  4707                              <1> ; "append" command
  4708                              <1> ;
  4709 000015BD 833E[E821]00        <1> pc_append:      cmp word [VKernelCtr],byte 0
  4710 000015C2 770F                <1> 		ja .vk
  4711 000015C4 BF0052              <1>                 mov di,AppendBuf
  4712 000015C7 E81EFD              <1> 		call getline
  4713 000015CA 81EF0052            <1>                 sub di,AppendBuf
  4714 000015CE 893E[DC21]          <1> .app1:        	mov [AppendLen],di
  4715 000015D2 C3                  <1> 		ret
  4716 000015D3 BF1850              <1> .vk:		mov di,VKernelBuf+vk_append	; "append" command (vkernel)
  4717 000015D6 E80FFD              <1> 		call getline
  4718 000015D9 81EF1850            <1> 		sub di,VKernelBuf+vk_append
  4719 000015DD 83FF02              <1>                 cmp di,byte 2
  4720 000015E0 7509                <1>                 jne .app2
  4721 000015E2 803E18502D          <1>                 cmp byte [VKernelBuf+vk_append],'-'
  4722 000015E7 7502                <1>                 jne .app2
  4723 000015E9 31FF                <1>                 xor di,di			; If "append -" -> null string
  4724 000015EB 893E1650            <1> .app2:		mov [VKernelBuf+vk_appendlen],di
  4725 000015EF C3                  <1> 		ret
  4726                              <1> 
  4727                              <1> ;
  4728                              <1> ; "ipappend" command (PXELINUX only)
  4729                              <1> ;
  4730                              <1> %if IS_PXELINUX
  4731                              <1> pc_ipappend:	call getint
  4732                              <1> 		jc .err
  4733                              <1> 		cmp word [VKernelCtr], byte 0
  4734                              <1> 		jne .vk
  4735                              <1> 		mov [IPAppend],bl
  4736                              <1> .err:		ret
  4737                              <1> .vk:		mov [VKernelBuf+vk_ipappend],bl
  4738                              <1> 		ret
  4739                              <1> %endif
  4740                              <1> 
  4741                              <1> ;
  4742                              <1> ; "localboot" command (PXELINUX, ISOLINUX)
  4743                              <1> ;
  4744                              <1> %if IS_PXELINUX || IS_ISOLINUX
  4745                              <1> pc_localboot:	call getint
  4746                              <1> 		cmp word [VKernelCtr],byte 0	; ("label" section only)
  4747                              <1> 		je .err
  4748                              <1> 		mov [VKernelBuf+vk_rname], byte 0	; Null kernel name
  4749                              <1> 		mov [VKernelBuf+vk_rname+1], bx	; Return type
  4750                              <1> .err:		ret
  4751                              <1> %endif
  4752                              <1> 
  4753                              <1> ;
  4754                              <1> ; "kernel" command
  4755 000015F0 833E[E821]00        <1> pc_kernel:	cmp word [VKernelCtr],byte 0
  4756 000015F5 7409                <1> 		je .err				; ("label" section only)
  4757 000015F7 E82A01              <1> 		call pc_getline
  4758 000015FA BF0B50              <1> 		mov di,VKernelBuf+vk_rname
  4759 000015FD E8F2FA              <1> 		call mangle_name
  4760 00001600 C3                  <1> .err:		ret
  4761                              <1> 
  4762                              <1> ;
  4763                              <1> ; "timeout" command
  4764                              <1> ;
  4765 00001601 E830FC              <1> pc_timeout:	call getint
  4766 00001604 720B                <1> 		jc .err
  4767 00001606 B815D2              <1> 		mov ax,0D215h			; There are approx 1.D215h
  4768 00001609 F7E3                <1> 		mul bx				; clock ticks per 1/10 s
  4769 0000160B 01D3                <1> 		add bx,dx
  4770 0000160D 891E[E221]          <1> 		mov [KbdTimeOut],bx
  4771 00001611 C3                  <1> .err:		ret
  4772                              <1> 
  4773                              <1> ;
  4774                              <1> ; Generic integer variable setting commands:
  4775                              <1> ; "prompt", "implicit"
  4776                              <1> ;
  4777                              <1> pc_setint16:
  4778 00001612 50                  <1> 		push ax
  4779 00001613 E81EFC              <1> 		call getint
  4780 00001616 5E                  <1> 		pop si
  4781 00001617 7202                <1> 		jc .err
  4782 00001619 891C                <1> 		mov [si],bx
  4783 0000161B C3                  <1> .err:		ret
  4784                              <1> 
  4785                              <1> ;
  4786                              <1> ; Generic file-processing commands:
  4787                              <1> ; "display", "font", "kbdmap"
  4788                              <1> ;
  4789 0000161C 50                  <1> pc_filecmd:	push ax				; Function to tailcall
  4790 0000161D E80401              <1> 		call pc_getline
  4791 00001620 BFCF57              <1> 		mov di,MNameBuf
  4792 00001623 57                  <1> 		push di
  4793 00001624 E8CBFA              <1> 		call mangle_name
  4794 00001627 5F                  <1> 		pop di
  4795 00001628 E826FA              <1> 		call searchdir			; tailcall
  4796 0000162B 7501                <1> 		jnz .ok
  4797 0000162D 58                  <1> 		pop ax				; Drop the successor function
  4798 0000162E C3                  <1> .ok:		ret				; Tailcall if OK, error return
  4799                              <1> 
  4800                              <1> ;
  4801                              <1> ; "serial" command
  4802                              <1> ;
  4803 0000162F E802FC              <1> pc_serial:	call getint
  4804 00001632 7207                <1> 		jc .err
  4805 00001634 53                  <1> 		push bx				; Serial port #
  4806 00001635 E8E3FB              <1> 		call skipspace
  4807 00001638 7302                <1> 		jnc .ok
  4808 0000163A 5B                  <1> 		pop bx
  4809 0000163B C3                  <1> .err:		ret
  4810                              <1> .ok:
  4811 0000163C E8CBFB              <1> 		call ungetc
  4812 0000163F E8F2FB              <1> 		call getint
  4813 00001642 C706C4570000        <1> 		mov [FlowControl], word 0	; Default to no flow control
  4814 00001648 7229                <1> 		jc .nobaud
  4815                              <1> .valid_baud:	
  4816 0000164A 6653                <1> 		push ebx
  4817 0000164C E8CCFB              <1> 		call skipspace
  4818 0000164F 7208                <1> 		jc .no_flow
  4819 00001651 E8B6FB              <1> 		call ungetc
  4820 00001654 E8DDFB              <1> 		call getint			; Hardware flow control?
  4821 00001657 7302                <1> 		jnc .valid_flow
  4822                              <1> .no_flow:
  4823 00001659 31DB                <1> 		xor bx,bx			; Default -> no flow control
  4824                              <1> .valid_flow:
  4825 0000165B 80E70F              <1> 		and bh,0Fh			; FlowIgnore
  4826 0000165E C0E704              <1> 		shl bh,4
  4827 00001661 883EC657            <1> 		mov [FlowIgnore],bh
  4828 00001665 88DF                <1> 		mov bh,bl
  4829 00001667 81E303F0            <1> 		and bx,0F003h			; Valid bits
  4830 0000166B 891EC457            <1> 		mov [FlowControl],bx
  4831 0000166F 665B                <1> 		pop ebx				; Baud rate
  4832 00001671 EB06                <1> 		jmp short .parse_baud
  4833                              <1> .nobaud:
  4834 00001673 66BB80250000        <1> 		mov ebx,DEFAULT_BAUD		; No baud rate given
  4835                              <1> .parse_baud:
  4836 00001679 5F                  <1> 		pop di				; Serial port #
  4837 0000167A 6683FB4B            <1> 		cmp ebx,byte 75
  4838 0000167E 72BB                <1> 		jb .err				; < 75 baud == bogus
  4839 00001680 66B800C20100        <1> 		mov eax,BAUD_DIVISOR
  4840 00001686 6699                <1> 		cdq
  4841 00001688 66F7F3              <1> 		div ebx
  4842 0000168B A3C257              <1> 		mov [BaudDivisor],ax
  4843 0000168E 50                  <1> 		push ax				; Baud rate divisor
  4844 0000168F 83FF03              <1> 		cmp di,3
  4845 00001692 7706                <1> 		ja .port_is_io			; If port > 3 then port is I/O addr
  4846 00001694 D1E7                <1> 		shl di,1
  4847 00001696 8BBD0004            <1> 		mov di,[di+serial_base]		; Get the I/O port from the BIOS
  4848                              <1> .port_is_io:
  4849 0000169A 893E[F021]          <1> 		mov [SerialPort],di
  4850 0000169E 8D5503              <1> 		lea dx,[di+3]			; DX -> LCR
  4851 000016A1 B083                <1> 		mov al,83h			; Enable DLAB
  4852 000016A3 E8D801              <1> 		call slow_out
  4853 000016A6 58                  <1> 		pop ax				; Divisor
  4854 000016A7 89FA                <1> 		mov dx,di			; DX -> LS
  4855 000016A9 E8D201              <1> 		call slow_out
  4856 000016AC 42                  <1> 		inc dx				; DX -> MS
  4857 000016AD 88E0                <1> 		mov al,ah
  4858 000016AF E8CC01              <1> 		call slow_out
  4859 000016B2 B003                <1> 		mov al,03h			; Disable DLAB
  4860 000016B4 83C202              <1> 		add dx,byte 2			; DX -> LCR
  4861 000016B7 E8C401              <1> 		call slow_out
  4862 000016BA EC                  <1> 		in al,dx			; Read back LCR (detect missing hw)
  4863 000016BB 3C03                <1> 		cmp al,03h			; If nothing here we'll read 00 or FF
  4864 000016BD 7520                <1> 		jne .serial_port_bad		; Assume serial port busted
  4865 000016BF 83EA02              <1> 		sub dx,byte 2			; DX -> IER
  4866 000016C2 30C0                <1> 		xor al,al			; IRQ disable
  4867 000016C4 E8B701              <1> 		call slow_out
  4868                              <1> 
  4869 000016C7 83C203              <1> 		add dx,byte 3			; DX -> MCR
  4870 000016CA EC                  <1> 		in al,dx
  4871 000016CB 0A06C457            <1> 		or al,[FlowOutput]		; Assert bits
  4872 000016CF E8AC01              <1> 		call slow_out
  4873                              <1> 
  4874                              <1> 		; Show some life
  4875 000016D2 BE[0002]            <1> 		mov si,syslinux_banner
  4876 000016D5 E83CFE              <1> 		call write_serial_str
  4877 000016D8 BE[DF1D]            <1> 		mov si,copyright_str
  4878 000016DB E836FE              <1> 		call write_serial_str
  4879 000016DE C3                  <1> 		ret
  4880                              <1> 
  4881                              <1> .serial_port_bad:
  4882 000016DF C706[F021]0000      <1> 		mov [SerialPort], word 0
  4883 000016E5 C3                  <1> 		ret
  4884                              <1> 
  4885                              <1> ;
  4886                              <1> ; "F"-key command
  4887                              <1> ;
  4888 000016E6 50                  <1> pc_fkey:	push ax
  4889 000016E7 E83A00              <1> 		call pc_getline
  4890 000016EA 5F                  <1> 		pop di
  4891 000016EB E804FA              <1> 		call mangle_name		; Mangle file name
  4892 000016EE C3                  <1> 		ret
  4893                              <1> 
  4894                              <1> ;
  4895                              <1> ; "label" command
  4896                              <1> ;
  4897 000016EF E84300              <1> pc_label:	call commit_vk			; Commit any current vkernel
  4898 000016F2 E82F00              <1> 		call pc_getline
  4899 000016F5 BF0050              <1> 		mov di,VKernelBuf+vk_vname
  4900 000016F8 E8F7F9              <1> 		call mangle_name		; Mangle virtual name
  4901 000016FB FF06[E821]          <1> 		inc word [VKernelCtr]		; One more vkernel
  4902 000016FF BE0050              <1> 		mov si,VKernelBuf+vk_vname 	; By default, rname == vname
  4903 00001702 BF0B50              <1> 		mov di,VKernelBuf+vk_rname
  4904 00001705 B90B00              <1> 		mov cx,FILENAME_MAX
  4905 00001708 F3A4                <1> 		rep movsb
  4906 0000170A BE0052              <1>                 mov si,AppendBuf         	; Default append==global append
  4907 0000170D BF1850              <1>                 mov di,VKernelBuf+vk_append
  4908 00001710 8B0E[DC21]          <1>                 mov cx,[AppendLen]
  4909 00001714 890E1650            <1>                 mov [VKernelBuf+vk_appendlen],cx
  4910 00001718 F3A4                <1>                 rep movsb
  4911                              <1> %if IS_PXELINUX					; PXELINUX only
  4912                              <1> 		mov al,[IPAppend]		; Default ipappend==global ipappend
  4913                              <1> 		mov [VKernelBuf+vk_ipappend],al
  4914                              <1> %endif
  4915 0000171A C3                  <1> 		ret
  4916                              <1> 
  4917                              <1> ;
  4918                              <1> ; "say" command
  4919                              <1> ;
  4920 0000171B E80600              <1> pc_say:		call pc_getline			; "say" command
  4921 0000171E E84BEA              <1> 		call writestr
  4922 00001721 E95AFE              <1> 		jmp crlf			; tailcall
  4923                              <1> 
  4924                              <1> ;
  4925                              <1> ; Comment line
  4926                              <1> ;
  4927                              <1> pc_comment	equ pc_getline			; Get a line and discard
  4928                              <1> 
  4929                              <1> ;
  4930                              <1> ; Common subroutine: load line into trackbuf; returns with SI -> trackbuf
  4931                              <1> ;
  4932 00001724 BF0010              <1> pc_getline:	mov di,trackbuf
  4933 00001727 57                  <1> 		push di
  4934 00001728 E8BDFB              <1> 		call getline
  4935 0000172B 30C0                <1> 		xor al,al
  4936 0000172D AA                  <1> 		stosb				; Null-terminate
  4937 0000172E 5E                  <1> 		pop si
  4938 0000172F C3                  <1> 		ret
  4939                              <1> 
  4940                              <1> ;
  4941                              <1> ; Main loop for configuration file parsing
  4942                              <1> ;
  4943                              <1> parse_config:
  4944 00001730 E83000              <1> 		call getcommand
  4945 00001733 73FB                <1>                 jnc parse_config		; If not EOF do it again
  4946                              <1> 		;
  4947                              <1> 		; The fall through to commit_vk to commit any final
  4948                              <1> 		; VKernel being read
  4949                              <1> 		;
  4950                              <1> ;
  4951                              <1> ; commit_vk: Store the current VKernelBuf into buffer segment
  4952                              <1> ;
  4953                              <1> commit_vk:
  4954 00001735 833E[E821]00        <1> 		cmp word [VKernelCtr],byte 0
  4955 0000173A 741F                <1> 		je cvk_ret			; No VKernel = return
  4956 0000173C 813E[E821]8000      <1> 		cmp word [VKernelCtr],max_vk	; Above limit?
  4957 00001742 7718                <1> 		ja cvk_overflow
  4958 00001744 8B3E[E821]          <1> 		mov di,[VKernelCtr]
  4959 00001748 4F                  <1> 		dec di
  4960 00001749 C1E709              <1> 		shl di,vk_shift
  4961 0000174C BE0050              <1> 		mov si,VKernelBuf
  4962 0000174F B98000              <1> 		mov cx,(vk_size >> 2)
  4963 00001752 06                  <1> 		push es
  4964 00001753 680020              <1> 		push word vk_seg
  4965 00001756 07                  <1> 		pop es
  4966 00001757 F366A5              <1> 		rep movsd			; Copy to buffer segment
  4967 0000175A 07                  <1> 		pop es
  4968 0000175B C3                  <1> cvk_ret:	ret
  4969 0000175C C706[E821]8000      <1> cvk_overflow:	mov word [VKernelCtr],max_vk	; No more than max_vk, please
  4970 00001762 C3                  <1> 		ret
  4971                                  %include "parsecmd.inc"		; Low-level config file handling
  4972                              <1> ;; $Id: parsecmd.inc,v 1.5 2002/10/24 17:31:45 hpa Exp $
  4973                              <1> ;; -----------------------------------------------------------------------
  4974                              <1> ;;   
  4975                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  4976                              <1> ;;
  4977                              <1> ;;   This program is free software; you can redistribute it and/or modify
  4978                              <1> ;;   it under the terms of the GNU General Public License as published by
  4979                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  4980                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  4981                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  4982                              <1> ;;
  4983                              <1> ;; -----------------------------------------------------------------------
  4984                              <1> 
  4985                              <1> ;;
  4986                              <1> ;; parsecmd.inc
  4987                              <1> ;;
  4988                              <1> ;; Command line parser code
  4989                              <1> ;;
  4990                              <1> 
  4991                              <1> ; -------------------------------------------------------------------------
  4992                              <1> ;  getcommand:	Get a keyword from the current "getc" file and match it
  4993                              <1> ;		against a list of keywords (keywd_table).  Each entry in
  4994                              <1> ;		that table should have the following form:
  4995                              <1> ;		<32 bit hash value> <16 bit handler offset>
  4996                              <1> ;
  4997                              <1> ;               The handler is called, and upon return this function
  4998                              <1> ;               returns with CF = 0.  On EOF, this function returns
  4999                              <1> ;		with CF = 1.
  5000                              <1> ; -------------------------------------------------------------------------
  5001                              <1> 
  5002                              <1> getcommand:
  5003                              <1> .find:
  5004 00001763 E8B5FA              <1> 		call skipspace		; Skip leading whitespace
  5005 00001766 7451                <1> 		jz .eof			; End of file
  5006 00001768 72F9                <1> 		jc .find		; End of line: try again
  5007 0000176A 3C30                <1> 		cmp al,'0'		; Skip comment line
  5008 0000176C 724D                <1> 		jb .skipline
  5009                              <1> 
  5010 0000176E 0C20                <1> 		or al,20h		; Convert to lower case
  5011 00001770 660FB6D8            <1> 		movzx ebx,al		; Hash for a one-char keyword
  5012                              <1> .read_loop:
  5013 00001774 6653                <1> 		push ebx
  5014 00001776 E84CFA              <1> 		call getc
  5015 00001779 665B                <1> 		pop ebx
  5016 0000177B 3C20                <1> 		cmp al,' '		; Whitespace
  5017 0000177D 760A                <1> 		jbe .done
  5018 0000177F 0C20                <1> 		or al,20h
  5019 00001781 66C1C305            <1> 		rol ebx,5
  5020 00001785 30C3                <1> 		xor bl,al
  5021 00001787 EBEB                <1> 		jmp short .read_loop
  5022 00001789 E87EFA              <1> .done:		call ungetc
  5023 0000178C E88CFA              <1> 		call skipspace
  5024 0000178F 7428                <1> 		jz .eof
  5025 00001791 7219                <1> 		jc .noparm
  5026 00001793 E874FA              <1> 		call ungetc		; Return nonwhitespace char to buf
  5027 00001796 BE[E820]            <1> 		mov si,keywd_table
  5028 00001799 B91B00              <1> 		mov cx,keywd_count
  5029                              <1> .table_search:
  5030 0000179C 66AD                <1> 		lodsd
  5031 0000179E 6639C3              <1> 		cmp ebx,eax
  5032 000017A1 7411                <1> 		je .found_keywd
  5033 000017A3 66AD                <1> 		lodsd			; Skip entrypoint/argument
  5034 000017A5 E2F5                <1> 		loop .table_search
  5035                              <1> 
  5036                              <1> 		; Otherwise unrecognized keyword
  5037 000017A7 BE[321F]            <1> 		mov si,err_badcfg
  5038 000017AA EB03                <1> 		jmp short .error
  5039                              <1> 
  5040                              <1> 		; No parameter
  5041                              <1> .noparm:
  5042 000017AC BE[551F]            <1> 		mov si,err_noparm
  5043                              <1> .error:
  5044 000017AF E8CFFD              <1> 		call cwritestr
  5045 000017B2 EBAF                <1> 		jmp short .find
  5046                              <1> 
  5047 000017B4 AD                  <1> .found_keywd:	lodsw			; Load argument into ax
  5048 000017B5 FF14                <1> 		call [si]
  5049 000017B7 F8                  <1> 		clc
  5050 000017B8 C3                  <1> 		ret
  5051                              <1> 
  5052 000017B9 F9                  <1> .eof:		stc
  5053 000017BA C3                  <1> 		ret
  5054                              <1> 
  5055 000017BB 3C0A                <1> .skipline:	cmp al,10		; Search for LF
  5056 000017BD 74A4                <1> 		je .find
  5057 000017BF E803FA              <1> 		call getc
  5058 000017C2 72F5                <1> 		jc .eof
  5059 000017C4 EBF5                <1> 		jmp short .skipline
  5060                                  %include "bcopy32.inc"		; 32-bit bcopy
  5061                              <1> ;; $Id: bcopy32.inc,v 1.7 2003/11/18 23:54:43 hpa Exp $
  5062                              <1> ;; -----------------------------------------------------------------------
  5063                              <1> ;;   
  5064                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  5065                              <1> ;;
  5066                              <1> ;;   This program is free software; you can redistribute it and/or modify
  5067                              <1> ;;   it under the terms of the GNU General Public License as published by
  5068                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  5069                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  5070                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  5071                              <1> ;;
  5072                              <1> ;; -----------------------------------------------------------------------
  5073                              <1> 
  5074                              <1> ;;
  5075                              <1> ;; bcopy32.inc
  5076                              <1> ;; 
  5077                              <1> ;; 32-bit bcopy routine for real mode
  5078                              <1> ;;
  5079                              <1> 
  5080                              <1> ;
  5081                              <1> ; 32-bit bcopy routine for real mode
  5082                              <1> ;
  5083                              <1> ; We enter protected mode, set up a flat 32-bit environment, run rep movsd
  5084                              <1> ; and then exit.  IMPORTANT: This code assumes cs == 0.
  5085                              <1> ;
  5086                              <1> ; This code is probably excessively anal-retentive in its handling of
  5087                              <1> ; segments, but this stuff is painful enough as it is without having to rely
  5088                              <1> ; on everything happening "as it ought to."
  5089                              <1> ;
  5090                              <1> ; IMPORTANT: This code must be capable of operating when copied to the
  5091                              <1> ; trackbuf area (1000h).  The routine bcopy_over_self handles this mode
  5092                              <1> ; of operation, including any necessary adjustments.
  5093                              <1> ;
  5094 000017C6 90<rept>            <1> 		align 4
  5095                              <1> __bcopy_start:
  5096                              <1> 
  5097 000017C8 2F00                <1> bcopy_gdt:	dw bcopy_gdt_size-1	; Null descriptor - contains GDT
  5098 000017CA [C8170000]          <1> .adj1:		dd bcopy_gdt		; pointer for LGDT instruction
  5099 000017CE 0000                <1> 		dw 0
  5100 000017D0 FFFF0000            <1> 		dd 0000ffffh		; Code segment, use16, readable,
  5101 000017D4 009B0000            <1> 		dd 00009b00h		; present, dpl 0, cover 64K
  5102 000017D8 FFFF0000            <1> 		dd 0000ffffh		; Data segment, use16, read/write,
  5103 000017DC 00938F00            <1> 		dd 008f9300h		; present, dpl 0, cover all 4G
  5104 000017E0 FFFF0000            <1> 		dd 0000ffffh		; Data segment, use16, read/write,
  5105 000017E4 00930000            <1> 		dd 00009300h		; present, dpl 0, cover 64K
  5106                              <1> 		; The rest are used for COM32 only
  5107 000017E8 FFFF0000            <1> 		dd 0000ffffh		; Code segment, use32, readable,
  5108 000017EC 009BCF00            <1> 		dd 00cf9b00h		; present, dpl 0, cover all 4G
  5109 000017F0 FFFF0000            <1> 		dd 0000ffffh		; Data segment, use32, read/write,
  5110 000017F4 0093CF00            <1> 		dd 00cf9300h		; present, dpl 0, cover all 4G
  5111                              <1> bcopy_gdt_size:	equ $-bcopy_gdt
  5112                              <1> 
  5113                              <1> ;
  5114                              <1> ; bcopy:
  5115                              <1> ;	32-bit copy
  5116                              <1> ;
  5117                              <1> ; Inputs:
  5118                              <1> ;	ESI	- source pointer
  5119                              <1> ;	EDI	- target pointer
  5120                              <1> ;	ECX	- byte count
  5121                              <1> ;	DF	- zero
  5122                              <1> ;
  5123                              <1> ; Outputs:
  5124                              <1> ;	ESI	- first byte after source
  5125                              <1> ;	EDI	- first byte after target
  5126                              <1> ;	ECX	- zero
  5127                              <1> ;
  5128 000017F8 6650                <1> bcopy:		push eax
  5129 000017FA 9C                  <1> 		pushf			; Saves, among others, the IF flag
  5130 000017FB 0FA8                <1> 		push gs
  5131 000017FD 0FA0                <1> 		push fs
  5132 000017FF 1E                  <1> 		push ds
  5133 00001800 06                  <1> 		push es
  5134 00001801 2E89266C57          <1> 		mov [cs:SavedSSSP],sp
  5135 00001806 2E8C166E57          <1> 		mov [cs:SavedSSSP+2],ss
  5136                              <1> 
  5137 0000180B FA                  <1> 		cli
  5138 0000180C E87500              <1> 		call enable_a20
  5139                              <1> 
  5140 0000180F 662E0F0116[C817]    <1> .adj2:		o32 lgdt [cs:bcopy_gdt]
  5141 00001816 0F20C0              <1> 		mov eax,cr0
  5142 00001819 0C01                <1> 		or al,1
  5143 0000181B 0F22C0              <1> 		mov cr0,eax		; Enter protected mode
  5144 0000181E EA[2318]0800        <1> .adj3a:		jmp 08h:.in_pm
  5145                              <1> 
  5146 00001823 B81000              <1> .in_pm:		mov ax,10h		; Data segment selector
  5147 00001826 8EC0                <1> 		mov es,ax
  5148 00001828 8ED8                <1> 		mov ds,ax
  5149                              <1> 
  5150 0000182A B018                <1> 		mov al,18h		; "Real-mode-like" data segment
  5151 0000182C 8ED0                <1> 		mov ss,ax
  5152 0000182E 8EE0                <1> 		mov fs,ax
  5153 00001830 8EE8                <1> 		mov gs,ax	
  5154                              <1> 
  5155 00001832 88C8                <1> 		mov al,cl		; Save low bits
  5156 00001834 66C1E902            <1> 		shr ecx,2		; Convert to dwords
  5157 00001838 67F366A5            <1> 		a32 rep movsd		; Do our business
  5158                              <1> 		; At this point ecx == 0
  5159                              <1> 
  5160 0000183C 88C1                <1> 		mov cl,al		; Copy any fractional dword
  5161 0000183E 80E103              <1> 		and cl,3
  5162 00001841 67F3A4              <1> 		a32 rep movsb
  5163                              <1> 
  5164 00001844 B018                <1> 		mov al,18h		; "Real-mode-like" data segment
  5165 00001846 8EC0                <1> 		mov es,ax
  5166 00001848 8ED8                <1> 		mov ds,ax
  5167                              <1> 
  5168 0000184A 0F20C0              <1> 		mov eax,cr0
  5169 0000184D 24FE                <1> 		and al,~1
  5170 0000184F 0F22C0              <1> 		mov cr0,eax		; Disable protected mode
  5171 00001852 EA[5718]0000        <1> .adj3b:		jmp 0:.in_rm
  5172                              <1> 
  5173                              <1> .in_rm:		; Back in real mode
  5174 00001857 2E0FB2266C57        <1> 		lss sp,[cs:SavedSSSP]
  5175 0000185D 07                  <1> 		pop es
  5176 0000185E 1F                  <1> 		pop ds
  5177 0000185F 0FA1                <1> 		pop fs
  5178 00001861 0FA9                <1> 		pop gs
  5179 00001863 E8C100              <1> 		call disable_a20
  5180                              <1> 
  5181 00001866 9D                  <1> 		popf			; Re-enables interrupts
  5182 00001867 6658                <1> 		pop eax
  5183 00001869 C3                  <1> 		ret
  5184                              <1> 
  5185                              <1> ;
  5186                              <1> ; Routines to enable and disable (yuck) A20.  These routines are gathered
  5187                              <1> ; from tips from a couple of sources, including the Linux kernel and
  5188                              <1> ; http://www.x86.org/.  The need for the delay to be as large as given here
  5189                              <1> ; is indicated by Donnie Barnes of RedHat, the problematic system being an
  5190                              <1> ; IBM ThinkPad 760EL.
  5191                              <1> ;
  5192                              <1> ; We typically toggle A20 twice for every 64K transferred.
  5193                              <1> ; 
  5194                              <1> %define	io_delay	call _io_delay
  5195                              <1> %define IO_DELAY_PORT	80h		; Invalid port (we hope!)
  5196                              <1> %define disable_wait 	32		; How long to wait for a disable
  5197                              <1> 
  5198                              <1> %define A20_DUNNO	0		; A20 type unknown
  5199                              <1> %define A20_NONE	1		; A20 always on?
  5200                              <1> %define A20_BIOS	2		; A20 BIOS enable
  5201                              <1> %define A20_KBC		3		; A20 through KBC
  5202                              <1> %define A20_FAST	4		; A20 through port 92h
  5203                              <1> 
  5204                              <1> 		align 2
  5205 0000186A [9818][9818][A318]- <1> A20List		dw a20_dunno, a20_none, a20_bios, a20_kbc, a20_fast
  5206 00001870 [B518][DB18]        <1>
  5207 00001874 [6319][6319][3519]- <1> A20DList	dw a20d_dunno, a20d_none, a20d_bios, a20d_kbc, a20d_fast
  5208 0000187A [4619][3E19]        <1>
  5209                              <1> a20_adjust_cnt	equ ($-A20List)/2
  5210                              <1> 
  5211 0000187E EE                  <1> slow_out:	out dx, al		; Fall through
  5212                              <1> 
  5213 0000187F E680                <1> _io_delay:	out IO_DELAY_PORT,al
  5214 00001881 E680                <1> 		out IO_DELAY_PORT,al
  5215 00001883 C3                  <1> 		ret
  5216                              <1> 
  5217                              <1> enable_a20:
  5218 00001884 6660                <1> 		pushad
  5219 00001886 2EC606CB57FF        <1> 		mov byte [cs:A20Tries],255 ; Times to try to make this work
  5220                              <1> 
  5221                              <1> try_enable_a20:
  5222                              <1> ;
  5223                              <1> ; Flush the caches
  5224                              <1> ;
  5225                              <1> %if DO_WBINVD
  5226                              <1> 		call try_wbinvd
  5227                              <1> %endif
  5228                              <1> 
  5229                              <1> ;
  5230                              <1> ; If the A20 type is known, jump straight to type
  5231                              <1> ;
  5232 0000188C 2E8B2EB057          <1> 		mov bp,[cs:A20Type]
  5233 00001891 01ED                <1> 		add bp,bp			; Convert to word offset
  5234 00001893 2EFFA6[6A18]        <1> .adj4:		jmp word [cs:bp+A20List]
  5235                              <1> 
  5236                              <1> ;
  5237                              <1> ; First, see if we are on a system with no A20 gate
  5238                              <1> ;
  5239                              <1> a20_dunno:
  5240                              <1> a20_none:
  5241 00001898 2EC606B05701        <1> 		mov byte [cs:A20Type], A20_NONE
  5242 0000189E E86400              <1> 		call a20_test
  5243 000018A1 755F                <1> 		jnz a20_done
  5244                              <1> 
  5245                              <1> ;
  5246                              <1> ; Next, try the BIOS (INT 15h AX=2401h)
  5247                              <1> ;
  5248                              <1> a20_bios:
  5249 000018A3 2EC606B05702        <1> 		mov byte [cs:A20Type], A20_BIOS
  5250 000018A9 B80124              <1> 		mov ax,2401h
  5251 000018AC 9C                  <1> 		pushf				; Some BIOSes muck with IF
  5252 000018AD CD15                <1> 		int 15h
  5253 000018AF 9D                  <1> 		popf
  5254                              <1> 
  5255 000018B0 E85200              <1> 		call a20_test
  5256 000018B3 754D                <1> 		jnz a20_done
  5257                              <1> 
  5258                              <1> ;
  5259                              <1> ; Enable the keyboard controller A20 gate
  5260                              <1> ;
  5261                              <1> a20_kbc:
  5262 000018B5 B201                <1> 		mov dl, 1			; Allow early exit
  5263 000018B7 E8AE00              <1> 		call empty_8042
  5264 000018BA 7546                <1> 		jnz a20_done			; A20 live, no need to use KBC
  5265                              <1> 
  5266 000018BC 2EC606B05703        <1> 		mov byte [cs:A20Type], A20_KBC	; Starting KBC command sequence
  5267                              <1> 
  5268 000018C2 B0D1                <1> 		mov al,0D1h			; Command write
  5269 000018C4 E664                <1> 		out 064h, al
  5270 000018C6 E89D00              <1> 		call empty_8042_uncond
  5271                              <1> 
  5272 000018C9 B0DF                <1> 		mov al,0DFh			; A20 on
  5273 000018CB E660                <1> 		out 060h, al
  5274 000018CD E89600              <1> 		call empty_8042_uncond
  5275                              <1> 
  5276                              <1> 		; Verify that A20 actually is enabled.  Do that by
  5277                              <1> 		; observing a word in low memory and the same word in
  5278                              <1> 		; the HMA until they are no longer coherent.  Note that
  5279                              <1> 		; we don't do the same check in the disable case, because
  5280                              <1> 		; we don't want to *require* A20 masking (SYSLINUX should
  5281                              <1> 		; work fine without it, if the BIOS does.)
  5282 000018D0 51                  <1> .kbc_wait:	push cx
  5283 000018D1 31C9                <1> 		xor cx,cx
  5284                              <1> .kbc_wait_loop:
  5285 000018D3 E82F00              <1> 		call a20_test
  5286 000018D6 7529                <1> 		jnz a20_done_pop
  5287 000018D8 E2F9                <1> 		loop .kbc_wait_loop
  5288                              <1> 
  5289 000018DA 59                  <1> 		pop cx
  5290                              <1> ;
  5291                              <1> ; Running out of options here.  Final attempt: enable the "fast A20 gate"
  5292                              <1> ;
  5293                              <1> a20_fast:
  5294 000018DB 2EC606B05704        <1> 		mov byte [cs:A20Type], A20_FAST	; Haven't used the KBC yet
  5295 000018E1 E492                <1> 		in al, 092h
  5296 000018E3 0C02                <1> 		or al,02h
  5297 000018E5 24FE                <1> 		and al,~01h			; Don't accidentally reset the machine!
  5298 000018E7 E692                <1> 		out 092h, al
  5299                              <1> 
  5300 000018E9 51                  <1> .fast_wait:	push cx
  5301 000018EA 31C9                <1> 		xor cx,cx
  5302                              <1> .fast_wait_loop:
  5303 000018EC E81600              <1> 		call a20_test
  5304 000018EF 7510                <1> 		jnz a20_done_pop
  5305 000018F1 E2F9                <1> 		loop .fast_wait_loop
  5306                              <1> 
  5307 000018F3 59                  <1> 		pop cx
  5308                              <1> 
  5309                              <1> ;
  5310                              <1> ; Oh bugger.  A20 is not responding.  Try frobbing it again; eventually give up
  5311                              <1> ; and report failure to the user.
  5312                              <1> ;
  5313                              <1> 
  5314                              <1> 
  5315 000018F4 2EFE0ECB57          <1> 		dec byte [cs:A20Tries]
  5316 000018F9 7591                <1> 		jnz try_enable_a20
  5317                              <1> 
  5318 000018FB BE[5120]            <1> 		mov si, err_a20
  5319 000018FE E93BF7              <1> 		jmp abort_load
  5320                              <1> ;
  5321                              <1> ; A20 unmasked, proceed...
  5322                              <1> ;
  5323 00001901 59                  <1> a20_done_pop:	pop cx
  5324 00001902 6661                <1> a20_done:	popad
  5325 00001904 C3                  <1> 		ret
  5326                              <1> 
  5327                              <1> ;
  5328                              <1> ; This routine tests if A20 is enabled (ZF = 0).  This routine
  5329                              <1> ; must not destroy any register contents.
  5330                              <1> ;
  5331                              <1> a20_test:
  5332 00001905 06                  <1> 		push es
  5333 00001906 51                  <1> 		push cx
  5334 00001907 50                  <1> 		push ax
  5335 00001908 B9FFFF              <1> 		mov cx,0FFFFh		; HMA = segment 0FFFFh
  5336 0000190B 8EC1                <1> 		mov es,cx
  5337 0000190D B92000              <1> 		mov cx,32		; Loop count
  5338 00001910 2EA1AE57            <1> 		mov ax,[cs:A20Test]
  5339 00001914 40                  <1> .a20_wait:	inc ax
  5340 00001915 2EA3AE57            <1> 		mov [cs:A20Test],ax
  5341 00001919 E863FF              <1> 		io_delay		; Serialize, and fix delay
  5342 0000191C 263B06BE57          <1> 		cmp ax,[es:A20Test+10h]
  5343 00001921 E1F1                <1> 		loopz .a20_wait
  5344 00001923 58                  <1> .a20_done:	pop ax
  5345 00001924 59                  <1> 		pop cx
  5346 00001925 07                  <1> 		pop es
  5347 00001926 C3                  <1> 		ret
  5348                              <1> 
  5349                              <1> disable_a20:
  5350 00001927 6660                <1> 		pushad
  5351                              <1> ;
  5352                              <1> ; Flush the caches
  5353                              <1> ;
  5354                              <1> %if DO_WBINVD
  5355                              <1> 		call try_wbinvd
  5356                              <1> %endif
  5357                              <1> 
  5358 00001929 2E8B2EB057          <1> 		mov bp,[cs:A20Type]
  5359 0000192E 01ED                <1> 		add bp,bp			; Convert to word offset
  5360 00001930 2EFFA6[7418]        <1> .adj5:		jmp word [cs:bp+A20DList]
  5361                              <1> 
  5362                              <1> a20d_bios:
  5363 00001935 B80024              <1> 		mov ax,2400h
  5364 00001938 9C                  <1> 		pushf				; Some BIOSes muck with IF
  5365 00001939 CD15                <1> 		int 15h
  5366 0000193B 9D                  <1> 		popf
  5367 0000193C EB19                <1> 		jmp short a20d_snooze
  5368                              <1> 
  5369                              <1> ;
  5370                              <1> ; Disable the "fast A20 gate"
  5371                              <1> ;
  5372                              <1> a20d_fast:
  5373 0000193E E492                <1> 		in al, 092h
  5374 00001940 24FC                <1> 		and al,~03h
  5375 00001942 E692                <1> 		out 092h, al
  5376 00001944 EB11                <1> 		jmp short a20d_snooze
  5377                              <1> 
  5378                              <1> ;
  5379                              <1> ; Disable the keyboard controller A20 gate
  5380                              <1> ;
  5381                              <1> a20d_kbc:
  5382 00001946 E81D00              <1> 		call empty_8042_uncond
  5383 00001949 B0D1                <1> 		mov al,0D1h
  5384 0000194B E664                <1> 		out 064h, al		; Command write
  5385 0000194D E81600              <1> 		call empty_8042_uncond
  5386 00001950 B0DD                <1> 		mov al,0DDh		; A20 off
  5387 00001952 E660                <1> 		out 060h, al
  5388 00001954 E80F00              <1> 		call empty_8042_uncond
  5389                              <1> 		; Wait a bit for it to take effect
  5390                              <1> a20d_snooze:
  5391 00001957 51                  <1> 		push cx
  5392 00001958 B92000              <1> 		mov cx, disable_wait
  5393 0000195B E8A7FF              <1> .delayloop:	call a20_test
  5394 0000195E 7402                <1> 		jz .disabled
  5395 00001960 E2F9                <1> 		loop .delayloop
  5396 00001962 59                  <1> .disabled:	pop cx
  5397                              <1> a20d_dunno:
  5398                              <1> a20d_none:
  5399 00001963 6661                <1> 		popad
  5400 00001965 C3                  <1> 		ret
  5401                              <1> 
  5402                              <1> ;
  5403                              <1> ; Routine to empty the 8042 KBC controller.  If dl != 0
  5404                              <1> ; then we will test A20 in the loop and exit if A20 is
  5405                              <1> ; suddenly enabled.
  5406                              <1> ;
  5407                              <1> empty_8042_uncond:
  5408 00001966 30D2                <1> 		xor dl,dl
  5409                              <1> empty_8042:
  5410 00001968 E89AFF              <1> 		call a20_test
  5411 0000196B 7404                <1> 		jz .a20_on
  5412 0000196D 20D2                <1> 		and dl,dl
  5413 0000196F 7517                <1> 		jnz .done
  5414 00001971 E80BFF              <1> .a20_on:	io_delay
  5415 00001974 E464                <1> 		in al, 064h		; Status port
  5416 00001976 A801                <1> 		test al,1
  5417 00001978 7407                <1> 		jz .no_output
  5418 0000197A E802FF              <1> 		io_delay
  5419 0000197D E460                <1> 		in al, 060h		; Read input
  5420 0000197F EBE7                <1> 		jmp short empty_8042
  5421                              <1> .no_output:
  5422 00001981 A802                <1> 		test al,2
  5423 00001983 75E3                <1> 		jnz empty_8042
  5424 00001985 E8F7FE              <1> 		io_delay
  5425 00001988 C3                  <1> .done:		ret	
  5426                              <1> 
  5427                              <1> ;
  5428                              <1> ; Execute a WBINVD instruction if possible on this CPU
  5429                              <1> ;
  5430                              <1> %if DO_WBINVD
  5431                              <1> try_wbinvd:
  5432                              <1> 		wbinvd
  5433                              <1> 		ret
  5434                              <1> %endif
  5435                              <1> 
  5436                              <1> ;
  5437                              <1> ; bcopy_over_self:
  5438                              <1> ;
  5439                              <1> ; This routine is used to copy large blocks of code on top of
  5440                              <1> ; conventional memory (to 0:7c00).  We therefore have to move
  5441                              <1> ; necessary code into the trackbuf area before doing the copy,
  5442                              <1> ; and do adjustments to anything except BSS area references.
  5443                              <1> ;
  5444                              <1> ; After performing the copy, this routine resets the stack and
  5445                              <1> ; jumps to 0:7c00.
  5446                              <1> ;
  5447                              <1> ; IMPORTANT: This routine does not canonicalize the stack or the
  5448                              <1> ; SS register.  That is the responsibility of the caller.
  5449                              <1> ;
  5450                              <1> ; Inputs:
  5451                              <1> ;	ESI, EDI, ECX	- same as bcopy
  5452                              <1> ;	On stack	- initial state (fd, ad, ds, es, fs, gs)
  5453                              <1> ;
  5454                              <1> %define ADJUST	(__bcopy_start - trackbuf)
  5455                              <1> 
  5456 00001989 90                  <1> 		align 2
  5457 0000198A 0210                <1> adjlist		dw bcopy_gdt.adj1 - ADJUST
  5458 0000198C 4C10                <1> 		dw bcopy.adj2 + 5 - ADJUST
  5459 0000198E 5710                <1> 		dw bcopy.adj3a + 1 - ADJUST
  5460 00001990 8B10                <1> 		dw bcopy.adj3b + 1 - ADJUST
  5461 00001992 CE10                <1> 		dw try_enable_a20.adj4 + 3 - ADJUST
  5462 00001994 6B11                <1> 		dw disable_a20.adj5 + 3 - ADJUST
  5463                              <1> adjlist_cnt	equ ($-adjlist)/2
  5464                              <1> 
  5465                              <1> bcopy_over_self:
  5466 00001996 6656                <1> 		push esi	
  5467 00001998 6657                <1> 		push edi
  5468 0000199A 6651                <1> 		push ecx
  5469                              <1> 
  5470 0000199C 31DB                <1> 		xor bx,bx
  5471 0000199E 8EC3                <1> 		mov es,bx
  5472 000019A0 8EDB                <1> 		mov ds,bx
  5473                              <1> 
  5474 000019A2 BE[C817]            <1> 		mov si,__bcopy_start
  5475 000019A5 BF0010              <1> 		mov di,trackbuf
  5476 000019A8 B98800              <1> 		mov cx,(__bcopy_end - __bcopy_start + 3) >> 2
  5477 000019AB F366A5              <1> 		rep movsd
  5478                              <1> 
  5479 000019AE BEA210              <1> 		mov si,A20List - ADJUST
  5480 000019B1 B90A00              <1> 		mov cx,a20_adjust_cnt
  5481                              <1> .adjust1:
  5482 000019B4 812C[C807]          <1> 		sub word [si], ADJUST
  5483 000019B8 46                  <1> 		inc si
  5484 000019B9 46                  <1> 		inc si
  5485 000019BA E2F8                <1> 		loop .adjust1
  5486                              <1> 
  5487 000019BC BE[8A19]            <1> 		mov si, adjlist
  5488 000019BF B90600              <1> 		mov cx, adjlist_cnt
  5489                              <1> .adjust2:
  5490 000019C2 AD                  <1> 		lodsw
  5491 000019C3 97                  <1> 		xchg di,ax
  5492 000019C4 812D[C807]          <1> 		sub word [di], ADJUST
  5493 000019C8 E2F8                <1> 		loop .adjust2
  5494                              <1> 
  5495 000019CA E9(0512)            <1> 		jmp .next-ADJUST
  5496                              <1> .next:
  5497 000019CD 6659                <1> 		pop ecx
  5498 000019CF 665F                <1> 		pop edi
  5499 000019D1 665E                <1> 		pop esi
  5500 000019D3 E822FE              <1> 		call bcopy
  5501                              <1> 		
  5502 000019D6 0FA9                <1> 		pop gs
  5503 000019D8 0FA1                <1> 		pop fs
  5504 000019DA 07                  <1> 		pop es
  5505 000019DB 1F                  <1> 		pop ds
  5506 000019DC 6661                <1> 		popad
  5507 000019DE 669D                <1> 		popfd
  5508 000019E0 EA007C0000          <1> 		jmp 0:7c00h
  5509                              <1> __bcopy_end:
  5510                                  %include "loadhigh.inc"		; Load a file into high memory
  5511                              <1> ;; $Id: loadhigh.inc,v 1.3 2002/06/01 07:51:40 hpa Exp $
  5512                              <1> ;; -----------------------------------------------------------------------
  5513                              <1> ;;   
  5514                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  5515                              <1> ;;
  5516                              <1> ;;   This program is free software; you can redistribute it and/or modify
  5517                              <1> ;;   it under the terms of the GNU General Public License as published by
  5518                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  5519                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  5520                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  5521                              <1> ;;
  5522                              <1> ;; -----------------------------------------------------------------------
  5523                              <1> 
  5524                              <1> ;;
  5525                              <1> ;; loadhigh.inc
  5526                              <1> ;; 
  5527                              <1> ;; Load a file into high memory
  5528                              <1> ;;
  5529                              <1> 
  5530                              <1> ;
  5531                              <1> ; load_high:	loads (the remainder of) a file into high memory.
  5532                              <1> ;		This routine prints dots for each 64K transferred, and
  5533                              <1> ;		calls abort_check periodically.
  5534                              <1> ; 
  5535                              <1> ;		The xfer_buf_seg is used as a bounce buffer.
  5536                              <1> ;
  5537                              <1> ;		The input address (EDI) should be dword aligned, and the final
  5538                              <1> ;		dword written is padded with zeroes if necessary.
  5539                              <1> ;
  5540                              <1> ; Inputs:	SI  = file handle/cluster pointer
  5541                              <1> ;		EDI = target address in high memory
  5542                              <1> ;		EAX = size of remaining file in bytes
  5543                              <1> ;
  5544                              <1> ; Outputs:	SI  = file handle/cluster pointer
  5545                              <1> ;		EDI = first untouched address (not including padding)
  5546                              <1> ;
  5547                              <1> load_high:
  5548 000019E5 06                  <1> 		push es
  5549                              <1> 
  5550 000019E6 BB0010              <1> 		mov bx,xfer_buf_seg
  5551 000019E9 8EC3                <1> 		mov es,bx
  5552                              <1> 
  5553                              <1> .read_loop:
  5554 000019EB 21F6                <1> 		and si,si			; If SI == 0 then we have end of file
  5555 000019ED 7467                <1> 		jz .eof
  5556 000019EF 56                  <1> 		push si
  5557 000019F0 BE[C520]            <1> 		mov si,dot_msg
  5558 000019F3 E88BFB              <1> 		call cwritestr
  5559 000019F6 5E                  <1> 		pop si
  5560 000019F7 E82EF6              <1> 		call abort_check
  5561                              <1> 
  5562 000019FA 6650                <1> 		push eax			; <A> Total bytes to transfer
  5563 000019FC 663D00000100        <1> 		cmp eax,(1 << 16)		; Max 64K in one transfer
  5564 00001A02 7606                <1> 		jna .size_ok
  5565 00001A04 66B800000100        <1> 		mov eax,(1 << 16)
  5566                              <1> .size_ok:
  5567 00001A0A 6631D2              <1> 		xor edx,edx
  5568 00001A0D 6650                <1> 		push eax			; <B> Bytes transferred this chunk
  5569 00001A0F 66F7367857          <1> 		div dword [ClustSize]		; Convert to clusters
  5570                              <1> 		; Round up...
  5571 00001A14 6683C2FF            <1> 		add edx,byte -1			; Sets CF if EDX >= 1
  5572 00001A18 6683D000            <1> 		adc eax,byte 0			; Add 1 to EAX if CF set
  5573                              <1> 
  5574                              <1> 		; Now (e)ax contains the number of clusters to get
  5575 00001A1C 6657                <1> 		push edi			; <C> Target buffer
  5576 00001A1E 89C1                <1> 		mov cx,ax
  5577 00001A20 31DB                <1> 		xor bx,bx			; ES:0
  5578 00001A22 E8F0E8              <1> 		call getfssec			; Load the data into xfer_buf_seg
  5579 00001A25 665F                <1> 		pop edi				; <C> Target buffer
  5580 00001A27 6659                <1> 		pop ecx				; <B> Byte count this round
  5581 00001A29 6651                <1> 		push ecx			; <B> Byte count this round 
  5582 00001A2B 6657                <1> 		push edi			; <C> Target buffer
  5583                              <1> .fix_slop:
  5584 00001A2D F6C103              <1> 		test cl,3
  5585 00001A30 7409                <1> 		jz .noslop
  5586                              <1> 		; The last dword fractional - pad with zeroes
  5587                              <1> 		; Zero-padding is critical for multi-file initramfs.
  5588 00001A32 2667C60100          <1> 		mov byte [es:ecx],0
  5589 00001A37 6641                <1> 		inc ecx
  5590 00001A39 EBF2                <1> 		jmp short .fix_slop
  5591                              <1> .noslop:
  5592 00001A3B 6656                <1> 		push esi			; <D> File handle/cluster pointer
  5593 00001A3D 66BE00000100        <1> 		mov esi,(xfer_buf_seg << 4)	; Source address
  5594 00001A43 E8B2FD              <1> 		call bcopy			; Copy to high memory
  5595 00001A46 665E                <1> 		pop esi				; <D> File handle/cluster pointer
  5596 00001A48 665F                <1> 		pop edi				; <C> Target buffer
  5597 00001A4A 6659                <1> 		pop ecx				; <B> Byte count this round
  5598 00001A4C 6658                <1> 		pop eax				; <A> Total bytes to transfer
  5599 00001A4E 6601CF              <1> 		add edi,ecx
  5600 00001A51 6629C8              <1> 		sub eax,ecx
  5601 00001A54 7595                <1> 		jnz .read_loop			; More to read...
  5602                              <1> 		
  5603                              <1> .eof:
  5604 00001A56 07                  <1> 		pop es
  5605 00001A57 C3                  <1> 		ret
  5606                              <1> 
  5607                                  %include "font.inc"		; VGA font stuff
  5608                              <1> ;; $Id: font.inc,v 1.3 2004/02/03 06:16:03 hpa Exp $
  5609                              <1> ;; -----------------------------------------------------------------------
  5610                              <1> ;;   
  5611                              <1> ;;   Copyright 1994-2004 H. Peter Anvin - All Rights Reserved
  5612                              <1> ;;
  5613                              <1> ;;   This program is free software; you can redistribute it and/or modify
  5614                              <1> ;;   it under the terms of the GNU General Public License as published by
  5615                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  5616                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  5617                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  5618                              <1> ;;
  5619                              <1> ;; -----------------------------------------------------------------------
  5620                              <1> 
  5621                              <1> ;;
  5622                              <1> ;; font.inc
  5623                              <1> ;;
  5624                              <1> ;; VGA font handling code
  5625                              <1> ;;
  5626                              <1> 
  5627                              <1> ;
  5628                              <1> ; loadfont:	Load a .psf font file and install it onto the VGA console
  5629                              <1> ;		(if we're not on a VGA screen then ignore.)  It is called with
  5630                              <1> ;		SI and DX:AX set by routine searchdir
  5631                              <1> ;
  5632                              <1> loadfont:
  5633 00001A58 BB0010              <1> 		mov bx,trackbuf			; The trackbuf is >= 16K; the part
  5634 00001A5B 8B0E9457            <1> 		mov cx,[BufSafe]		; of a PSF file we care about is no
  5635 00001A5F E8B3E8              <1> 		call getfssec			; more than 8K+4 bytes
  5636                              <1> 
  5637 00001A62 A10010              <1> 		mov ax,[trackbuf]		; Magic number
  5638 00001A65 3D3604              <1> 		cmp ax,0436h
  5639 00001A68 755B                <1> 		jne lf_ret
  5640                              <1> 
  5641 00001A6A A00210              <1> 		mov al,[trackbuf+2]		; File mode
  5642 00001A6D 3C05                <1> 		cmp al,5			; Font modes 0-5 supported
  5643 00001A6F 7754                <1> 		ja lf_ret
  5644                              <1> 
  5645 00001A71 8A3E0310            <1> 		mov bh,byte [trackbuf+3]	; Height of font
  5646 00001A75 80FF02              <1> 		cmp bh,2			; VGA minimum
  5647 00001A78 724B                <1> 		jb lf_ret
  5648 00001A7A 80FF20              <1> 		cmp bh,32			; VGA maximum
  5649 00001A7D 7746                <1> 		ja lf_ret
  5650                              <1> 
  5651                              <1> 		; Copy to font buffer
  5652 00001A7F BE0410              <1> 		mov si,trackbuf+4		; Start of font data
  5653 00001A82 883E[F221]          <1> 		mov [VGAFontSize],bh
  5654 00001A86 BF00E0              <1> 		mov di,vgafontbuf
  5655 00001A89 B90008              <1> 		mov cx,(32*256) >> 2		; Maximum size
  5656 00001A8C F366A5              <1> 		rep movsd
  5657                              <1> 
  5658 00001A8F C606[F421]01        <1> 		mov [UserFont], byte 1		; Set font flag
  5659                              <1> 
  5660                              <1> 		; Fall through to use_font
  5661                              <1> 
  5662                              <1> ;
  5663                              <1> ; use_font:
  5664                              <1> ; 	This routine activates whatever font happens to be in the
  5665                              <1> ;	vgafontbuf, and updates the adjust_screen data.
  5666                              <1> ;       Must be called with CS = DS = ES
  5667                              <1> ;
  5668                              <1> use_font:
  5669 00001A94 F606[F421]01        <1> 		test [UserFont], byte 1		; Are we using a user-specified font?
  5670 00001A99 743C                <1> 		jz adjust_screen		; If not, just do the normal stuff
  5671                              <1> 
  5672 00001A9B BD00E0              <1> 		mov bp,vgafontbuf
  5673 00001A9E 8A3E[F221]          <1> 		mov bh,[VGAFontSize]
  5674                              <1> 
  5675 00001AA2 30DB                <1> 		xor bl,bl			; Needed by both INT 10h calls
  5676 00001AA4 803E[CD1C]01        <1> 		cmp [UsingVGA], byte 1		; Are we in graphics mode?
  5677 00001AA9 751B                <1> 		jne .text
  5678                              <1> 
  5679                              <1> .graphics:
  5680 00001AAB 31C9                <1> 		xor cx,cx
  5681 00001AAD 88F9                <1> 		mov cl,bh			; CX = bytes/character
  5682 00001AAF B8E001              <1> 		mov ax,480
  5683 00001AB2 F6F1                <1> 		div cl				; Compute char rows per screen
  5684 00001AB4 88C2                <1> 		mov dl,al
  5685 00001AB6 FEC8                <1> 		dec al
  5686 00001AB8 A2C157              <1> 		mov [VidRows],al
  5687 00001ABB B82111              <1> 		mov ax,1121h			; Set user character table
  5688 00001ABE CD10                <1> 		int 10h
  5689 00001AC0 C606C0574F          <1> 		mov [VidCols], byte 79		; Always 80 bytes/line
  5690 00001AC5 C3                  <1> .lf_ret:	ret				; No need to call adjust_screen
  5691                              <1> 
  5692                              <1> .text:
  5693 00001AC6 B90001              <1> 		mov cx,256
  5694 00001AC9 31D2                <1> 		xor dx,dx
  5695 00001ACB B81011              <1> 		mov ax,1110h
  5696 00001ACE CD10                <1> 		int 10h				; Load into VGA RAM
  5697                              <1> 
  5698 00001AD0 30DB                <1> 		xor bl,bl
  5699 00001AD2 B80311              <1> 		mov ax,1103h			; Select page 0
  5700 00001AD5 CD10                <1> 		int 10h
  5701                              <1> 
  5702                              <1> 		; Fall through to adjust_screen
  5703                              <1> 
  5704                              <1> lf_ret		equ use_font.lf_ret
  5705                              <1> 
  5706                              <1> ;
  5707                              <1> ; adjust_screen: Set the internal variables associated with the screen size.
  5708                              <1> ;		This is a subroutine in case we're loading a custom font.
  5709                              <1> ;
  5710                              <1> adjust_screen:
  5711 00001AD7 60                  <1> 		pusha
  5712 00001AD8 A08404              <1>                 mov al,[BIOS_vidrows]
  5713 00001ADB 20C0                <1>                 and al,al
  5714 00001ADD 7502                <1>                 jnz vidrows_ok
  5715 00001ADF B018                <1>                 mov al,24                       ; No vidrows in BIOS, assume 25
  5716                              <1> 						; (Remember: vidrows == rows-1)
  5717 00001AE1 A2C157              <1> vidrows_ok:	mov [VidRows],al
  5718 00001AE4 B40F                <1>                 mov ah,0fh
  5719 00001AE6 CD10                <1>                 int 10h                         ; Read video state
  5720 00001AE8 FECC                <1>                 dec ah                          ; Store count-1 (same as rows)
  5721 00001AEA 8826C057            <1>                 mov [VidCols],ah
  5722 00001AEE 61                  <1> 		popa
  5723 00001AEF C3                  <1> 		ret
  5724                              <1> 
  5725                                  %include "graphics.inc"		; VGA graphics
  5726                              <1> ;; $Id: graphics.inc,v 1.2 2002/06/10 18:32:42 hpa Exp $
  5727                              <1> ;; -----------------------------------------------------------------------
  5728                              <1> ;;   
  5729                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  5730                              <1> ;;
  5731                              <1> ;;   This program is free software; you can redistribute it and/or modify
  5732                              <1> ;;   it under the terms of the GNU General Public License as published by
  5733                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  5734                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  5735                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  5736                              <1> ;;
  5737                              <1> ;; -----------------------------------------------------------------------
  5738                              <1> 
  5739                              <1> ; ----------------------------------------------------------------------------
  5740                              <1> ;  VGA splash screen code
  5741                              <1> ; ----------------------------------------------------------------------------
  5742                              <1> 
  5743                              <1> ;
  5744                              <1> ; vgadisplayfile:
  5745                              <1> ;	Display a graphical splash screen.
  5746                              <1> ;
  5747                              <1> ; Input:
  5748                              <1> ;
  5749                              <1> ; SI	= cluster/socket pointer
  5750                              <1> ;
  5751                              <1> vgadisplayfile:
  5752 00001AF0 8936B857            <1> 		mov [VGACluster],si
  5753 00001AF4 06                  <1> 		push es
  5754                              <1> 
  5755                              <1> 		; This is a cheap and easy way to make sure the screen is
  5756                              <1> 		; cleared in case we were in graphics mode already
  5757 00001AF5 E87E01              <1> 		call vgaclearmode
  5758 00001AF8 E84D01              <1> 		call vgasetmode
  5759 00001AFB 7514                <1> 		jnz .error_nz
  5760                              <1> 
  5761                              <1> .graphalready:
  5762 00001AFD B80010              <1> 		mov ax,xfer_buf_seg		; Use as temporary storage
  5763 00001B00 8EC0                <1> 		mov es,ax
  5764 00001B02 8EE0                <1> 		mov fs,ax
  5765                              <1> 
  5766 00001B04 E8F300              <1> 		call vgagetchunk		; Get the first chunk
  5767                              <1> 
  5768                              <1> 		; The header WILL be in the first chunk.
  5769 00001B07 2666813E00403DF313- <1> 		cmp dword [es:xbs_vgabuf],0x1413f33d	; Magic number
  5770 00001B10 14                  <1>
  5771 00001B11 757D                <1> .error_nz:	jne .error
  5772 00001B13 26A10440            <1> 		mov ax,[es:xbs_vgabuf+4]
  5773 00001B17 A3B457              <1> 		mov [GraphXSize],ax
  5774                              <1> 
  5775 00001B1A BA0840              <1> 		mov dx,xbs_vgabuf+8		; Color map offset
  5776 00001B1D B81210              <1> 		mov ax,1012h			; Set RGB registers
  5777 00001B20 31DB                <1> 		xor bx,bx			; First register number
  5778 00001B22 B91000              <1> 		mov cx,16			; 16 registers
  5779 00001B25 CD10                <1> 		int 10h
  5780                              <1> 	
  5781                              <1> .movecursor:
  5782 00001B27 26A10640            <1> 		mov ax,[es:xbs_vgabuf+6]	; Number of pixel rows
  5783 00001B2B 8B16[F221]          <1> 		mov dx,[VGAFontSize]
  5784 00001B2F 01D0                <1> 		add ax,dx
  5785 00001B31 48                  <1> 		dec ax
  5786 00001B32 F6F2                <1> 		div dl
  5787 00001B34 31D2                <1> 		xor dx,dx			; Set column to 0
  5788 00001B36 3A06C157            <1> 		cmp al,[VidRows]
  5789 00001B3A 7205                <1> 		jb .rowsok
  5790 00001B3C A0C157              <1> 		mov al,[VidRows]
  5791 00001B3F FEC8                <1> 		dec al
  5792                              <1> .rowsok:
  5793 00001B41 88C6                <1> 		mov dh,al
  5794 00001B43 B402                <1> 		mov ah,2
  5795 00001B45 31DB                <1> 		xor bx,bx
  5796 00001B47 CD10                <1> 		int 10h				; Set cursor below image
  5797                              <1> 
  5798 00001B49 268B0E0640          <1> 		mov cx,[es:xbs_vgabuf+6]	; Number of graphics rows
  5799                              <1> 
  5800 00001B4E BE3840              <1> 		mov si,xbs_vgabuf+8+3*16	; Beginning of pixel data
  5801 00001B51 C706B6570000        <1> 		mov word [VGAPos],0
  5802                              <1> 
  5803                              <1> .drawpixelrow:
  5804 00001B57 51                  <1> 		push cx
  5805 00001B58 8B0EB457            <1> 		mov cx,[GraphXSize]
  5806 00001B5C BF0080              <1> 		mov di,xbs_vgatmpbuf		; Row buffer
  5807 00001B5F E83000              <1> 		call rledecode			; Decode one row
  5808 00001B62 56                  <1> 		push si
  5809 00001B63 BE0080              <1> 		mov si,xbs_vgatmpbuf
  5810 00001B66 89F7                <1> 		mov di,si
  5811 00001B68 033EB457            <1> 		add di,[GraphXSize]
  5812 00001B6C B9A000              <1> 		mov cx,640/4
  5813 00001B6F 6631C0              <1> 		xor eax,eax
  5814 00001B72 F366AB              <1> 		rep stosd			; Clear rest of row
  5815 00001B75 BF00A0              <1> 		mov di,0A000h			; VGA segment
  5816 00001B78 8EC7                <1> 		mov es,di
  5817 00001B7A 8B3EB657            <1> 		mov di,[VGAPos]
  5818 00001B7E BD8002              <1> 		mov bp,640
  5819 00001B81 E89500              <1> 		call packedpixel2vga
  5820 00001B84 8306B65750          <1> 		add word [VGAPos],byte 80	; Advance to next pixel row
  5821 00001B89 0FA0                <1> 		push fs
  5822 00001B8B 07                  <1> 		pop es
  5823 00001B8C 5E                  <1> 		pop si
  5824 00001B8D 59                  <1> 		pop cx
  5825 00001B8E E2C7                <1> 		loop .drawpixelrow
  5826                              <1> 
  5827                              <1> .error:
  5828 00001B90 07                  <1> 		pop es
  5829 00001B91 C3                  <1> 		ret
  5830                              <1> 
  5831                              <1> ;
  5832                              <1> ; rledecode:
  5833                              <1> ;	Decode a pixel row in RLE16 format.
  5834                              <1> ;
  5835                              <1> ; FS:SI	-> input
  5836                              <1> ; CX -> pixel count
  5837                              <1> ; ES:DI -> output (packed pixel)
  5838                              <1> ;
  5839                              <1> rledecode:
  5840 00001B92 66D1E6              <1> 		shl esi,1		; Nybble pointer
  5841 00001B95 30D2                <1> 		xor dl,dl		; Last pixel
  5842                              <1> .loop:
  5843 00001B97 E83E00              <1> 		call .getnybble
  5844 00001B9A 38D0                <1> 		cmp al,dl
  5845 00001B9C 740D                <1> 		je .run			; Start of run sequence
  5846 00001B9E AA                  <1> 		stosb
  5847 00001B9F 88C2                <1> 		mov dl,al
  5848 00001BA1 49                  <1> 		dec cx
  5849 00001BA2 75F3                <1> 		jnz .loop
  5850                              <1> .done:
  5851 00001BA4 66D1EE              <1> 		shr esi,1
  5852 00001BA7 83D600              <1> 		adc si,byte 0
  5853 00001BAA C3                  <1> 		ret
  5854                              <1> .run:
  5855 00001BAB 31DB                <1> 		xor bx,bx
  5856 00001BAD E82800              <1> 		call .getnybble
  5857 00001BB0 20C0                <1> 		and al,al
  5858 00001BB2 7410                <1> 		jz .longrun
  5859 00001BB4 88C3                <1> 		mov bl,al
  5860                              <1> .dorun:
  5861 00001BB6 51                  <1> 		push cx
  5862 00001BB7 89D9                <1> 		mov cx,bx
  5863 00001BB9 88D0                <1> 		mov al,dl
  5864 00001BBB F3AA                <1> 		rep stosb
  5865 00001BBD 59                  <1> 		pop cx
  5866 00001BBE 29D9                <1> 		sub cx,bx
  5867 00001BC0 77D5                <1> 		ja .loop
  5868 00001BC2 EBE0                <1> 		jmp short .done
  5869                              <1> .longrun:
  5870 00001BC4 E81100              <1> 		call .getnybble
  5871 00001BC7 88C4                <1> 		mov ah,al
  5872 00001BC9 E80C00              <1> 		call .getnybble
  5873 00001BCC C0E004              <1> 		shl al,4
  5874 00001BCF 08E0                <1> 		or al,ah
  5875 00001BD1 88C3                <1> 		mov bl,al
  5876 00001BD3 83C310              <1> 		add bx,16
  5877 00001BD6 EBDE                <1> 		jmp short .dorun
  5878                              <1> .getnybble:
  5879 00001BD8 66D1EE              <1> 		shr esi,1
  5880 00001BDB 64AC                <1> 		fs lodsb
  5881 00001BDD 7208                <1> 		jc .high
  5882 00001BDF 4E                  <1> 		dec si
  5883 00001BE0 240F                <1> 		and al,0Fh
  5884 00001BE2 F9                  <1> 		stc
  5885 00001BE3 66D1D6              <1> 		rcl esi,1
  5886 00001BE6 C3                  <1> 		ret
  5887                              <1> .high:
  5888 00001BE7 C0E804              <1> 		shr al,4
  5889 00001BEA 81FE0080            <1> 		cmp si,xbs_vgabuf+trackbufsize	; Chunk overrun
  5890 00001BEE 7206                <1> 		jb .nonewchunk
  5891 00001BF0 E80700              <1> 		call vgagetchunk
  5892 00001BF3 BE0040              <1> 		mov si,xbs_vgabuf		; Start at beginning of buffer
  5893                              <1> .nonewchunk:
  5894 00001BF6 66D1E6              <1> 		shl esi,1
  5895 00001BF9 C3                  <1> 		ret
  5896                              <1> 
  5897                              <1> ;
  5898                              <1> ; vgagetchunk:
  5899                              <1> ;	Get a new trackbufsize chunk of VGA image data
  5900                              <1> ;
  5901                              <1> ; On input, ES is assumed to point to the buffer segment.
  5902                              <1> ;
  5903                              <1> vgagetchunk:
  5904 00001BFA 6660                <1> 		pushad
  5905 00001BFC 8B36B857            <1> 		mov si,[VGACluster]
  5906 00001C00 21F6                <1> 		and si,si
  5907 00001C02 7412                <1> 		jz .eof				; EOF overrun, not much to do...
  5908                              <1> 
  5909 00001C04 8B0E9457            <1> 		mov cx,[BufSafe]		; One trackbuf worth of data
  5910 00001C08 BB0040              <1> 		mov bx,xbs_vgabuf
  5911 00001C0B E807E7              <1> 		call getfssec
  5912                              <1> 
  5913 00001C0E 7302                <1> 		jnc .noteof
  5914 00001C10 31F6                <1> 		xor si,si
  5915 00001C12 8936B857            <1> .noteof:	mov [VGACluster],si
  5916                              <1> 
  5917 00001C16 6661                <1> .eof:		popad
  5918 00001C18 C3                  <1> 		ret
  5919                              <1> 
  5920                              <1> ;
  5921                              <1> ; packedpixel2vga:
  5922                              <1> ;	Convert packed-pixel to VGA bitplanes
  5923                              <1> ;
  5924                              <1> ; FS:SI -> packed pixel string
  5925                              <1> ; BP    -> pixel count (multiple of 8)
  5926                              <1> ; ES:DI -> output
  5927                              <1> ;
  5928                              <1> packedpixel2vga:
  5929 00001C19 BAC403              <1> 		mov dx,3C4h	; VGA Sequencer Register select port
  5930 00001C1C B002                <1> 		mov al,2	; Sequencer mask
  5931 00001C1E EE                  <1> 		out dx,al	; Select the sequencer mask
  5932 00001C1F 42                  <1> 		inc dx		; VGA Sequencer Register data port
  5933 00001C20 B001                <1> 		mov al,1
  5934 00001C22 88C3                <1> 		mov bl,al
  5935                              <1> .planeloop:
  5936 00001C24 60                  <1> 		pusha
  5937 00001C25 EE                  <1> 		out dx,al
  5938                              <1> .loop1:
  5939 00001C26 B90800              <1> 		mov cx,8
  5940                              <1> .loop2:
  5941 00001C29 87CB                <1> 		xchg cx,bx
  5942 00001C2B 64AC                <1> 		fs lodsb
  5943 00001C2D D2E8                <1> 		shr al,cl
  5944 00001C2F D0D5                <1> 		rcl ch,1	; VGA is bigendian.  Sigh.
  5945 00001C31 87CB                <1> 		xchg cx,bx
  5946 00001C33 E2F4                <1> 		loop .loop2
  5947 00001C35 88F8                <1> 		mov al,bh
  5948 00001C37 AA                  <1> 		stosb
  5949 00001C38 83ED08              <1> 		sub bp,byte 8
  5950 00001C3B 77E9                <1> 		ja .loop1
  5951 00001C3D 61                  <1> 		popa
  5952 00001C3E FEC3                <1> 		inc bl
  5953 00001C40 D0E0                <1> 		shl al,1
  5954 00001C42 80FB04              <1> 		cmp bl,4
  5955 00001C45 76DD                <1> 		jbe .planeloop
  5956 00001C47 C3                  <1> 		ret
  5957                              <1> 
  5958                              <1> ;
  5959                              <1> ; vgasetmode:
  5960                              <1> ;	Enable VGA graphics, if possible; return ZF=1 on success
  5961                              <1> ;	DS must be set to the base segment; ES is set to DS.
  5962                              <1> ;
  5963                              <1> vgasetmode:
  5964 00001C48 1E                  <1> 		push ds
  5965 00001C49 07                  <1> 		pop es
  5966 00001C4A B8001A              <1> 		mov ax,1A00h		; Get video card and monitor
  5967 00001C4D 31DB                <1> 		xor bx,bx
  5968 00001C4F CD10                <1> 		int 10h
  5969 00001C51 80EB07              <1> 		sub bl, 7		; BL=07h and BL=08h OK
  5970 00001C54 80FB01              <1> 		cmp bl, 1
  5971 00001C57 771C                <1> 		ja .error		; ZF=0
  5972                              <1> ;		mov bx,TextColorReg
  5973                              <1> ;		mov dx,1009h		; Read color registers
  5974                              <1> ;		int 10h
  5975 00001C59 B81200              <1> 		mov ax,0012h		; Set mode = 640x480 VGA 16 colors
  5976 00001C5C CD10                <1> 		int 10h
  5977 00001C5E BA[BC1C]            <1> 		mov dx,linear_color
  5978 00001C61 B80210              <1> 		mov ax,1002h		; Write color registers
  5979 00001C64 CD10                <1> 		int 10h
  5980 00001C66 C606[CD1C]01        <1> 		mov [UsingVGA], byte 1
  5981                              <1> 
  5982 00001C6B E826FE              <1> 		call use_font		; Set graphics font/data
  5983 00001C6E C606[F521]00        <1> 		mov byte [ScrollAttribute], 00h
  5984                              <1> 
  5985 00001C73 31C0                <1> 		xor ax,ax		; Set ZF
  5986                              <1> .error:
  5987 00001C75 C3                  <1> 		ret
  5988                              <1> 
  5989                              <1> ;
  5990                              <1> ; vgaclearmode:
  5991                              <1> ;	Disable VGA graphics.  It is not safe to assume any value
  5992                              <1> ;	for DS or ES.
  5993                              <1> ;
  5994                              <1> vgaclearmode:
  5995 00001C76 1E                  <1> 		push ds
  5996 00001C77 06                  <1> 		push es
  5997 00001C78 6660                <1> 		pushad
  5998 00001C7A 8CC8                <1> 		mov ax,cs
  5999 00001C7C 8ED8                <1> 		mov ds,ax
  6000 00001C7E 8EC0                <1> 		mov es,ax
  6001 00001C80 803E[CD1C]01        <1> 		cmp [UsingVGA], byte 1
  6002 00001C85 7512                <1> 		jne .done
  6003 00001C87 B80300              <1> 		mov ax,0003h		; Return to normal video mode
  6004 00001C8A CD10                <1> 		int 10h
  6005                              <1> ;		mov dx,TextColorReg	; Restore color registers
  6006                              <1> ;		mov ax,1002h
  6007                              <1> ;		int 10h
  6008 00001C8C C606[CD1C]00        <1> 		mov [UsingVGA], byte 0
  6009                              <1> 
  6010 00001C91 E800FE              <1> 		call use_font		; Restore text font/data
  6011 00001C94 C606[F521]07        <1> 		mov byte [ScrollAttribute], 07h
  6012                              <1> .done:
  6013 00001C99 6661                <1> 		popad
  6014 00001C9B 07                  <1> 		pop es
  6015 00001C9C 1F                  <1> 		pop ds
  6016 00001C9D C3                  <1> 		ret
  6017                              <1> 
  6018                              <1> ;
  6019                              <1> ; vgashowcursor/vgahidecursor:
  6020                              <1> ;	If VGA graphics is enabled, draw a cursor/clear a cursor
  6021                              <1> ;
  6022                              <1> vgashowcursor:
  6023 00001C9E 6660                <1> 		pushad
  6024 00001CA0 B05F                <1> 		mov al,'_'
  6025 00001CA2 EB04                <1> 		jmp short vgacursorcommon
  6026                              <1> vgahidecursor:
  6027 00001CA4 6660                <1> 		pushad
  6028 00001CA6 B020                <1> 		mov al,' '
  6029                              <1> vgacursorcommon:
  6030 00001CA8 803E[CD1C]01        <1> 		cmp [UsingVGA], byte 1
  6031 00001CAD 750A                <1> 		jne .done
  6032 00001CAF B409                <1> 		mov ah,09h
  6033 00001CB1 BB0700              <1> 		mov bx,0007h
  6034 00001CB4 B90100              <1> 		mov cx,1
  6035 00001CB7 CD10                <1> 		int 10h
  6036                              <1> .done:
  6037 00001CB9 6661                <1> 		popad
  6038 00001CBB C3                  <1> 		ret
  6039                              <1> 
  6040                              <1> 
  6041                              <1> 		; Map colors to consecutive DAC registers
  6042 00001CBC 000102030405060708- <1> linear_color	db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0
  6043 00001CC5 090A0B0C0D0E0F00    <1>
  6044 00001CCD 00                  <1> UsingVGA	db 0
  6045                              <1> 
  6046                                  %include "highmem.inc"		; High memory sizing
  6047                              <1> ;; $Id: highmem.inc,v 1.2 2004/04/23 04:14:15 hpa Exp $
  6048                              <1> ;; -----------------------------------------------------------------------
  6049                              <1> ;;   
  6050                              <1> ;;   Copyright 1994-2004 H. Peter Anvin - All Rights Reserved
  6051                              <1> ;;
  6052                              <1> ;;   This program is free software; you can redistribute it and/or modify
  6053                              <1> ;;   it under the terms of the GNU General Public License as published by
  6054                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  6055                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  6056                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  6057                              <1> ;;
  6058                              <1> ;; -----------------------------------------------------------------------
  6059                              <1> 
  6060                              <1> ;;
  6061                              <1> ;; highmem.inc
  6062                              <1> ;; 
  6063                              <1> ;; Probe for the size of high memory.  This can be overridden by a
  6064                              <1> ;; mem= command on the command line while booting a new kernel.
  6065                              <1> ;;
  6066                              <1> 
  6067                              <1> ;
  6068                              <1> ; This is set up as a subroutine; it will set up the global variable
  6069                              <1> ; HighMemSize.  All registers are preserved.  Assumes DS == CS.
  6070                              <1> ;
  6071                              <1> highmemsize:
  6072 00001CCE 06                  <1> 		push es
  6073 00001CCF 6660                <1> 		pushad
  6074                              <1> 
  6075                              <1> ;
  6076                              <1> ; First, try INT 15:E820 (get BIOS memory map)
  6077                              <1> ;
  6078                              <1> get_e820:
  6079 00001CD1 6631DB              <1> 		xor ebx,ebx			; Start with first record
  6080 00001CD4 66C70658570000F0FF  <1> 		mov dword [E820Max],-(1 << 20)	; Max amount of high memory
  6081 00001CDD 66891E5457          <1> 		mov dword [E820Mem],ebx		; Detected amount of high memory
  6082 00001CE2 8EC3                <1> 		mov es,bx			; Need ES = DS = 0 for now
  6083 00001CE4 EB05                <1> 		jmp short .do_e820		; Skip "at end" check first time!
  6084 00001CE6 6621DB              <1> .int_loop:	and ebx,ebx			; If we're back at beginning...
  6085 00001CE9 7478                <1> 		jz .e820_done			; ... we're done
  6086 00001CEB 66B820E80000        <1> .do_e820:	mov eax,0000E820h
  6087 00001CF1 66BA50414D53        <1> 		mov edx,534D4150h		; "SMAP" backwards
  6088 00001CF7 6631C9              <1> 		xor ecx,ecx
  6089 00001CFA B114                <1> 		mov cl,20			; ECX <- 20
  6090 00001CFC BF4057              <1> 		mov di,E820Buf
  6091 00001CFF CD15                <1> 		int 15h
  6092 00001D01 7307                <1> 		jnc .no_carry
  6093                              <1> 		; If carry, ebx == 0 means error, ebx != 0 means we're done
  6094 00001D03 6621DB              <1> 		and ebx,ebx
  6095 00001D06 755B                <1> 		jnz .e820_done
  6096 00001D08 EB6F                <1> 		jmp no_e820
  6097                              <1> .no_carry:
  6098 00001D0A 663D50414D53        <1> 		cmp eax,534D4150h
  6099 00001D10 7567                <1> 		jne no_e820
  6100                              <1> ;
  6101                              <1> ; Look for a memory block starting at <= 1 MB and continuing upward
  6102                              <1> ;
  6103 00001D12 66833E445700        <1> 		cmp dword [E820Buf+4], byte 0
  6104 00001D18 77CC                <1> 		ja .int_loop			; Start >= 4 GB?
  6105 00001D1A 66BA00001000        <1> 		mov edx, (1 << 20)
  6106 00001D20 662B164057          <1> 		sub edx, [E820Buf]
  6107 00001D25 7319                <1> 		jnb .ram_range			; Start >= 1 MB?
  6108                              <1> 		; If we get here, it starts > 1 MB but < 4 GB; if this is a
  6109                              <1> 		; *non*-memory range, remember this as unusable; some BIOSes
  6110                              <1> 		; get the length of primary RAM wrong!
  6111 00001D27 66833E505701        <1> 		cmp dword [E820Buf+16], byte 1
  6112 00001D2D 74B7                <1> 		je .int_loop			; If it's memory, don't worry about it
  6113 00001D2F 66F7DA              <1> 		neg edx				; This means what for memory limit?
  6114 00001D32 663B165857          <1> 		cmp edx,[E820Max]		; Better or worse
  6115 00001D37 73AD                <1> 		jnb .int_loop
  6116 00001D39 6689165857          <1> 		mov [E820Max],edx
  6117 00001D3E EBA6                <1> 		jmp .int_loop
  6118                              <1> 		
  6119                              <1> .ram_range:
  6120 00001D40 F9                  <1> 		stc
  6121 00001D41 6619C0              <1> 		sbb eax,eax			; eax <- 0xFFFFFFFF
  6122 00001D44 66833E4C5700        <1> 		cmp dword [E820Buf+12], byte 0
  6123 00001D4A 7704                <1> 		ja .huge			; Size >= 4 GB
  6124 00001D4C 66A14857            <1> 		mov eax, [E820Buf+8]
  6125 00001D50 6629D0              <1> .huge:		sub eax, edx			; Adjust size to start at 1 MB
  6126 00001D53 7691                <1> 		jbe .int_loop			; Completely below 1 MB?
  6127                              <1> 
  6128                              <1> 		; Now EAX contains the size of memory 1 MB...up
  6129 00001D55 66833E505701        <1> 		cmp dword [E820Buf+16], byte 1
  6130 00001D5B 7589                <1> 		jne .int_loop			; High memory isn't usable memory!!!!
  6131                              <1> 
  6132                              <1> 		; We're good!
  6133 00001D5D 66A35457            <1> 		mov [E820Mem],eax
  6134 00001D61 EB83                <1> 		jmp .int_loop			; Still need to add low 1 MB
  6135                              <1> 
  6136                              <1> .e820_done:
  6137 00001D63 66A15457            <1> 		mov eax,[E820Mem]
  6138 00001D67 6621C0              <1> 		and eax,eax
  6139 00001D6A 740D                <1> 		jz no_e820			; Nothing found by E820?
  6140 00001D6C 663B065857          <1> 		cmp eax,[E820Max]		; Make sure we're not limited
  6141 00001D71 7638                <1> 		jna got_highmem_add1mb
  6142 00001D73 66A15857            <1> 		mov eax,[E820Max]
  6143 00001D77 EB32                <1> 		jmp got_highmem_add1mb
  6144                              <1> 
  6145                              <1> ;
  6146                              <1> ; INT 15:E820 failed.  Try INT 15:E801.
  6147                              <1> ;
  6148                              <1> no_e820:
  6149 00001D79 B801E8              <1> 		mov ax,0e801h			; Query high memory (semi-recent)
  6150 00001D7C CD15                <1> 		int 15h
  6151 00001D7E 7215                <1> 		jc no_e801
  6152 00001D80 3D003C              <1> 		cmp ax,3c00h
  6153 00001D83 7710                <1> 		ja no_e801			; > 3C00h something's wrong with this call
  6154 00001D85 721A                <1> 		jb e801_hole			; If memory hole we can only use low part
  6155                              <1> 
  6156 00001D87 89D8                <1> 		mov ax,bx
  6157 00001D89 66C1E010            <1> 		shl eax,16			; 64K chunks
  6158 00001D8D 660500000001        <1> 		add eax,(16 << 20)		; Add first 16M
  6159 00001D93 EB1C                <1> 		jmp short got_highmem				
  6160                              <1> 
  6161                              <1> ;
  6162                              <1> ; INT 15:E801 failed.  Try INT 15:88.
  6163                              <1> ;
  6164                              <1> no_e801:
  6165 00001D95 B488                <1> 		mov ah,88h			; Query high memory (oldest)
  6166 00001D97 CD15                <1> 		int 15h
  6167 00001D99 3D0038              <1> 		cmp ax,14*1024			; Don't trust memory >15M
  6168 00001D9C 7603                <1> 		jna e801_hole
  6169 00001D9E B80038              <1> 		mov ax,14*1024
  6170                              <1> e801_hole:
  6171 00001DA1 6625FFFF0000        <1> 		and eax,0ffffh
  6172 00001DA7 66C1E00A            <1> 		shl eax,10			; Convert from kilobytes
  6173                              <1> got_highmem_add1mb:
  6174 00001DAB 660500001000        <1> 		add eax,(1 << 20)		; First megabyte
  6175                              <1> got_highmem:
  6176                              <1> %if HIGHMEM_SLOP != 0
  6177                              <1> 		sub eax,HIGHMEM_SLOP
  6178                              <1> %endif
  6179 00001DB1 66A36057            <1> 		mov [HighMemSize],eax
  6180 00001DB5 6661                <1> 		popad
  6181 00001DB7 07                  <1> 		pop es
  6182 00001DB8 C3                  <1> 		ret				; Done!
  6183                                  
  6184                                  ; -----------------------------------------------------------------------------
  6185                                  ;  Begin data section
  6186                                  ; -----------------------------------------------------------------------------
  6187                                  
  6188                                  CR		equ 13		; Carriage Return
  6189                                  LF		equ 10		; Line Feed
  6190                                  FF		equ 12		; Form Feed
  6191                                  BS		equ  8		; Backspace
  6192                                  
  6193                                  ;
  6194                                  ; Lower-case table for codepage 865
  6195                                  ;
  6196                                  lcase_low       equ 128
  6197                                  lcase_high      equ 165
  6198 00001DB9 878182838485868788-     lcase_tab       db 135, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138
  6199 00001DC2 898A               
  6200 00001DC4 8B8C8D848682919193-                     db 139, 140, 141, 132, 134, 130, 145, 145, 147, 148, 149
  6201 00001DCD 9495               
  6202 00001DCF 96979894819B9C9B9E-                     db 150, 151, 152, 148, 129, 155, 156, 155, 158, 159, 160
  6203 00001DD8 9FA0               
  6204 00001DDA A1A2A3A4A4                              db 161, 162, 163, 164, 164
  6205                                  
  6206 00001DDF 20436F707972696768-     copyright_str   db ' Copyright (C) 1994-', year, ' H. Peter Anvin'
  6207 00001DE8 742028432920313939-
  6208 00001DF1 342D3230303420482E-
  6209 00001DFA 20506574657220416E-
  6210 00001E03 76696E             
  6211 00001E06 0D0A00                  		db CR, LF, 0
  6212 00001E09 626F6F743A2000          boot_prompt	db 'boot: ', 0
  6213 00001E10 08200800                wipe_char	db BS, ' ', BS, 0
  6214 00001E14 436F756C64206E6F74-     err_notfound	db 'Could not find kernel image: ',0
  6215 00001E1D 2066696E64206B6572-
  6216 00001E26 6E656C20696D616765-
  6217 00001E2F 3A2000             
  6218 00001E32 0D0A496E76616C6964-     err_notkernel	db CR, LF, 'Invalid or corrupt kernel image.', CR, LF, 0
  6219 00001E3B 206F7220636F727275-
  6220 00001E44 7074206B65726E656C-
  6221 00001E4D 20696D6167652E0D0A-
  6222 00001E56 00                 
  6223 00001E57 497420617070656172-     err_noram	db 'It appears your computer has less than '
  6224 00001E60 7320796F757220636F-
  6225 00001E69 6D7075746572206861-
  6226 00001E72 73206C657373207468-
  6227 00001E7B 616E20             
  6228 00001E7E 333834                  		asciidec dosram_k
  6229 00001E81 4B206F66206C6F7720-     		db 'K of low ("DOS")'
  6230 00001E8A 2822444F532229     
  6231 00001E91 0D0A                    		db CR, LF
  6232 00001E93 52414D2E20204C696E-     		db 'RAM.  Linux needs at least this amount to boot.  If you get'
  6233 00001E9C 7578206E6565647320-
  6234 00001EA5 6174206C6561737420-
  6235 00001EAE 7468697320616D6F75-
  6236 00001EB7 6E7420746F20626F6F-
  6237 00001EC0 742E2020496620796F-
  6238 00001EC9 7520676574         
  6239 00001ECE 0D0A                    		db CR, LF
  6240 00001ED0 74686973206D657373-     		db 'this message in error, hold down the Ctrl key while'
  6241 00001ED9 61676520696E206572-
  6242 00001EE2 726F722C20686F6C64-
  6243 00001EEB 20646F776E20746865-
  6244 00001EF4 204374726C206B6579-
  6245 00001EFD 207768696C65       
  6246 00001F03 0D0A                    		db CR, LF
  6247 00001F05 626F6F74696E672C20-     		db 'booting, and I will take your word for it.', CR, LF, 0
  6248 00001F0E 616E6420492077696C-
  6249 00001F17 6C2074616B6520796F-
  6250 00001F20 757220776F72642066-
  6251 00001F29 6F722069742E0D0A00 
  6252 00001F32 556E6B6E6F776E206B-     err_badcfg      db 'Unknown keyword in syslinux.cfg.', CR, LF, 0
  6253 00001F3B 6579776F726420696E-
  6254 00001F44 207379736C696E7578-
  6255 00001F4D 2E6366672E0D0A00   
  6256 00001F55 4D697373696E672070-     err_noparm      db 'Missing parameter in syslinux.cfg.', CR, LF, 0
  6257 00001F5E 6172616D6574657220-
  6258 00001F67 696E207379736C696E-
  6259 00001F70 75782E6366672E0D0A-
  6260 00001F79 00                 
  6261 00001F7A 0D0A436F756C64206E-     err_noinitrd    db CR, LF, 'Could not find ramdisk image: ', 0
  6262 00001F83 6F742066696E642072-
  6263 00001F8C 616D6469736B20696D-
  6264 00001F95 6167653A2000       
  6265 00001F9B 4E6F7420656E6F7567-     err_nohighmem   db 'Not enough memory to load specified kernel.', CR, LF, 0
  6266 00001FA4 68206D656D6F727920-
  6267 00001FAD 746F206C6F61642073-
  6268 00001FB6 706563696669656420-
  6269 00001FBF 6B65726E656C2E0D0A-
  6270 00001FC8 00                 
  6271 00001FC9 0D0A4B65726E656C20-     err_highload    db CR, LF, 'Kernel transfer failure.', CR, LF, 0
  6272 00001FD2 7472616E7366657220-
  6273 00001FDB 6661696C7572652E0D-
  6274 00001FE4 0A00               
  6275 00001FE6 43616E6E6F74206C6F-     err_oldkernel   db 'Cannot load a ramdisk with an old kernel image.'
  6276 00001FEF 616420612072616D64-
  6277 00001FF8 69736B207769746820-
  6278 00002001 616E206F6C64206B65-
  6279 0000200A 726E656C20696D6167-
  6280 00002013 652E               
  6281 00002015 0D0A00                                  db CR, LF, 0
  6282 00002018 3A20617474656D7074-     err_notdos	db ': attempted DOS system call', CR, LF, 0
  6283 00002021 656420444F53207379-
  6284 0000202A 7374656D2063616C6C-
  6285 00002033 0D0A00             
  6286 00002036 434F4D424F4F542069-     err_comlarge	db 'COMBOOT image too large.', CR, LF, 0
  6287 0000203F 6D61676520746F6F20-
  6288 00002048 6C617267652E0D0A00 
  6289 00002051 0D0A41323020676174-     err_a20		db CR, LF, 'A20 gate not responding!', CR, LF, 0
  6290 0000205A 65206E6F7420726573-
  6291 00002063 706F6E64696E67210D-
  6292 0000206C 0A00               
  6293 0000206E 0D0A426F6F74206661-     err_bootfailed	db CR, LF, 'Boot failed: please change disks and press '
  6294 00002077 696C65643A20706C65-
  6295 00002080 617365206368616E67-
  6296 00002089 65206469736B732061-
  6297 00002092 6E6420707265737320 
  6298 0000209B 61206B657920746F20-     		db 'a key to continue.', CR, LF, 0
  6299 000020A4 636F6E74696E75652E-
  6300 000020AD 0D0A00             
  6301 000020B0 52656164792E0D0A00      ready_msg	db 'Ready.', CR, LF, 0
  6302 000020B9 0D0A                    crlfloading_msg	db CR, LF
  6303 000020BB 4C6F6164696E672000      loading_msg     db 'Loading ', 0
  6304 000020C4 2E                      dotdot_msg      db '.'
  6305 000020C5 2E00                    dot_msg         db '.', 0
  6306 000020C7 2061626F727465642E      aborted_msg	db ' aborted.'			; Fall through to crlf_msg!
  6307 000020D0 0D0A                    crlf_msg	db CR, LF
  6308 000020D2 00                      null_msg	db 0
  6309 000020D3 0D0C00                  crff_msg	db CR, FF, 0
  6310 000020D6 5359534C494E555843-     syslinux_cfg	db 'SYSLINUXCFG'
  6311 000020DF 4647               
  6312                                  %if IS_MDSLINUX
  6313                                  manifest	db 'MANIFEST   '
  6314                                  %endif
  6315                                  ;
  6316                                  ; Command line options we'd like to take a look at
  6317                                  ;
  6318                                  ; mem= and vga= are handled as normal 32-bit integer values
  6319 000020E1 696E697472643D          initrd_cmd	db 'initrd='
  6320                                  initrd_cmd_len	equ 7
  6321                                  
  6322                                  ;
  6323                                  ; Config file keyword table
  6324                                  ;
  6325                                  %include "keywords.inc"
  6326                              <1> ;; $Id: keywords.inc,v 1.8 2004/05/29 22:11:23 hpa Exp $
  6327                              <1> ;; -----------------------------------------------------------------------
  6328                              <1> ;;   
  6329                              <1> ;;   Copyright 1994-2002 H. Peter Anvin - All Rights Reserved
  6330                              <1> ;;
  6331                              <1> ;;   This program is free software; you can redistribute it and/or modify
  6332                              <1> ;;   it under the terms of the GNU General Public License as published by
  6333                              <1> ;;   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
  6334                              <1> ;;   Bostom MA 02111-1307, USA; either version 2 of the License, or
  6335                              <1> ;;   (at your option) any later version; incorporated herein by reference.
  6336                              <1> ;;
  6337                              <1> ;; -----------------------------------------------------------------------
  6338                              <1> 
  6339                              <1> ;;
  6340                              <1> ;; keywords.inc
  6341                              <1> ;;
  6342                              <1> ;; Common header file for the handling of keyword hash and macros
  6343                              <1> ;;
  6344                              <1> 
  6345                              <1> %ifndef DEPEND		; Generated file
  6346                              <1> %include "kwdhash.gen"
  6347                              <2> hash_hash               equ 0x00000023
  6348                              <2> hash_append             equ 0xc53999a4
  6349                              <2> hash_default            equ 0xcc5159ed
  6350                              <2> hash_display            equ 0xd509bc40
  6351                              <2> hash_font               equ 0x0032b1b4
  6352                              <2> hash_implicit           equ 0xa6f50207
  6353                              <2> hash_ipappend           equ 0xc5399af0
  6354                              <2> hash_kbdmap             equ 0xd013b850
  6355                              <2> hash_kernel             equ 0xd068b4cc
  6356                              <2> hash_label              equ 0x06f104cc
  6357                              <2> hash_localboot          equ 0x04f0def4
  6358                              <2> hash_prompt             equ 0xe7163a74
  6359                              <2> hash_say                equ 0x0001c059
  6360                              <2> hash_serial             equ 0xe068a84c
  6361                              <2> hash_timeout            equ 0xd4e332c9
  6362                              <2> hash_allowoptions       equ 0x1648dd10
  6363                              <2> hash_ontimeout          equ 0xd4e35eb9
  6364                              <2> hash_onerror            equ 0x1a68c589
  6365                              <2> hash_f0                 equ 0x00000cf0
  6366                              <2> hash_f1                 equ 0x00000cf1
  6367                              <2> hash_f2                 equ 0x00000cf2
  6368                              <2> hash_f3                 equ 0x00000cf3
  6369                              <2> hash_f4                 equ 0x00000cf4
  6370                              <2> hash_f5                 equ 0x00000cf5
  6371                              <2> hash_f6                 equ 0x00000cf6
  6372                              <2> hash_f7                 equ 0x00000cf7
  6373                              <2> hash_f8                 equ 0x00000cf8
  6374                              <2> hash_f9                 equ 0x00000cf9
  6375                              <2> hash_f10                equ 0x00019e10
  6376                              <2> hash_f11                equ 0x00019e11
  6377                              <2> hash_f12                equ 0x00019e12
  6378                              <1> %endif
  6379                              <1> 
  6380                              <1> %macro keyword 2
  6381                              <1> 	dd hash_%1	; Hash value
  6382                              <1> 	dw 0		; No argument
  6383                              <1> 	dw %2		; Entrypoint
  6384                              <1> %endmacro
  6385                              <1> 
  6386                              <1> %macro keyword 3
  6387                              <1> 	dd hash_%1	; Hash value
  6388                              <1> 	dw %3		; 16-bit argument
  6389                              <1> 	dw %2		; Entrypoint
  6390                              <1> %endmacro
  6391                              <1> 
  6392                              <1> %macro keyword 4
  6393                              <1> 	dd hash_%1	; Hash value
  6394                              <1> 	db %3, %4	; 2 8-bit arguments
  6395                              <1> 	dw %2		; Entrypoint
  6396                              <1> %endmacro
  6397                              <1> 
  6398                              <1> keywd_size	equ 8	; Bytes per keyword
  6399                              <1> 
  6400                              <1> 		align 4, db 0
  6401                              <1> 
  6402                              <1> keywd_table:
  6403                              <1> 		keyword hash,      pc_comment
  6404 000020E8 23000000            <2>  dd hash_%1
  6405 000020EC 0000                <2>  dw 0
  6406 000020EE 2417                <2>  dw %2
  6407                              <1> 		keyword append,    pc_append
  6408 000020F0 A49939C5            <2>  dd hash_%1
  6409 000020F4 0000                <2>  dw 0
  6410 000020F6 [BD15]              <2>  dw %2
  6411                              <1> 		keyword default,   pc_default
  6412 000020F8 ED5951CC            <2>  dd hash_%1
  6413 000020FC 0000                <2>  dw 0
  6414 000020FE [9415]              <2>  dw %2
  6415                              <1> 		keyword display,   pc_filecmd,  get_msg_file
  6416 00002100 40BC09D5            <2>  dd hash_%1
  6417 00002104 [4413]              <2>  dw %3
  6418 00002106 [1C16]              <2>  dw %2
  6419                              <1> 		keyword font,      pc_filecmd,  loadfont
  6420 00002108 B4B13200            <2>  dd hash_%1
  6421 0000210C [581A]              <2>  dw %3
  6422 0000210E [1C16]              <2>  dw %2
  6423                              <1> 		keyword implicit,  pc_setint16, AllowImplicit
  6424 00002110 0702F5A6            <2>  dd hash_%1
  6425 00002114 [EC21]              <2>  dw %3
  6426 00002116 [1216]              <2>  dw %2
  6427                              <1> 		keyword kbdmap,    pc_filecmd,  loadkeys
  6428 00002118 50B813D0            <2>  dd hash_%1
  6429 0000211C [2513]              <2>  dw %3
  6430 0000211E [1C16]              <2>  dw %2
  6431                              <1> 		keyword kernel,    pc_kernel
  6432 00002120 CCB468D0            <2>  dd hash_%1
  6433 00002124 0000                <2>  dw 0
  6434 00002126 [F015]              <2>  dw %2
  6435                              <1> 		keyword label,     pc_label
  6436 00002128 CC04F106            <2>  dd hash_%1
  6437 0000212C 0000                <2>  dw 0
  6438 0000212E [EF16]              <2>  dw %2
  6439                              <1> 		keyword prompt,    pc_setint16, ForcePrompt
  6440 00002130 743A16E7            <2>  dd hash_%1
  6441 00002134 [EA21]              <2>  dw %3
  6442 00002136 [1216]              <2>  dw %2
  6443                              <1> 		keyword say,       pc_say
  6444 00002138 59C00100            <2>  dd hash_%1
  6445 0000213C 0000                <2>  dw 0
  6446 0000213E [1B17]              <2>  dw %2
  6447                              <1> 		keyword serial,    pc_serial
  6448 00002140 4CA868E0            <2>  dd hash_%1
  6449 00002144 0000                <2>  dw 0
  6450 00002146 [2F16]              <2>  dw %2
  6451                              <1> 		keyword timeout,   pc_timeout
  6452 00002148 C932E3D4            <2>  dd hash_%1
  6453 0000214C 0000                <2>  dw 0
  6454 0000214E [0116]              <2>  dw %2
  6455                              <1> 		keyword ontimeout, pc_ontimeout
  6456 00002150 B95EE3D4            <2>  dd hash_%1
  6457 00002154 0000                <2>  dw 0
  6458 00002156 [9F15]              <2>  dw %2
  6459                              <1> 		keyword onerror,   pc_onerror
  6460 00002158 89C5681A            <2>  dd hash_%1
  6461 0000215C 0000                <2>  dw 0
  6462 0000215E [AE15]              <2>  dw %2
  6463                              <1> 		keyword allowoptions, pc_setint16, AllowOptions
  6464 00002160 10DD4816            <2>  dd hash_%1
  6465 00002164 [EE21]              <2>  dw %3
  6466 00002166 [1216]              <2>  dw %2
  6467                              <1> 		keyword f1,        pc_fkey,     FKeyName+(0<<FILENAME_MAX_LG2)
  6468 00002168 F10C0000            <2>  dd hash_%1
  6469 0000216C 0056                <2>  dw %3
  6470 0000216E [E616]              <2>  dw %2
  6471                              <1> 		keyword f2,        pc_fkey,     FKeyName+(1<<FILENAME_MAX_LG2)
  6472 00002170 F20C0000            <2>  dd hash_%1
  6473 00002174 1056                <2>  dw %3
  6474 00002176 [E616]              <2>  dw %2
  6475                              <1> 		keyword f3,        pc_fkey,     FKeyName+(2<<FILENAME_MAX_LG2)
  6476 00002178 F30C0000            <2>  dd hash_%1
  6477 0000217C 2056                <2>  dw %3
  6478 0000217E [E616]              <2>  dw %2
  6479                              <1> 		keyword f4,        pc_fkey,     FKeyName+(3<<FILENAME_MAX_LG2)
  6480 00002180 F40C0000            <2>  dd hash_%1
  6481 00002184 3056                <2>  dw %3
  6482 00002186 [E616]              <2>  dw %2
  6483                              <1> 		keyword f5,        pc_fkey,     FKeyName+(4<<FILENAME_MAX_LG2)
  6484 00002188 F50C0000            <2>  dd hash_%1
  6485 0000218C 4056                <2>  dw %3
  6486 0000218E [E616]              <2>  dw %2
  6487                              <1> 		keyword f6,        pc_fkey,     FKeyName+(5<<FILENAME_MAX_LG2)
  6488 00002190 F60C0000            <2>  dd hash_%1
  6489 00002194 5056                <2>  dw %3
  6490 00002196 [E616]              <2>  dw %2
  6491                              <1> 		keyword f7,        pc_fkey,     FKeyName+(6<<FILENAME_MAX_LG2)
  6492 00002198 F70C0000            <2>  dd hash_%1
  6493 0000219C 6056                <2>  dw %3
  6494 0000219E [E616]              <2>  dw %2
  6495                              <1> 		keyword f8,        pc_fkey,     FKeyName+(7<<FILENAME_MAX_LG2)
  6496 000021A0 F80C0000            <2>  dd hash_%1
  6497 000021A4 7056                <2>  dw %3
  6498 000021A6 [E616]              <2>  dw %2
  6499                              <1> 		keyword f9,        pc_fkey,     FKeyName+(8<<FILENAME_MAX_LG2)
  6500 000021A8 F90C0000            <2>  dd hash_%1
  6501 000021AC 8056                <2>  dw %3
  6502 000021AE [E616]              <2>  dw %2
  6503                              <1> 		keyword f10,       pc_fkey,     FKeyName+(9<<FILENAME_MAX_LG2)
  6504 000021B0 109E0100            <2>  dd hash_%1
  6505 000021B4 9056                <2>  dw %3
  6506 000021B6 [E616]              <2>  dw %2
  6507                              <1> 		keyword f0,        pc_fkey,     FKeyName+(9<<FILENAME_MAX_LG2)
  6508 000021B8 F00C0000            <2>  dd hash_%1
  6509 000021BC 9056                <2>  dw %3
  6510 000021BE [E616]              <2>  dw %2
  6511                              <1> %if IS_PXELINUX
  6512                              <1> 		keyword ipappend,  pc_ipappend
  6513                              <1> %endif
  6514                              <1> %if IS_PXELINUX || IS_ISOLINUX
  6515                              <1> 		keyword localboot, pc_localboot
  6516                              <1> %endif
  6517                              <1> 
  6518                              <1> keywd_count	equ ($-keywd_table)/keywd_size
  6519                              <1> 
  6520                                  
  6521                                  ;
  6522                                  ; Extensions to search for (in *forward* order).
  6523                                  ;
  6524 000021C0 43425400                exten_table:	db 'CBT',0		; COMBOOT (specific)
  6525 000021C4 42535300                		db 'BSS',0		; Boot Sector (add superblock)
  6526 000021C8 42532000                		db 'BS ',0		; Boot Sector 
  6527 000021CC 434F4D00                		db 'COM',0		; COMBOOT (same as DOS)
  6528 000021D0 43333200                		db 'C32',0		; COM32
  6529                                  exten_table_end:
  6530 000021D4 0000000000000000        		dd 0, 0			; Need 8 null bytes here
  6531                                  
  6532                                  ;
  6533                                  ; Misc initialized (data) variables
  6534                                  ;
  6535                                  %ifdef debug				; This code for debugging only
  6536                                  debug_magic	dw 0D00Dh		; Debug code sentinel
  6537                                  %endif
  6538 000021DC 0000                    AppendLen       dw 0                    ; Bytes in append= command
  6539 000021DE 0000                    OntimeoutLen	dw 0			; Bytes in ontimeout command
  6540 000021E0 0000                    OnerrorLen	dw 0			; Bytes in onerror command
  6541 000021E2 0000                    KbdTimeOut      dw 0                    ; Keyboard timeout (if any)
  6542 000021E4 0090                    CmdLinePtr	dw cmd_line_here	; Command line advancing pointer
  6543                                  initrd_flag	equ $
  6544 000021E6 0000                    initrd_ptr	dw 0			; Initial ramdisk pointer/flag
  6545 000021E8 0000                    VKernelCtr	dw 0			; Number of registered vkernels
  6546 000021EA 0000                    ForcePrompt	dw 0			; Force prompt
  6547 000021EC 0100                    AllowImplicit   dw 1                    ; Allow implicit kernels
  6548 000021EE 0100                    AllowOptions	dw 1			; User-specified options allowed
  6549 000021F0 0000                    SerialPort	dw 0			; Serial port base (or 0 for no serial port)
  6550 000021F2 1000                    VGAFontSize	dw 16			; Defaults to 16 byte font
  6551 000021F4 00                      UserFont	db 0			; Using a user-specified font
  6552 000021F5 07                      ScrollAttribute	db 07h			; White on black (for text mode)
  6553                                  ;
  6554                                  ; Stuff for the command line; we do some trickery here with equ to avoid
  6555                                  ; tons of zeros appended to our file and wasting space
  6556                                  ;
  6557 000021F6 6C696E757820617574-     linuxauto_cmd	db 'linux auto',0
  6558 000021FF 6F00               
  6559                                  linuxauto_len   equ $-linuxauto_cmd
  6560 00002201 424F4F545F494D4147-     boot_image      db 'BOOT_IMAGE='
  6561 0000220A 453D               
  6562                                  boot_image_len  equ $-boot_image
  6563                                  ldlinux_end	equ $
  6564                                  ldlinux_len	equ $-ldlinux_magic
  6565                                  ;
  6566                                  ; Put the getcbuf right after the code, aligned on a sector boundary
  6567                                  ;
  6568                                  end_of_code	equ (ldlinux_end-bootsec)+7C00h
  6569                                  getcbuf		equ (end_of_code + 511) & 0FE00h
  6570                                  
  6571                                  ; VGA font buffer at the end of memory (so loading a font works even
  6572                                  ; in graphics mode.)
  6573                                  vgafontbuf	equ 0E000h
  6574                                  
  6575                                  ; This is a compile-time assert that we didn't run out of space
  6576                                  %ifndef DEPEND
  6577                                  %if (getcbuf+trackbufsize) > vgafontbuf
  6578                                  %error "Out of memory, better reorganize something..."
  6579                                  %endif
  6580                                  %endif
